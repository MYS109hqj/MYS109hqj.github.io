<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>a simple blog</title>
    <url>/2023/12/12/231212blog/</url>
    <content><![CDATA[<p>(注：bing搜索随笔的英文，结果如下：<br>随笔，英文称“essay”，词源来自法文动词“essayer”，意为“尝试”、“探索”。<br>经过后继搜索，essay由短文，尝试的意思；也可作动词表企图试图<br>所以这个category绝对不是正式的论文的意思)<br>有些丧，觉得自己应该多跟人主动交流，也许现在在做的事情在自我评价体系中得不到正面反馈，要跟他人聊天，多关注周围的事情。<br>觉得这观点并不新颖，如果说概括关键词的话，扩大关注范围、刻意练习表达、频繁交际。<br>基于现在头脑中的映像，我是个喜欢单干又单干不好，兴趣点在游戏实况、游戏赛事与排球，没能在某个领域专精的人。没有频繁尝试。</p>
<p>我现在对打排球有着极高的热忱，不过毕竟排球的反馈直观地来自球，“能力不行-&gt;球垫不好-&gt;球乱飞”的链条是能轻松感受到的。也不断地在学排球的理论知识，但也改变不了目前能力不足的现况。接球嘛，看球的轨迹，移动找击球点。两天没打球，上来垫球就不知道怎么垫了，扣球不能奢望能扣准，毕竟人球关系没有高概率找好的保障，现在这个水平只要愿意尝试、练习也就够了。<br>大一下（之所以说是大一下，而非高三，主要是基于频次和技术，大一下初感觉啥也不会。之前建立的友谊也难得可贵）到现在快一年，我的技术有一定提升，能够在攻防时进行有限的移动，养成了在接球时喊一下的习惯。（经过查看知乎上几篇“关于排球打不好”的文章，启发了后续观点）但毕竟排球的每一项技术（eg.接一传）都需要基本功，需要持续练习。<br>顺带一提，在今天早一点思考时尝试验证了“反应力不行”的想法，结果如下：<a href="https://humanbenchmark.com/tests/reactiontime">反应力测试网站</a><br><img src="/2023/12/12/231212blog/reaction.png" alt="reaction" title="reaction"></p>
]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构个人复习总结</title>
    <url>/2023/12/13/231213DataStructureRecovery/</url>
    <content><![CDATA[<p>注:<a href="http://t.csdnimg.cn/HQvqN">markdown语法参考</a></p>
<p>231213第一次更新</p>
<p>一、时间复杂度<br>常见操作时间复杂度：</p>
<p>二、链表<br>线性表中，变量fence操作的是fence后面的那个元素<br><del>※fence是什么…</del></p>
<p>三、树<br>1.树的深度与高度<br>教材定义：结点的深度是从根到结点的距离(<strong>The depth of a node M in the tree is the length of the path from the root of the tree to M</strong>)，高度比最大深度大一；<br>设总层数为n，则height&#x3D;n; depth_max&#x3D;n-1。<br>网上查阅时，有些教材定义根所在层数为1的，但按用的教材定义是<strong>根所在层数是0</strong>，导致最大深度是n-1，高度不受影响还是n。（顺带一提，2-3树也一样，注意根的深度是0）<br>2.满(full)二叉树与完全(complete)二叉树<br>full binary tree，满二叉树要求每层都达到最大结点树，即结点个数是2^n-1；<br>complete binary tree，完全二叉树要求最后一层的结点必须从左到右连续，尤其以数组存储时最大结点下标为n，则n以前的有效下标都得有数据<br>(至于下标为0的就看怎么构建了，注意一下在堆中0有没有放哨兵，0不存有效数据是父子下标对应关系会变的，不过课上讲的好像没用哨兵；哨兵放比数据范围更大或更小的值，比较时哨兵就可以起到防止越界的作用)<br>3.注：普通树考点有集合union</p>
<p>四、图</p>
<p>五、散列&#x2F;哈希<br>1.open hashing，简单来说，指针存储，无限空间。别的都是closed hashing，只能在有限的哈希表里。<br>2.冲突处理Collision Resolution Methods<br>下面的都属于探测散列表(probing hash table)，对应的另一种方法是分离链接法(separate chaining)，就是存指针弄链表。<br>线性侦测法(Linear Probing)向后逐个试探,主要还是看它给的p(K,i)是什么，一般是用h(K)+p(K,i)作为下标检测是否为空&#x2F;命中。<br>对于平方探测法(quadratic probing)，课本里给的形式是通用的，可以理解为p(K,i)是二次函数，课本原话p(K,i)&#x3D;i^2是最简单平方探测法的例子。考的话应该会给p(K,i)的。（写代码用的话我是用正负i^2的）<br>（什么时候可能正负都要试，见下图：源自浙江大学MOOC数据结构的讲义）<br><img src="/2023/12/13/231213DataStructureRecovery/001.png" alt="浙江大学MOOC数据结构的讲义中关于开放地址法的描述"></p>
<p>（使用平方探测仍会产生二次聚集(secondary clustering)，为解决这个缺憾引出了双散列(double hashing)）<br>3.注：删除时要设墓碑。（但对散列要求没这么高吧，实际应用了）</p>
<p>六、索引<br>1.<a href="https://blog.csdn.net/kexuanxiu1163/article/details/87887529">2-3树</a><br>2.<a href="https://blog.csdn.net/u014453898/article/details/112469113">B-树与B+树</a>（区分：B+分别索引结点和叶子结点，所有数据都保存在叶子结点中）</p>
]]></content>
      <categories>
        <category>major</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
</search>
