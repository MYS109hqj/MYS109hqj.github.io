<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一篇简单的博客a simple blog</title>
    <url>/2023/12/12/231212blog/</url>
    <content><![CDATA[<p>(注：bing搜索随笔的英文，结果如下：<br>随笔，英文称“essay”，词源来自法文动词“essayer”，意为“尝试”、“探索”。<br>经过后继搜索，essay由短文，尝试的意思；也可作动词表企图试图<br>所以这个category绝对不是正式的论文的意思)<br>有些丧，觉得自己应该多跟人主动交流，也许现在在做的事情在自我评价体系中得不到正面反馈，要跟他人聊天，多关注周围的事情。<br>觉得这观点并不新颖，如果说概括关键词的话，扩大关注范围、刻意练习表达、频繁交际。<br>基于现在头脑中的映像，我是个喜欢单干又单干不好，兴趣点在游戏实况、游戏赛事与排球，没能在某个领域专精的人。没有频繁尝试。</p>
<p>我现在对打排球有着极高的热忱，不过毕竟排球的反馈直观地来自球，“能力不行-&gt;球垫不好-&gt;球乱飞”的链条是能轻松感受到的。也不断地在学排球的理论知识，但也改变不了目前能力不足的现况。接球嘛，看球的轨迹，移动找击球点。两天没打球，上来垫球就不知道怎么垫了，扣球不能奢望能扣准，毕竟人球关系没有高概率找好的保障，现在这个水平只要愿意尝试、练习也就够了。<br>大一下（之所以说是大一下，而非高三，主要是基于频次和技术，大一下初感觉啥也不会。之前建立的友谊也难得可贵）到现在快一年，我的技术有一定提升，能够在攻防时进行有限的移动，养成了在接球时喊一下的习惯。（经过查看知乎上几篇“关于排球打不好”的文章，启发了后续观点）但毕竟排球的每一项技术（eg.接一传）都需要基本功，需要持续练习。<br>顺带一提，在今天早一点思考时尝试验证了“反应力不行”的想法，结果如下：<a href="https://humanbenchmark.com/tests/reactiontime">反应力测试网站</a><br><img src="/2023/12/12/231212blog/reaction.png" alt="reaction" title="reaction"></p>
]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构个人复习总结</title>
    <url>/2023/12/13/231216DataStructureRecovery02/</url>
    <content><![CDATA[<p>注:<a href="http://t.csdnimg.cn/HQvqN">markdown语法参考</a></p>
<p>231217第三次更新，更新完全覆盖之前的内容，查询可以GitHub历史记录<br>单纯个人复习输出，很多图片参考<a href="https://www.icourse163.org/learn/ZJU-93001">MOOC浙江大学数据结构</a>的课件<br>同时参考任课老师<strong>吕建明</strong>的课件内容<br>由于是个人输出，基于对生疏概念复习的需求，只是<strong>有选择性</strong>的做记录，很多内容都没有包含，仅供参考。<br><strong>如果有出错或者疑问的，我愿意一同探究解惑。</strong>按道理能看到这篇博客就有我的联系方式。没有就发邮件。考虑到可能承担未妥善管控不当言论的风险，暂不考虑开评论区&#x2F;留言板。</p>
<h2 id="一、时间复杂度"><a href="#一、时间复杂度" class="headerlink" title="一、时间复杂度"></a>一、时间复杂度</h2><p>1.时间复杂度的符号（上界下界确界）<br>参考文章：<a href="https://blog.csdn.net/anshuai_aw1/article/details/108449000">https://blog.csdn.net/anshuai_aw1/article/details/108449000</a><br><img src="/2023/12/13/231216DataStructureRecovery02/018.png" alt="时间复杂度的相关符号"><br>2.常见操作时间复杂度：<br>参考<a href="http://t.csdnimg.cn/oAog6">http://t.csdnimg.cn/oAog6</a><br>链表、堆栈、队列：插入删除O(1)；查找O(n)<br>二叉搜索树：都是O(logN)<br><img src="/2023/12/13/231216DataStructureRecovery02/002.png" alt="二叉堆时间复杂度"><br><img src="/2023/12/13/231216DataStructureRecovery02/003.png" alt="邻接列表的时间复杂度"></p>
<h2 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h2><p> 1.fence:课件中的定义：”The position of a list to execute operations is defined as a fence.”栅栏体现的是当前操作的位置。不同操作对应位置会有区别，结合下图更好理解。<br><img src="/2023/12/13/231216DataStructureRecovery02/004.png" alt="操作实例"></p>
<h2 id="三、树"><a href="#三、树" class="headerlink" title="三、树"></a>三、树</h2><p>1.树的深度与高度<br>教材定义：结点的深度是从根到结点的距离(The depth of a node M in the tree is the length of the path from the root of the tree to M)，高度比最大深度大一；<br>设总层数为n，则height&#x3D;n; depth_max&#x3D;n-1。<br>网上查阅时，有些教材定义根所在层数为1的，但按用的教材定义是根所在层数是0，导致最大深度是n-1，高度不受影响还是n。（顺带一提，2-3树也一样，注意根的深度是0）<br>2.满(<strong>full</strong>)二叉树与完全(<strong>complete</strong>)二叉树<br><strong>full binary tree</strong>，满二叉树要求每层都达到最大结点树，即结点个数是2^n-1；<br><strong>complete binary tree</strong>，完全二叉树要求最后一层的结点必须从左到右连续，尤其以数组存储时最大结点下标为n，则n以前的有效下标都得有数据<br>(至于下标为0的就看怎么构建了，注意一下在堆中0有没有放哨兵，0不存有效数据是父子下标对应关系会变的，不过课上讲的好像没用哨兵；哨兵放比数据范围更大或更小的值，比较时哨兵就可以起到防止越界的作用)<br>3.注：普通树考点有集合union</p>
<h2 id="四、图"><a href="#四、图" class="headerlink" title="四、图"></a>四、图</h2><p>1.最短路径问题：<br>单源最短路径：从某固定源点出发，求其到所有其它顶点的最短路径<br>多源最短路径：求任意两顶点间的最短路径<br>有权图的单源最短路算法：Dijkstra算法<br><img src="/2023/12/13/231216DataStructureRecovery02/005.png" alt="源自MOOC浙江大学数据结构课件"><br><img src="/2023/12/13/231216DataStructureRecovery02/006.png" alt="源自MOOC浙江大学数据结构课件"><br>（多源最短路算法：Floyd算法，教材上没有，思想差不多）<br><img src="/2023/12/13/231216DataStructureRecovery02/007.png" alt="源自MOOC浙江大学数据结构课件"><br><img src="/2023/12/13/231216DataStructureRecovery02/008.png" alt="源自MOOC浙江大学数据结构课件"><br>2.最小生成树问题<br>(1)Prim算法：贪心法，每次取与邻接点间的边中的最短边<br><img src="/2023/12/13/231216DataStructureRecovery02/009.png" alt="源自MOOC浙江大学数据结构课件"><br>(2)Kruskal算法：将森林合并成树，每次取所有边中的最短边，如果不构成回路就加入。（用并查集，跟集合差不多。根结点存放-n，n表示所在集合中的元素个数；非根元素存放父亲结点，即父亲结点的下标）<br><img src="/2023/12/13/231216DataStructureRecovery02/010.png" alt="源自MOOC浙江大学数据结构课件"></p>
<h2 id="五、散列-哈希"><a href="#五、散列-哈希" class="headerlink" title="五、散列&#x2F;哈希"></a>五、散列&#x2F;哈希</h2><p>1.open hashing，简单来说，指针存储，无限空间。别的都是closed hashing，只能在有限的哈希表里。<br>2.冲突处理Collision Resolution Methods<br>下面的都属于探测散列表(probing hash table)，对应的另一种方法是分离链接法(separate chaining)，就是存指针弄链表。<br>线性侦测法(Linear Probing)向后逐个试探,主要还是看它给的p(K,i)是什么，一般是用h(K)+p(K,i)作为下标检测是否为空&#x2F;命中。<br>对于平方探测法(quadratic probing)，课本里给的形式是通用的，可以理解为p(K,i)是二次函数，课本原话p(K,i)&#x3D;i^2是最简单平方探测法的例子。考的话应该会给p(K,i)的。（写代码用的话我是用正负i^2的）<br>（什么时候可能正负都要试，见下图：源自浙江大学MOOC数据结构的讲义）<br><img src="/2023/12/13/231216DataStructureRecovery02/011.png" alt="源自MOOC浙江大学数据结构课件"><br>（使用平方探测仍会产生二次聚集(secondary clustering)，大致就是h(x)一致，为解决这个缺憾引出了双散列(double hashing)）<br>3.注：删除时要设墓碑。（但对散列要求没这么高吧，不过掌握没坏事）</p>
<h2 id="六、索引"><a href="#六、索引" class="headerlink" title="六、索引"></a>六、索引</h2><p>1.2-3树<br>具体操作可以参考下面这篇文章<br><a href="https://blog.csdn.net/kexuanxiu1163/article/details/87887529">https://blog.csdn.net/kexuanxiu1163/article/details/87887529</a><br>2.B-树与B+树（区分：B+分别索引结点和叶子结点，所有数据都保存在叶子结点中）<br><a href="https://blog.csdn.net/u014453898/article/details/112469113">https://blog.csdn.net/u014453898/article/details/112469113</a></p>
<h2 id="七、排序"><a href="#七、排序" class="headerlink" title="七、排序"></a>七、排序</h2><p>（基本术语：内部排序Internal Sorting 给内存里的排序、外部排序External Sorting 给磁盘里的排序）<br>1.简单排序<br>冒泡排序、插入排序都稳定；选择排序不稳定<br>选择排序可以优化为堆排序(O(nlogn))，快速找到最小值。<br>2.Shellsort希尔排序<br><img src="/2023/12/13/231216DataStructureRecovery02/012.png" alt="源自MOOC浙江大学数据结构课件"><br><img src="/2023/12/13/231216DataStructureRecovery02/013.png" alt="源自MOOC浙江大学数据结构课件"><br>（有归并排序mergesort这个东西，二分法思想）<br>3.快速排序QuickSort<br><img src="/2023/12/13/231216DataStructureRecovery02/014.png" alt="源自MOOC浙江大学数据结构课件"><br><img src="/2023/12/13/231216DataStructureRecovery02/015.png" alt="源自MOOC浙江大学数据结构课件"><br>4.箱&#x2F;桶排序BinSort：很像哈希（散列）的开放定址法，都是空间换时间，T(N,M)&#x3D;O(M+N)<br>5.基排序RadixSort，次位优先主位优先<br><img src="/2023/12/13/231216DataStructureRecovery02/016.png" alt="源自MOOC浙江大学数据结构课件"><br><img src="/2023/12/13/231216DataStructureRecovery02/017.png" alt="源自MOOC浙江大学数据结构课件"></p>
]]></content>
      <categories>
        <category>major</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法练习测试</title>
    <url>/2024/01/06/240106makedowntest/</url>
    <content><![CDATA[<p>引用操作</p>
<blockquote>
<p>学习内容参考文章：<a href="http://t.csdnimg.cn/hj0lV">http://t.csdnimg.cn/hj0lV</a><br>数学公式部分参考文章：<a href="https://zhuanlan.zhihu.com/p/138532124">https://zhuanlan.zhihu.com/p/138532124</a></p>
</blockquote>
<p><del>任务：1.用所学知识完成下面内容的博文的排版</del><br>（vscode表示：你用快捷键怎么能不经过我的同意？参考文章所说的快捷键适用于github的在线编辑器）<br>功能        快捷键<br>加粗        Ctrl+B<br>斜体        Ctrl+I<br>引用        Ctrl+Q<br>插入链接    Ctrl+L<br>插入代码    Ctrl+K<br>插入图片    Ctrl+G<br>提升标题    Ctrl+H<br>有序列表    Ctrl+O<br>无序列表    Ctrl+U<br>横线        Ctrl+R<br>撤销        Ctrl+Z<br>重做        Ctrl+Y</p>
<p>斜体：  <em>test</em> <em>test</em><br>粗体：  <strong>test</strong><br>倾斜加粗：  <em><strong>test</strong></em><br>下划线：    <del>test</del></p>
<hr>
<p>分级标题</p>
<p>#一级标题<br>##二级标题<br>###三级标题<br>####四级标题<br>#####五级标题<br>######六级标题</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>链接：<br>插入本地图片链接<br><img src="/2024/01/06/240106makedowntest/" alt="图片描述"><br>hexo能够使用img标签，参数有src(链接地址)、alt(文本说明)、width height等属性<br><img src="/2024/01/06/240106makedowntest/001.png" width="50%" hegiht="auto"></p>
<p>超链接就用html的a标签咯，可以连接文件如pdf，扔文件夹里，跟图片差不多<br><a href="https://mys109hqj.github.io/">这是跳转到博客首页的链接</a><br><a href="https://mys109hqj.github.io/" title="博客首页">博客首页</a></p>
<video width="480" height="320" controls>
<source src="part01-02版修正.mp4">
</video>

<p>播放音频示例：使用标签audio controls标识表示控制播放暂停<br><audio controls><br>  <source src="002.wav"><br>  您的浏览器不支持 audio 元素。<br></audio><br><audio controls src="003.wav">您的浏览器不支持 audio 元素。</audio></p>
<p>要注意的是，如果你用html格式写，必须要紧邻，不能隔行。否则hexo转html时会自动分段，导致标签出错。<br>html制作弹出框（使用javascript）</p>
<blockquote>
<p>参考CSDN文章<a href="https://blog.csdn.net/qq_35727582/article/details/114868023">https://blog.csdn.net/qq_35727582/article/details/114868023</a></p>
</blockquote>
<head>

  <style>
  /* 遮罩层 */
  #overlay {
    position: fixed;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
    font-size: 16px;
    /* IE9以下不支持rgba模式 */
    background-color: rgba(0, 0, 0, 0.5);
    /* 兼容IE8及以下 */
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#7f000000,endColorstr=#7f000000);
    display: none;
  }
  /* 弹出框主体 */
  .popup {
    background-color: #ffffff;
    max-width: 400px;
    min-width: 200px;
    height: 240px;
    border-radius: 5px;
    margin: 100px auto;
    text-align: center;
  }
  /* 弹出框的标题 */
  .popup_title {
    height: 60px;
    line-height: 60px;
    border-bottom: solid 1px #cccccc;
  }
  /* 弹出框的内容 */
  .popup_content {
    height: 50px;
    line-height: 50px;
    padding: 15px 20px;
  }
  /* 弹出框的按钮栏 */
  .popup_btn {
    padding-bottom: 10px;
  }
  /* 弹出框的按钮 */
  .popup_btn button {
    color: #778899;
    width: 40%;
    height: 40px;
    cursor: pointer;
    border: solid 1px #cccccc;
    border-radius: 5px;
    margin: 5px 10px;
    color: #ffffff;
    background-color: #337ab7;
  }
  </style>
</head>
<body>
  <button id="showPopup" onclick="showPopup()">弹出</button>
  <div id="overlay">
    <div class="popup">
      <p class="popup_title">提示</p>
      <p class="popup_content">学会制作弹出框了吗？</p>
      <div class="popup_btn">
        <button class="cancelBtn" onclick="hidePopup()">取消</button>
        <button class="confirmBtn" onclick="hidePopup()">确认</button>
      </div>
    </div>
  </div>
<script>
  function showPopup(){
    var overlay = document.getElementById("overlay");
    overlay.style.display = "block";
  }
  function hidePopup(){
    var overlay = document.getElementById("overlay");
    overlay.style.display = "none";
  }
  </script>
</body>]]></content>
      <categories>
        <category>major</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>桌游|强盗兄弟burglebros</title>
    <url>/2024/01/17/240117burglebros/</url>
    <content><![CDATA[<p>基础教学推荐bga中的教程：</p>
<p>bga中的规则书链接：（Eng）<br><a href="https://tesera.ru/images/items/1085040/BBRuleBook[MarkIII-v2.02]-Spreads.pdf">https://tesera.ru/images/items/1085040/BBRuleBook[MarkIII-v2.02]-Spreads.pdf</a><br>Burgle Bros中文化卡表链接：（需要科学上网，繁体中文。包含角色能力介绍、事件event、赃物loot、工具tool的列表）<br><a href="https://gggjms.blogspot.com/2016/03/burgle-bros_30.html">https://gggjms.blogspot.com/2016/03/burgle-bros_30.html</a></p>
<p>选定起始点<br>开局时，你可以知道一层警卫的初始位置，并选定起始点位。<br>格子位置的名称列为用字母ABCD表示，即分布为：<br>A1 B1 C1 D1<br>A2 B2 ……<br><img src="/2024/01/17/240117burglebros/001.png" alt="行列展示"></p>
<p>注：行列指示物展示打开方式<br><img src="/2024/01/17/240117burglebros/002.png" alt="行列指示物展示打开方式"></p>
<p>在玩家的第一回合，该玩家的角色出现到板块中。起始点位尽量现在路径开阔的地方。</p>
<p>警卫的寻路逻辑为：<br>目的地为巡逻卡的终点板块，如果有警报则终点改为警报位置，若有多个警报，永远先前往最近的警报，若出现等距离则由玩家选择警卫先查看的警报。<br>永远寻找最短路径。如果有多条等长最短路径，则从左侧开始，选择最顺时针的路径。<br>（原文：The Guard always takes the shortest possible path to the destination. If more than one path is equally short, the Guard takes the path that is the most clockwise, starting from the Guard’s left）<br>一层的警卫初始为2动、二层3动、三层4动；巡逻牌耗尽重洗时基础移动速度加一，如一层警卫在一层巡逻卡耗尽重洗后变为3动。基础移动速度上限为6，速度为几则一次行动有几动。1动可以移动一个板块。若该层有警报，则在警卫原有速度基础上，每有一个警报增加1动。</p>
<p>角色的个人技能：（以bga无进阶版本）<br>鹰眼：每轮可以免费查看一个相邻的隔墙板块。（探图神技）<br><img src="/2024/01/17/240117burglebros/THE_HAWK.png" alt="侦察专家 鹰眼 THE_HAWK"><br>渡鸦：可以在两步距离内放置一个乌鸦，警卫经过该格时多消耗一个步数。放置乌鸦的操作免费，如果不移动乌鸦乌鸦将在格子停留。注意：若乌鸦与警卫起点在同一格，警卫离开该格时乌鸦不起作用。若再次经过正常起作用。（控警卫技能）<br><img src="/2024/01/17/240117burglebros/THE_RAVEN.png" alt="渡鸦 THE_RAVEN"><br>观察者：可以花费一个行动点，查看本层警卫的下一张巡逻终点牌，并选择是否将其放到牌堆底部。（控警卫技能）<br><img src="/2024/01/17/240117burglebros/THE_SPOTTER.png" alt="观察者 THE_SPOTTER"><br>杂技演员：可以免费移动到一步内的警卫所在格，此操作不扣除隐秘标记。但是如果回合结束仍在警卫所在格，仍然正常扣除隐秘标记。（跑图神技）<br><img src="/2024/01/17/240117burglebros/THE_ACROBAT.png" alt="杂技演员 THE_ACROBAT"><br>主谋（骗子）：每回合可以花费一点行动，使一个同伴移动一格。移动仍要遵循基本规则，但（移动到激光检测与门栓时）不用耗费额外点数。（跑图技能）<br><img src="/2024/01/17/240117burglebros/THE_ROOK.png" alt="骗子 THE_ROOK"><br>小偷：在自己开保险箱或者数字门锁时可以多一个骰子。（更容易完成骰子检定）<br><img src="/2024/01/17/240117burglebros/THE_PETERMAN.png" alt="小偷 THE_PETERMAN"><br>钻机安装员：开始持有炸药（可以炸毁相邻墙壁，并在所在格发出警报）。所有玩家获得道具时可以查看两个道具之后保留一个（原本是直接抽一个）。（提供道具上的优势）<br><img src="/2024/01/17/240117burglebros/THE_RIGGER.png" alt="钻机安装员 THE_RIGGER"><br>照明专家：可以免费在相邻格制造一个警报。（控警卫技能）<br><img src="/2024/01/17/240117burglebros/THE_JUICER.png" alt="照明专家 THE_JUICER"><br>黑客：不会触发指纹、激光、动作检测警报（热感应警报与物品检测器仍正常触发），队友不会在自己所在格触发警报。<br><img src="/2024/01/17/240117burglebros/THE_HACKER.png" alt="黑客 THE_HACKER"></p>
<p>玩家在自己的回合内可以选择执行以下行动：<br>一般情况下，玩家有4动。可以选择花1动偷看相邻板块（不能隔墙看）；花1动移动到相邻板块（并进行进入板块的相关判定）；使用角色技能；免费使用道具卡（tool）；在保险箱（safe）板块花1动掷骰子或2动增加骰子；在机房板块进行黑客行动获取相应骇客标记。<br>在玩家的行动回合结束后，进行事件判定。当该轮玩家只使用2动及以下时，触发事件（持有赃物邮票stamp时是3动及以下都会触发事件）。抽取事件卡。之后移动角色结束时所在楼层的警卫。</p>
<p>接下来是各个房间介绍：<br>黄色卡牌：<br>ATRIUM 中庭<br>在中庭板块，可以偷看上一层或下一层相同位置的板块。但同时可以被上一层或下一层的警卫走到对应板块发现。<br>FOYER 门厅</p>
<blockquote>
<p>foyer : a large open area just inside the entrance of a public building such as a theatre or a hotel, where people can wait and meet each other（剧院、宾馆等公共建筑物入口处内的）门厅</p>
</blockquote>
<p>如果你在门厅板块，警卫可以从相邻板块发现你。若警卫在同一轮次从相邻板块移动到门厅，视为再次被发现，再次扣除一个隐匿标记。</p>
<table rules="none" align="center">
    <tr>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/atrium.png" width="60%">
                <br>
                <font color="AAAAAA">atrium</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/foyer.png" width="60%">
                <br>
                <font color="AAAAAA">foyer</font>
            </center>
        </td>
    </tr>
</table>

<p>蓝色卡牌：<br>LABORATORY 实验室<br>当板块被发现时，在板块上放置一个道具标记。第一个到达该板块的角色抽取一张道具牌。<br>LAVATORY 公共厕所<br>板块上初始有三个隐匿标记。角色在这个板块上被发现时，消耗板块上的标记。（道具：烟雾弹的效果同理）<br>WALKWAY 过道<br>如果该板块没被提前偷看，而是在行动中被揭示，则角色往下摔落一层。（若已经在最底层则无事发生）摔落到下面一层不视作正常进入板块，不进行进入板块的相关判定（不会触发警报，若该板块有警卫也不会丢失隐匿标记）。 另外，角色可以通过这个板块单向向下移动（只能从上往下，特定“事件”下能够双向）。</p>
<table rules="none" align="center">
    <tr>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/laboratory.png" width="60%">
                <br>
                <font color="AAAAAA">laboratory</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/lavatory.png" width="60%">
                <br>
                <font color="AAAAAA">lavatory</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/walkway.png" width="60%">
                <br>
                <font color="AAAAAA">walkway</font>
            </center>
        </td>
    </tr>
</table>

<p>棕色卡牌：<br>SECRET DOOR 秘密通道<br>在相邻板块，可以越过墙移动到该板块内。注意只能单向移动。警卫不能通过秘密通道移动。<br>SERVICE DUCT 服务&#x2F;维修管道<br>在两个服务管道板块都被发现后，在该板块上可以花费一点行动移动到管道的另一端（即另一个服务管道板块上）。<br>若携带赃物：名画，携带的玩家无法使用上述两个板块的功能。</p>
<table rules="none" align="center">
    <tr>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/secret_door.png" width="60%">
                <br>
                <font color="AAAAAA">secret_door</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/service_duct.png" width="60%">
                <br>
                <font color="AAAAAA">service_duct</font>
            </center>
        </td>
    </tr>
</table>

<p>警报类卡牌：<br>CAMERA 摄像机<br>若建筑中有警卫在任一摄像机板块，角色进入摄像机板块将触发警报。<br>DETECTOR 探测器<br>携带道具或脏物(loot)时进入板块会触发警报<br>THERMO 热感应器<br>如果回合结束停留在这一板块，触发警报。（持有赃物“同位素”时只要经过就会触发警报）<br>FINGERPRINT 指纹检测 （有对应机房）<br>进入就会触发警报。可使用一个在机房进行黑客行动获得的骇客标记来取消这次警报。<br>LASER 激光检测<br>进入（1动）需要另外花费一动才能不触发警报。可以选择不消耗额外行动，直接触发警报；或使用黑客标记。<br>MOTION 运动检测<br>移入该板块后，若在该回合移动出此板块，触发警报。可以使用黑客标记；也可以通过下一回合再移动躲避警报。<br>注意，如果有触发警报，该层警卫的巡逻终点会立即改为警报点（警报详细介绍见上文），当前的巡逻地点卡会被废除。在适当时机触发警报也许可以营救队友于水火之中。</p>
<table rules="none" align="center">
    <tr>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/camera.png" width="60%">
                <br>
                <font color="AAAAAA">camera</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/detector.png" width="60%">
                <br>
                <font color="AAAAAA">detector</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/thermo.png" width="60%">
                <br>
                <font color="AAAAAA">thermo</font>
            </center>
        </td>
                <td>
            <center>
                <img src="/2024/01/17/240117burglebros/fingerprint.png" width="60%">
                <br>
                <font color="AAAAAA">fingerprint</font>
            </center>
        </td>
                <td>
            <center>
                <img src="/2024/01/17/240117burglebros/laser.png" width="60%">
                <br>
                <font color="AAAAAA">laser</font>
            </center>
        </td>
                <td>
            <center>
                <img src="/2024/01/17/240117burglebros/motion.png" width="60%">
                <br>
                <font color="AAAAAA">motion</font>
            </center>
        </td>
    </tr>
</table>
对应机房：
可以在对应机房中消耗一动获取一个对应骇客标记。注意三种标记与三种警报类型一一对应。
（标记：可以在触发对应类型警报时选择消耗一个标记，取消这次警报）
<table rules="none" align="center">
    <tr>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/hack_fingerprint.png" width="60%">
                <br>
                <font color="AAAAAA">hack_fingerprint</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/hack_laser.png" width="60%">
                <br>
                <font color="AAAAAA">hack_laser</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/hack_motion.png" width="60%">
                <br>
                <font color="AAAAAA">hack_motion</font>
            </center>
        </td>
    </tr>
</table>

<p>楼梯与保险箱：<br>STAIRS 楼梯<br>通过该板块可以上楼。从楼上对应板块也能下楼。上楼视为进入上面一层的对应板块。在顶层时，当团队收集完赃物后（必须都在身上），可以通过楼梯逃脱（逃脱同样消耗一动）。<br>SAFE 保险箱<br>一动投骰子，两动加骰子。所处行列的房间（需要被揭示）右下角对应的数字都被摇出过一次后才能打开保险箱，获得一个道具卡（tool）和一个有特殊效果的赃物（loot）。</p>
<table rules="none" align="center">
    <tr>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/stairs.png" width="60%">
                <br>
                <font color="AAAAAA">stairs</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/safe.png" width="60%">
                <br>
                <font color="AAAAAA">safe</font>
            </center>
        </td>
    </tr>
</table>

<blockquote>
<p>赃物列表<br><a href="https://gggjms.blogspot.com/2016/03/burgle-bros-loot.html">https://gggjms.blogspot.com/2016/03/burgle-bros-loot.html</a><br><img src="/2024/01/17/240117burglebros/loot.png" height="30%"><br>工具列表<br><a href="https://gggjms.blogspot.com/2016/03/tool-event-loot-tool-blueprints-crowbar.html">https://gggjms.blogspot.com/2016/03/tool-event-loot-tool-blueprints-crowbar.html</a><br><img src="/2024/01/17/240117burglebros/tool.png" height="30%"><br>事件列表<br><a href="https://gggjms.blogspot.com/2016/03/burgle-bros_30.html">https://gggjms.blogspot.com/2016/03/burgle-bros_30.html</a><br><img src="/2024/01/17/240117burglebros/event.png" height="30%"></p>
</blockquote>
]]></content>
      <categories>
        <category>game</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>短时轻策桌游推荐|Faraway： 介绍/教程</title>
    <url>/2024/02/07/240207faraway/</url>
    <content><![CDATA[<h2 id="Faraway游戏介绍"><a href="#Faraway游戏介绍" class="headerlink" title="Faraway游戏介绍"></a>Faraway游戏介绍</h2><h3 id="游戏简介"><a href="#游戏简介" class="headerlink" title="游戏简介"></a>游戏简介</h3><p>Faraway是2023年新上线的桌游，是一款<strong>轻度策略</strong>的，<strong>支持2-6人游玩</strong>的桌游。玩家一同前往阿鲁拉岛屿，争取在岛民中取得更多的名誉。<strong>游戏时长2-3人时5-15分钟，人数多时20-30分钟</strong>。<br>这个桌游<strong>“顺序放置——逆向结算”的基本玩法</strong>十分新颖；游戏过程中需要在<strong>保持数字顺序、满足居民的计分条件与区域卡牌的优先选择权</strong>三者相互制衡。<br>在了解基本的计分规则后，新手也能打出一定的combo，很好上手；对于老手，不同组合、追求分数上限也让这个游戏有可玩性和重开性。<br><strong>游戏有一定运气成分</strong>，<strong>在3人及以上的游戏中选牌的交涉尤为突出</strong>，线下玩也有追求合作共赢的空间。<br>线下玩这个游戏有个缺点，就是计分极其繁琐，线上网站结算阶段“公开处刑”，简化了繁琐的计分过程。</p>
<p>bga上游戏链接：<a href="https://boardgamearena.com/gamepanel?game=faraway">https://boardgamearena.com/gamepanel?game=faraway</a><br>注：bga为免费在线桌游平台，注册时别用qq邮箱就行。</p>
<p>下面部分是自拟图文教程，以及其它教程的参考链接</p>
<h3 id="基础教程部分"><a href="#基础教程部分" class="headerlink" title="基础教程部分"></a>基础教程部分</h3><p>（本部分结尾有规则书pdf；内容结构为：游戏设定补充、图文教程、其它教程链接）<br><strong>游戏设定补充：</strong>（参照规则书Page1-2）<br>ALULA（阿鲁拉）的岛屿位置可以任意变化，使得任何行动路线都有可能。探索的方式只有行走。<br>这里的岛民有些说原住民，有些是定居的探索者。他们各自独立看守一个岛屿，他们热情招待到来的探索者，并且喜欢谈论有关Uddu（矿产资源，即蓝色标志），Okiko（动物，即红色标志），Goldlog（植物，即绿色标志）的最新发现。（因此获得名誉值的条件会和返回路上岛屿上的这些标志内容有关。）<br>阿鲁拉有四种生物群系：河流（红色区域）、城市（黄色区域）、森林（红色区域）、(岩石)沙漠（蓝色区域）。每个生物群系都有自己独特的季节规律。<strong>（因此获得名誉值的条件会和返回路上的岛屿的生物群系有关。）</strong></p>
<img src="/2024/02/07/240207faraway/001.png" width="50%" hegiht="auto">
<img src="/2024/02/07/240207faraway/002.png" width="50%" hegiht="auto">
<img src="/2024/02/07/240207faraway/003.png" width="50%" hegiht="auto">
<img src="/2024/02/07/240207faraway/004.png" width="50%" hegiht="auto">
<img src="/2024/02/07/240207faraway/005.png" width="50%" hegiht="auto">
<img src="/2024/02/07/240207faraway/006.png" width="50%" hegiht="auto">
<img src="/2024/02/07/240207faraway/007.png" width="50%" hegiht="auto">
<img src="/2024/02/07/240207faraway/008.png" width="50%" hegiht="auto">

<p><strong>这个游戏也有进阶选项，开局每位玩家分别分到5张区域牌，每位玩家自由进行5选3，即放弃两张区域牌。被放弃的区域牌洗回区域牌堆中。熟悉游戏基本机制后建议启用，可以提升游戏体验。</strong></p>
<p>其它的中文教程推荐：<br>视频教程：（b站）<br><a href="https://www.bilibili.com/video/BV1694y1h7Yp">https://www.bilibili.com/video/BV1694y1h7Yp</a><br>图文教程：（b站）<br><a href="https://www.bilibili.com/read/cv27286594/">https://www.bilibili.com/read/cv27286594/</a><br>规则书链接：<br><a href="Faraway-rules-EN.pdf">规则书(en)pdf</a></p>
<h3 id="个人向Faraway进阶部分（附区域-圣殿图片集）"><a href="#个人向Faraway进阶部分（附区域-圣殿图片集）" class="headerlink" title="个人向Faraway进阶部分（附区域&#x2F;圣殿图片集）"></a>个人向Faraway进阶部分（附区域&#x2F;圣殿图片集）</h3><h4 id="个人游戏理解"><a href="#个人游戏理解" class="headerlink" title="个人游戏理解"></a>个人游戏理解</h4><p><strong>在2人对局中，选牌阶段的干扰相对较少</strong>（毕竟是总数N+1，N个人选，2人也是理论干扰最小的），很容易拿到自己想要的牌。经常出现每有干扰的局面。游戏也进行地非常迅速，可以把它称为“自由刷分”的局面，无疑容易出现高分对决的情景。<br>但要是涉及到对抗，那就有“长考”（较长地思考）了:);<br><strong>人数越多，对抗越激烈，你也更有可能没法拿到想要的牌。在这时候小数字先拿牌的优势就体现出来了</strong><br><img src="/2024/02/07/240207faraway/009.png" alt="自由刷分示例" width="50%" hegiht="auto"><br><strong>保持区域卡数字的升序，可以拿到尽可能多的圣殿卡</strong>，圣殿卡可以提供额外资源（即三色标志、线索）与区域（四色+夜晚），提供额外的计分项目。足够数量的圣殿卡能让你取得更高的分数。<br><img src="/2024/02/07/240207faraway/010理论升序.png" alt="升序数字理论" width="50%" height="auto"><br><strong>起手牌数字小并</strong>且<strong>得分条件有一定上限</strong>，<strong>数字小又可以优先选牌</strong>。不过“理论升序”拿满7张圣殿牌也得有一定运气了。<br><img src="/2024/02/07/240207faraway/011起手大牌升序.png" alt="大牌起手理论上限" width="50%" height="auto"><br>虽然<strong>理论上限高</strong>，但<strong>风险在于圣殿不刷植物（需要的标志）与对手的争夺（数字太大了，多人游戏最后选牌，想要的经常被选走）</strong>。在这个例子中如果别人不跟你抢，植物（绿标志）刷的适中，就可以打出效果。（<strong>风险就是（绿标志）原本就少还刷的少+被对手针对抢牌；居民的要求迟迟不能满足时就得考虑保下限了</strong>）</p>
<h4 id="区域-圣殿图片集"><a href="#区域-圣殿图片集" class="headerlink" title="区域&#x2F;圣殿图片集"></a>区域&#x2F;圣殿图片集</h4><blockquote>
<p>图片来源链接:<a href="https://imgur.com/paAf8ih">https://imgur.com/paAf8ih</a>与<a href="https://imgur.com/KOvyJSP">https://imgur.com/KOvyJSP</a>（需要科学上网访问）<br><img src="/2024/02/07/240207faraway/place.jpeg" alt="区域卡牌集合"><br><img src="/2024/02/07/240207faraway/shelter.jpeg" alt="圣殿卡牌集合"><br>68张区域卡中，一共只有10个绿标志（植物），14个红标志（动物），18个蓝标志（矿产），18条线索，数字20-40是夜晚；46张圣殿卡中，一共只有5个绿标志（植物），6个红标志（动物），9个蓝标志（矿产），8条线索，4张夜晚。<br>至于板块颜色（景观&#x2F;生物群系）方面，颜色分布均匀，区域卡中四色各17张，圣殿卡中四色各5张。<br>由此可以建立对游戏更深的、定量的认识。与朋友一同游玩时一起参考集合图片也未尝不可。</p>
</blockquote>
]]></content>
      <categories>
        <category>game</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找相同图案——本地对战版 | Find same patterns</title>
    <url>/2024/02/26/240226Find-same-patterns/</url>
    <content><![CDATA[<p>2403021056更新版本<br>注：已知问题:关闭各窗口后0-5秒后才完全关闭，在此期间窗口覆盖部分可能暂时无法点击<br>设置可以调卡牌正面显示时间与难度；切换难度自动重新开始游戏。</p>
<script type="text/javascript">
function SetCwinHeight(){
  var iframeid = document.getElementById("iframeid"); //iframe id
  if (document.getElementById) {
    if (iframeid && !window.opera) {
      if (iframeid.contentDocument && iframeid.contentDocument.body.offsetHeight) {
        iframeid.height = iframeid.contentDocument.body.offsetHeight + 50;
      } else if (iframeid.Document && iframeid.Document.body.scrollHeight) {
        iframeid.height = iframeid.Document.body.scrollHeight + 50;
      }
    }
  }
}
</script>

<iframe width="100%" id="iframeid" onload="Javascript:SetCwinHeight()" scrolling="yes" height="1300" frameborder="0" src=".\Find_same_patterns.html"></iframe>
]]></content>
      <categories>
        <category>game</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>依据信息视频的抢答游戏 | responder game</title>
    <url>/2024/02/14/240214responder-game/</url>
    <content><![CDATA[<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        .image-container {
            width: 240px; /* 设置图片容器宽度 */
            height: 320px; /* 设置图片容器高度 */
            overflow: hidden; /* 隐藏溢出部分 */
        }
        .image-container img {
            width: 240px; /* 设置图片宽度为容器宽度 */
            height: 320px; /* 设置图片高度为容器高度 */
            object-fit: fill; /* 填充满容器，不保持宽高比 */
            object-position: center; /* 图片居中 */
        }
          /* 遮罩层 */
  .overlay {
    position: fixed;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
    font-size: 16px;
    /* IE9以下不支持rgba模式 */
    background-color: rgba(0, 0, 0, 0.5);
    /* 兼容IE8及以下 */
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#7f000000,endColorstr=#7f000000);
    display: none;
  }
  /* 弹出框主体 */
  .popup {
    background-color: #ffffff;
    max-width: 80%;
    min-width: 50%;
    height: auto;
    border-radius: 5px;
    margin: 100px auto;
    text-align: center;
  }
  /* 弹出框的标题 */
  .popup_title {
    height: 60px;
    line-height: 60px;
    border-bottom: solid 1px #cccccc;
  }
  /* 弹出框的内容 */
  .popup_content {
    height: 80%;
    line-height: 50px;
    padding: 15px 20px;
  }
  /* 弹出框的按钮栏 */
  .popup_btn {
    padding-bottom: 10px;
  }
  /* 弹出框的按钮 */
  .popup_btn button {
    color: #778899;
    width: 40%;
    height: 40px;
    cursor: pointer;
    border: solid 1px #cccccc;
    border-radius: 5px;
    margin: 5px 10px;
    color: #ffffff;
    background-color: #337ab7;
  }
  </style>
</head>
<body>
  抢答游戏<br>
  注：点击每道题的音频开始计时，按下选项按钮停止计时；点击查看答案按钮后该题数据会汇总到最后的表格。<br>
  一旦按下按钮，即锁定答案，同时时间也会暂停，该组按钮也不能再次使用。请慎重选择按下按钮的时机。完成游戏后可以分享汇总表格。（实在误触，刷新后按钮会重置，做过的题点查看答案可以恢复记录；但你重做可能题目的记录就会重置）<button onclick="clearLocalStorage()">清除记录</button>清除记录按钮就是清除缓存从而清除时间记录<br>
    <p>游戏规则：
      这里有十一张有关恐怖游戏的海报，以及为它们作出的歌词，但是它们被弄混了。
      首先，你会看一段视频，接着回答八道题目。每一道题目都会三张备选的游戏海报，
      你必须找出所听到的歌词描述的那张海报。一旦你确定答案，立刻进行抢答，
      最快答对的玩家可以获得一分，累计分数最高的玩家获胜。
      但是请注意，对于特定的游戏海报，为其而作出的曲子未必只有一首。
      在此之前，我会展示主题为“恐怖游戏的冰山一角”的短片，
      它将介绍所有海报上的游戏。</p><br>
      短片及海报栏：<br>
<iframe src="//player.bilibili.com/player.html?aid=1051059492&bvid=BV1EH4y177DN&cid=1450590252&p=1" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"> </iframe>
            <table>
                <tr>
                    <td><img src="/2024/02/14/240214responder-game/002Amnesia.jpg" alt="Amnesia" height="320" width="240"></td>
                    <td><img src="/2024/02/14/240214responder-game/003FNAF02.jpg" alt="FNAF" height="320" width="240"> </td>
                    <td><img src="/2024/02/14/240214responder-game/004Outlast.jpg" alt="Outlast" height="320px" width="240px"></td>
                    <td><img src="/2024/02/14/240214responder-game/005the last of us.jpeg" alt="The Last Of Us" height="320" width="240"></td>
                </tr>
                <tr>
                    <td><img src="/2024/02/14/240214responder-game/007bioshock.jpg" alt="Bioshock" height="320px" width="240px"></td>
                    <td><img src="/2024/02/14/240214responder-game/008slient hill.jpg" alt="Slient Hill" height="320px" width="240px"></td>
                    <td><img src="/2024/02/14/240214responder-game/009heavy rain.jpg" alt="Heavy Rain" height="320px" width="240px"></td>
                    <td><img src="/2024/02/14/240214responder-game/010earth bound.jpg" alt="Earth Bound" height="320px" width="240px"></td>
                </tr>
                <tr>
                    <td><img src="/2024/02/14/240214responder-game/011Majora's mask.jpg" alt="Majora's Mask" height="320px" width="240px"></td>
                    <td><img src="/2024/02/14/240214responder-game/012UntilDawn.jpg" alt="UntilDawn" height="320px" width="240px"></td>
                    <td><img src="/2024/02/14/240214responder-game/013dying light.jpg" alt="Dying Light" height="320px" width="240px"></td>
                    <td></td>
                </tr>
            </table>
    <br>
    Q1:
    <audio controls>
      <source src="012.wav">
      您的浏览器不支持 audio 元素。
    </audio><br>
    <table>
      <tr class="image-container">
        <td><img src="/2024/02/14/240214responder-game/012UntilDawn.jpg" alt width="30%"></td>
        <td><img src="/2024/02/14/240214responder-game/008slient hill.jpg" alt width="30%"></td>
        <td><img src="/2024/02/14/240214responder-game/003FNAF02.jpg" alt width="30%"></td>
      </tr>
      <tr>
        <td><button class="Q1" onclick="selectOption('Q1', 'A')">A</button></td>
        <td><button class="Q1" onclick="selectOption('Q1', 'B')">B</button></td>
        <td><button class="Q1" onclick="selectOption('Q1', 'C')">C</button></td>
      </tr>
    </table>
    <button id="showPopup1" onclick="showPopup('popup1');showSelection('Q1')">查看答案1</button>
    <br>
    <div id="overlay1" class="overlay">
      <div id="popup1" class="popup">
        <p class="popup_title">歌词原文及答案</p>
        <p class="popup_content" align="left">
          <img src="/2024/02/14/240214responder-game/012UntilDawn.jpg" alt="UntilDawn" align="right" width="30%">
        Story and atmosphere, 80s serial killer's reign,<br>
        College kids on a mountain, where dangers remain,<br><br>
        Survive or die trying, their fate intertwines,<br>
        On this vacation, terror creeps and confines.<br><br>
        Decisions weigh heavy, escape death's might,<br>
        Survival's uncertain, in the face of the night.<br><br>
        In this gripping tale, life hangs by a thread,<br>
        Until the dawn breaks, hope clings to their breath.<br><br>
        <div id="answerQ1"></div>
        <div>正确答案是：A</div>
        <div id="timerQ1"></div>
</p>
        <div class="popup_btn">
          <button class="confirmBtn" onclick="hidePopup('popup1')">确认</button>
        </div>
      </div>
    </div>
  <br>
    Q2:
    <audio controls>
      <source src="004.wav">
      您的浏览器不支持 audio 元素。
    </audio>
    <table>
      <tr class="image-container">
        <td><img src="/2024/02/14/240214responder-game/011Majora's mask.jpg" alt width="30%"></td>
        <td><img src="/2024/02/14/240214responder-game/005the last of us.jpeg" alt width="30%"></td>
        <td><img src="/2024/02/14/240214responder-game/004Outlast.jpg" alt width="30%"></td>
      </tr>
      <tr>
          <td><button class="Q2" onclick="selectOption('Q2', 'A')">A</button></td>
          <td><button class="Q2" onclick="selectOption('Q2', 'B')">B</button></td>
          <td><button class="Q2" onclick="selectOption('Q2', 'C')">C</button></td>
        
      </tr>
    </table>
    <br>
    <div id="overlay2" class="overlay">
      <div id="popup2" class="popup">
        <p class="popup_title">歌词原文及答案</p>
        <p class="popup_content" align="left">
          <img src="/2024/02/14/240214responder-game/004Outlast.jpg" alt="Outlast" align="right" width="30%">
          No way to fight, just helpless prey,<br>
          Facing the attacker, at the end of each day.<br><br>
          Investigate through pages, journal unfolds,<br>
          Mental hospital's secrets, stories untold,<br><br>
          Another journey, to find his lost wife,<br>
          Surviving the madness, an unyielding strife.<br><br>
          A new trial awaits, escape is the aim,<br>
          Outlast's sequel, a test of survival's flame.<br><br> 
          <div id="answerQ2"></div>
          <div>正确答案是：C</div>
          <div id="timerQ2"></div>
</p>
        <div class="popup_btn">
          <button class="confirmBtn" onclick="hidePopup('popup2')">确认</button>
        </div>
      </div>
    </div>
    <button id="showPopup2" onclick="showPopup('popup2');showSelection('Q2')">查看答案2</button>
<br>
Q3:
<audio controls>
  <source src="010.wav">
  您的浏览器不支持 audio 元素。
</audio><br>
<table>
  <tr class="image-container">
    <td><img src="/2024/02/14/240214responder-game/013dying light.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/010earth bound.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/002Amnesia.jpg" alt width="30%"></td>
  </tr>
  <tr>
    <td><button class="Q3" onclick="selectOption('Q3', 'A')">A</button></td>
    <td><button class="Q3" onclick="selectOption('Q3', 'B')">B</button></td>
    <td><button class="Q3" onclick="selectOption('Q3', 'C')">C</button></td>
  </tr>
</table>
<br>
<div id="overlay3" class="overlay">
  <div id="popup3" class="popup">
    <p class="popup_title">歌词原文及答案</p>
    <p class="popup_content" align="left">
      <img src="/2024/02/14/240214responder-game/010earth bound.jpg" alt="Earth Bound" align="right" width="30%">
    A classic RPG tale, a journey begins,<br>
    Unveiling a world where darkness and light thins,<br><br>
    From childhood's torment, a masterpiece arose,<br>
    Inspiring countless games, where fear overflows,<br><br>
    In a wrong turn theater, a scene so raw,<br>
    Bloody horror's grip, an unsettling awe.<br><br>
    In a world unknown, darkness sends its signs,<br>
     Final boss Giygas, Earthbound's epic final binds.<br><br>
     <div id="answerQ3"></div>
     <div>正确答案是：B</div>
     <div id="timerQ3"></div>
</p>
    <div class="popup_btn">
      <button class="confirmBtn" onclick="hidePopup('popup3')">确认</button>
    </div>
  </div>
</div>
<button id="showPopup3" onclick="showPopup('popup3');showSelection('Q3')">查看答案3</button>
<br>
<br>
Q4:
<audio controls>
  <source src="007.wav">
  您的浏览器不支持 audio 元素。
</audio><br>
<table>
  <tr class="image-container">
    <td><img src="/2024/02/14/240214responder-game/009heavy rain.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/008slient hill.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/007bioshock.jpg" alt width="30%"></td>
  </tr>
  <tr>
    <td><button class="Q4" onclick="selectOption('Q4', 'A')">A</button></td>
    <td><button class="Q4" onclick="selectOption('Q4', 'B')">B</button></td>
    <td><button class="Q4" onclick="selectOption('Q4', 'C')">C</button></td>
  </tr>
</table>
<br>
<div id="overlay4" class="overlay">
  <div id="popup4" class="popup">
    <p class="popup_title">歌词原文及答案</p>
    <p class="popup_content" align="left">
      <img src="/2024/02/14/240214responder-game/007bioshock.jpg" alt="Bioshock" align="right" width="30%">
      Jack on a plane, crashes through ocean tide,<br>
      Lost in the waves, secrets stirring inside,<br><br>
      Plasmids empower, superhuman might prevails,<br>
      In this underwater city, an epic tale unveils.<br><br>
      Little sisters, Big daddies, a haunting scene,<br>
      Survival in Rapture, where nightmares convene.<br><br>
      In this subaquatic world, darkness takes its toll,<br>
      Bioshock's legend, forever etched in soul.<br><br>
     <div id="answerQ4"></div>
     <div>正确答案是：C</div>
     <div id="timerQ4"></div>
</p>
    <div class="popup_btn">
      <button class="confirmBtn" onclick="hidePopup('popup4')">确认</button>
    </div>
  </div>
</div>
<button id="showPopup4" onclick="showPopup('popup4');showSelection('Q4')">查看答案4</button>
<br>
<br>
Q5:
<audio controls>
  <source src="008.wav">
  您的浏览器不支持 audio 元素。
</audio><br>
<table>
  <tr class="image-container">
    <td><img src="/2024/02/14/240214responder-game/008slient hill.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/004Outlast.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/013dying light.jpg" alt width="30%"></td>
  </tr>
  <tr>
    <td><button class="Q5" onclick="selectOption('Q5', 'A')">A</button></td>
    <td><button class="Q5" onclick="selectOption('Q5', 'B')">B</button></td>
    <td><button class="Q5" onclick="selectOption('Q5', 'C')">C</button></td>
  </tr>
</table>
<br>
<div id="overlay5" class="overlay">
  <div id="popup5" class="popup">
    <p class="popup_title">歌词原文及答案</p>
    <p class="popup_content" align="left">
      <img src="/2024/02/14/240214responder-game/008slient hill.jpg" alt="Slient Hill" align="right" width="30%">
      Here come an iconic survival series,<br>
      Where psychological horror pierces and freezes,<br><br>
      Enter the second game, a journey through despair,<br>
      Depression and frustration, emotions laid bare,<br><br>
      Pyramid Head, an iconic figure emerges,<br>
      Symbolic of guilt, torment never purges,<br><br>
      Surviving the psychological abyss, we remain,<br>
      Forever gripped by Silent Hill's chilling reign.<br><br>
     <div id="answerQ5"></div>
     <div>正确答案是：A</div>
     <div id="timerQ5"></div>
</p>
    <div class="popup_btn">
      <button class="confirmBtn" onclick="hidePopup('popup5')">确认</button>
    </div>
  </div>
</div>
<button id="showPopup5" onclick="showPopup('popup5');showSelection('Q5')">查看答案5</button>
<br>
<br>
Q6:
<audio controls>
  <source src="005.wav">
  您的浏览器不支持 audio 元素。
</audio><br>
<table>
  <tr class="image-container">
    <td><img src="/2024/02/14/240214responder-game/005the last of us.jpeg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/013dying light.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/012UntilDawn.jpg" alt width="30%"></td>
  </tr>
  <tr>
    <td><button class="Q6" onclick="selectOption('Q6', 'A')">A</button></td>
    <td><button class="Q6" onclick="selectOption('Q6', 'B')">B</button></td>
    <td><button class="Q6" onclick="selectOption('Q6', 'C')">C</button></td>
  </tr>
</table>
<br>
<div id="overlay6" class="overlay">
  <div id="popup6" class="popup">
    <p class="popup_title">歌词原文及答案</p>
    <p class="popup_content" align="left">
      <img src="/2024/02/14/240214responder-game/005the last of us.jpeg" alt="The Last Of Us" align="right" width="30%">
      A fungus-born plague, infecting all around,<br>
      Survival is the game, in this post-apocalyptic ground.<br><br>
      Zombie apocalypse, relentless storm,<br>
      Joel and Ellie, thriving through reform.<br><br>
      Fungal parasitism, darkness takes hold,<br>
      Their legacy unfolds, as stories are retold.<br><br>
      Game reset, a version anew,<br>
      The Last of Us, reborn for me and you.<br><br>
     <div id="answerQ6"></div>
     <div>正确答案是：A</div>
     <div id="timerQ6"></div>
</p>
    <div class="popup_btn">
      <button class="confirmBtn" onclick="hidePopup('popup6')">确认</button>
    </div>
  </div>
</div>
<button id="showPopup6" onclick="showPopup('popup6');showSelection('Q6')">查看答案6</button>
<br>
<br>
Q7:
<audio controls>
  <source src="003.wav">
  您的浏览器不支持 audio 元素。
</audio><br>
<table>
  <tr class="image-container">
    <td><img src="/2024/02/14/240214responder-game/003FNAF02.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/007bioshock.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/011Majora's mask.jpg" alt width="30%"></td>
  </tr>
  <tr>
    <td><button class="Q7" onclick="selectOption('Q7', 'A')">A</button></td>
    <td><button class="Q7" onclick="selectOption('Q7', 'B')">B</button></td>
    <td><button class="Q7" onclick="selectOption('Q7', 'C')">C</button></td>
  </tr>
</table>
<br>
<div id="overlay7" class="overlay">
  <div id="popup7" class="popup">
    <p class="popup_title">歌词原文及答案</p>
    <p class="popup_content" align="left">
      <img src="/2024/02/14/240214responder-game/003FNAF02.jpg" alt="Five Nights At Freddy's" align="right" width="30%">
      Scott Cawthon's fright, a hop takes flight,<br>
      Previous game characters, reborn in fright.<br><br>
      Jump scares in pizzeria, dread fills the air,<br>
      From zero to six, scares beyond compare.<br><br>
      Locked in the pizzeria, cameras reveal,<br>
      Freddy, Chica, Foxy, horrors that are real.<br><br>
      Survive till dawn, facing nightmares untold,<br>
      Five Nights at Freddy's, where fear takes hold.<br><br>
     <div id="answerQ7"></div>
     <div>正确答案是：A</div>
     <div id="timerQ7"></div>
</p>
    <div class="popup_btn">
      <button class="confirmBtn" onclick="hidePopup('popup7')">确认</button>
    </div>
  </div>
</div>
<button id="showPopup7" onclick="showPopup('popup7');showSelection('Q7')">查看答案7</button>
<br>
<br>
Q8:
<audio controls>
  <source src="011.wav">
  您的浏览器不支持 audio 元素。
</audio><br>
<table>
  <tr class="image-container">
    <td><img src="/2024/02/14/240214responder-game/011Majora's mask.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/002Amnesia.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/009heavy rain.jpg" alt width="30%"></td>
  </tr>
  <tr>
    <td><button class="Q8" onclick="selectOption('Q8', 'A')">A</button></td>
    <td><button class="Q8" onclick="selectOption('Q8', 'B')">B</button></td>
    <td><button class="Q8" onclick="selectOption('Q8', 'C')">C</button></td>
  </tr>
</table>
<br>
<div id="overlay8" class="overlay">
  <div id="popup8" class="popup">
    <p class="popup_title">歌词原文及答案</p>
    <p class="popup_content" align="left">
      <img src="/2024/02/14/240214responder-game/011Majora's mask.jpg" alt="Majora's Mask" align="right" width="30%">
      In a countdown's grasp, time's running low,<br>
      Complete tasks in three days, before shadows grow.<br><br>
      Flute of Time, months pass, secrets unfold,<br>
      Find the mask, power untold.<br><br>
      Dark and disturbing elements take flight,<br>
      Ben Prowned's presence haunts, through day and night.<br><br>
      Haunting echoes linger, in each twisted turn,<br>
      Majora's Mark weaves nightmares, a world to discern.<br><br>
     <div id="answerQ8"></div>
     <div>正确答案是：A</div>
     <div id="timerQ8"></div>
</p>
    <div class="popup_btn">
      <button class="confirmBtn" onclick="hidePopup('popup8')">确认</button>
    </div>
  </div>
</div>
<button id="showPopup8" onclick="showPopup('popup8');showSelection('Q8')">查看答案8</button>
<div>答题情况汇总：（Q_绿色答对，红色误答；时间项红色为超时或误答）</div>
<table border="1">
  <tr>
    <td id="sumcfQ1">Q1</td>
    <td id="sumcfQ2">Q2</td>
    <td id="sumcfQ3">Q3</td>
    <td id="sumcfQ4">Q4</td>
  </tr>
  <tr>
    <td id="sumtimerQ1"></td>
    <td id="sumtimerQ2"></td>
    <td id="sumtimerQ3"></td>
    <td id="sumtimerQ4"></td>
  </tr>
  <tr>
    <td id="sumcfQ5">Q5</td>
    <td id="sumcfQ6">Q6</td>
    <td id="sumcfQ7">Q7</td>
    <td id="sumcfQ8">Q8</td>
  </tr>
  <tr>
    <td id="sumtimerQ5"></td>
    <td id="sumtimerQ6"></td>
    <td id="sumtimerQ7"></td>
    <td id="sumtimerQ8"></td>
  </tr>
</table>
    <script>
      function showPopup(popupId) {
          var overlay = document.getElementById("overlay" + popupId.substring(5));
          overlay.style.display = "block";
      }
      function hidePopup(popupId) {
          var overlay = document.getElementById("overlay" + popupId.substring(5));
          overlay.style.display = "none";
      }
      function selectOption(questionId, option) {
          // 禁用其他两个按钮
          var buttons = document.getElementsByClassName(questionId);
          var buttonsArray = Array.from(buttons);
          buttonsArray.forEach(function(button) {
              button.disabled = true;
          });
          // 在这里执行获取选项信息的操作
          localStorage.setItem(questionId, option);
          alert("您选择了问题 " + questionId + " 的选项 " + option);
          //按钮点击后禁用对应计时器
          //document.getElementById(audioId).removeEventListener('play', startTimer);
          //stopTimer();
          //计算时间间隔，即计时
          if(startTime==0) return;
          var endTime = new Date();
          var elapsedTime = endTime - startTime;
          startTime = 0;
          localStorage.setItem(questionId + "_time",elapsedTime); //存储时间
      }
    function showSelection(questionId) {
    var selectedOption = localStorage.getItem(questionId);
    var answerDiv = document.getElementById("answer" + questionId);
    if (selectedOption) {
        answerDiv.innerText = "您选择的选项是：" + selectedOption;
    } else {
        answerDiv.innerText = "您尚未选择任何选项！";
    }
    // 显示时间间隔 暂且log
    var elapsedTime = localStorage.getItem(questionId + "_time");
    var timerDiv = document.getElementById("timer" + questionId);
    //test:
    //console.log(elapsedTime);
    let sumtimer = document.getElementById('sumtimer'+questionId);
    if(elapsedTime==null || elapsedTime==NaN){
        timerDiv.innerText = "您并未播放过音频！";
        sumtimer.innerText = "--:--";
    }
    else if(elapsedTime > 30000){
        if(timerDiv.innerText.startsWith("用时")) {console.log("出现错误按键");return;}
        timerDiv.innerText = "已超时（超过30秒）；未播放音频直接点击选项也会出现这段文字";
        localStorage.setItem(questionId + "finaltimer",30000);
        sumtimer.innerText = "30:00";
        sumtimer.style.color="red";
    }
    else{
        let seconds =Math.floor(elapsedTime/1000);
        let miliseconds = Math.floor(elapsedTime/10%100);
        timerDiv.innerText = "用时："+seconds+":"+miliseconds;
        localStorage.setItem(questionId + "finaltimer",elapsedTime);
        sumtimer.innerText =seconds+":"+miliseconds;
        sumtimer.style.color="black";
    }
    check(questionId);
    //test:
    console.log("从点击播放按钮到点击答案按钮的时间间隔：" + elapsedTime + "毫秒");
  }
  function clearLocalStorage() {
    localStorage.clear();
    alert("成功清除缓存")
  }
    var timer;
    var startTime;
    function startTimer(){
        startTime = new Date();
        //timer = setInterval(updatetimer,1000);
        //test:
        //console.log(startTime);
    }
    function stopTimer(){
        //clearInterval(timer);
    }
    //监听器，播放按钮被点击时触发
    document.querySelectorAll('audio').forEach(function(audio) {
        audio.addEventListener('play', startTimer);
    });
    function check(questionId){
      var AnswerLot = ['D','A','C','B','C','A','A','A','A'];
      let answer = localStorage.getItem(questionId);
      let sumtimer = document.getElementById('sumtimer'+questionId);
      var sumcf = document.getElementById('sumcf'+questionId);
      if(answer!=AnswerLot[questionId.substring(1,2)]) 
      {
        sumcf.style.color = "red";
        sumtimer.style.color = "red";
      }
      else{
        sumcf.style.color = "green";
      }
      return;
    }
      </script>
</body>

]]></content>
      <categories>
        <category>game</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找相同图案——本地对战版 实现笔记 | Find-same-patterns-notes</title>
    <url>/2024/02/28/240228Find-same-patterns-notes/</url>
    <content><![CDATA[<p>目标：<br>1.理解翻牌游戏的内在逻辑<br>2.学习建立html游戏的基本思路，实践基本流程</p>
<h2 id="1-关于Element-classList"><a href="#1-关于Element-classList" class="headerlink" title="1. 关于Element.classList"></a>1. 关于Element.classList</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/classList">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/classList</a><br>它是一个只读属性，可以返回一个元素的动态DOMTokenList集合，可用于操作class集合。<br>可以用add()，remove()，replace()，toggle()方法修改DOMTokenList：<br>示例：<br>const div &#x3D; document.createElement(“div”);<br>div.className &#x3D; “foo”;<br>console.log(div.outerHTML); &#x2F;&#x2F;&lt; div class&#x3D;”foo”&gt;&lt;&#x2F; div&gt;<br>&#x2F;&#x2F;使用classList API<br>div.classList.remove(“foo”);<br>div.classList.add(“anotherclass”);<br>&#x2F;&#x2F;…class&#x3D;”anotherclass”…<br>div.classList.toggle(“visible”); &#x2F;&#x2F;toggle切换；如果该类值已存在则移除它，否则添加它。</p>
<blockquote>
<p>[toggle(class, true|false)	在元素中切换类名。<br>第一个参数为要在元素中移除的类名，并返回 false。<br>如果该类名不存在则会在元素中添加类名，并返回 true。<br>第二个是可选参数，是个布尔值用于设置元素是否强制添加或移除类，不管该类名是否存 在。例如：</p>
</blockquote>
<p>移除一个 class: element.classList.toggle(“classToRemove”, false);<br>添加一个 class: element.classList.toggle(“classToAdd”, true);</p>
<p>注意： Internet Explorer 或 Opera 12 及其更早版本不支持第二个参数。]<br>div.classList.toggle(“visible”,i&lt;10);<br>console.log(dic.classList.contains(“foo”))<br>&#x2F;&#x2F;添加删除多个类值<br>div.classListadd&#x2F;remove(“foo”,”bar”,…);<br>&#x2F;&#x2F;使用展开语法添加或移除多个类值<br>const cls &#x3D; [“foo”,”bar”];<br>div.classList.add(…cls);<br>div.classList.remove(…cls);<br>div.classList.replace(“foo”,”bar”);</p>
<p>翻牌游戏的js代码中主要就是通过classList这个API添加删除类值，改变卡牌的状态。</p>
<h2 id="2-关于API-应用程序编程接口"><a href="#2-关于API-应用程序编程接口" class="headerlink" title="2.关于API 应用程序编程接口"></a>2.关于API 应用程序编程接口</h2><p>API(Application Programming Interface)程序之间的接口，程序之间的合约。<br>可以理解为：服务商通过API提供服务，进行利益交换&#x2F;互助。</p>
<h2 id="3-Node-appendChild-方法"><a href="#3-Node-appendChild-方法" class="headerlink" title="3.Node.appendChild()方法"></a>3.Node.appendChild()方法</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild">https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild</a><br>将一个结点附加到指定父节点的子节点列表的末尾处；如有该结点本身存在，只会移动而非新建（不用事先删除要移动的结点）<br>若要保留原有结点，可通过Node.cloneNode()方法创造副本（即复制），再对副本操作。<br>如果给定的子节点是 DocumentFragment，那么 DocumentFragment 的全部内容将转移到指定父节点的子节点列表中。<br>备注： 有更加新的 API 可供使用！ &gt; ParentNode.append() (en-US) 方法支持多个参数，接受字符串作为参数，会将字符串转换为文本节点再附加。<br>语法<br>element.appendChild(aChild)<br>参数<br>aChild<br>要追加给父节点（通常为一个元素）的节点。<br>返回值<br>返回追加后的子节点（aChild），除非 aChild 是一个文档片段（DocumentFragment），这种情况下将返回空文档片段（DocumentFragment）。</p>
<p>对数组有push、pop操作。</p>
<p>使板块背面为字母，就是改变.deck .card背后的background元素，给每个type单独赋值一个，但是为了满足字母位置不变的需求，应当让背面的字母与类数组的下标对应。<br>appendChild会移除原对象，需要使用cloneNode()等方法复制原对象后对副本操作。但对于本项目的需求，复制cards数组对三个独立的“cards”数组操作更为便捷。<br>经过实践，复制cards数组的过程中还是需要使用cloneNode()复制DOM结点，否则数组内都是同个DOM结点，只是存有指针的顺序不同，仍然只有最后一个有效。为此我添加了initial()函数用于在页面加载时复制结点到两个target-card数组中。</p>
<h2 id="4-slice-和concat-在JS中复制数组时的常用方法"><a href="#4-slice-和concat-在JS中复制数组时的常用方法" class="headerlink" title="4.slice()和concat() 在JS中复制数组时的常用方法"></a>4.slice()和concat() 在JS中复制数组时的常用方法</h2><p>slice()方法：array.slice(start,end)<br>slice返回一个新数组，从start位置到end位置（不包括end）的元素；若省略end参数则会一直复制到数组的末尾。<br>示例：<br>const array &#x3D; [1, 2, 3, 4, 5];<br>const newArray &#x3D; array.slice(1, 3); &#x2F;&#x2F; 返回 [2, 3]<br>concat()方法：array.concat(value1,value2,…,valueN)<br>concat用于合并两个或多个数组，并返回一个新数组。<br>示例：<br>const array1 &#x3D; [1, 2, 3];<br>const array2 &#x3D; [4, 5, 6];<br>const newArray &#x3D; array1.concat(array2); &#x2F;&#x2F; 返回 [1, 2, 3, 4, 5, 6]</p>
<p>逗号分隔元素单元：<br>#target-card1 .card,#target-card2 .card<br>同时执行多个函数的方法：<br>document.body.onload &#x3D; function(){initial();startGame();}</p>
<p>removeChild()与appendChild()相对。主要使用这两个方法增添减少deck中的card。<br>firstChild DOM中的方法，获取该元素的第一个孩子结点，没有孩子则返回null。</p>
<p>类似于appendChild的属性有：</p>
<p>insertBefore: 这个方法将一个节点插入到指定节点之前的位置。<br>replaceChild: 这个方法替换指定父节点的子节点。<br>append: 这是一个比较新的方法，它允许将一个或多个节点追加到父节点的子节点列表的末尾。<br>prepend: 与append类似，但是它会将节点插入到父节点的子节点列表的开头。<br>insertAdjacentElement: 这个方法允许在指定元素的相对位置插入一个HTML元素节点。<br>这些方法都用于动态地向文档中添加新的节点或对现有节点进行操作。</p>
<p>原有样例的翻面是由“原本字体大小为0”+“反转动画”+“对class::open的字体样式进行设置，即设置font-size: 33px”完成的。因此，要使卡牌”正面显示“，只需要设置font-size的大小。（注意：ID选择器优先级高于类选择器，注意覆盖问题）</p>
<p>在替换图标时，由于之前使用的是字体，可以直接对字体大小font-size操作；而使用svg后要对width和height操作，因此要重新设定样式。<br>经过不断地尝试，我利用id选择器优先级高的特点，利用后代选择器为#card-deck里面的svg图像设置样式。<br>#card-deck .open .icon可以在翻开卡片时被使用；<br>而#card-deck .card:not(.open) .icon会在卡片没被翻开时使用。<br>其余部分都只用直接展示，使用svg标签选择。<br>接下来就是用自选的图案svg机械替换原有文本。（当然SVG标签也可以选择卡片背面的字母）<br>在测试的过程中，unmatched时的红把红色图案融入其中，无法观察，因此修改了unmatched状态下的background-color。<br>废弃了一个图案。指纹的svg代码太长了，给GPT转url都要continue两次……</p>
<p>关于需要找的图案上的标识，debug了半天，发现问题在于：使用……::after{positon: absolute}时，其包含块即父元素（此处是card）的定位属性必须设置为非 static 属性，比如 relative、absolute 或者 fixed。否则，它会继续往父元素的父元素寻找（作为包含块），直到定位到具有非static定位属性的元素（或者到达根元素html）。当到达根元素html伪元素的位置属性top、right、bottom、left都是相对于html网页的。当你的位置属性给出个负值，很有可能会移除视口（viewport）之外，导致无法看见这个元素。</p>
<p>unmatched的动画现在匹配不到targetcard数组<br>学习html内嵌博客的不同方法。。。。。。<br>设置起始位置下拉选项框<br>设置介绍游戏规则的按钮及浮窗<br>难度的切换？（可以另做，最好内嵌）<br>新增next标识，修改代码<br>为了更加贴合原游戏的设定，添加了游戏规则按钮与两色next标识。需要寻找的图案为next标识对应的图案。因此，match相关的一系列代码传参都要改成cur+1，游戏结束判定条件也有所更改。<br>考虑到游戏后期5秒的显示时间可能过长，我添加了设置显示时间的设置。并发现已知性能问题：若保存设置，content2会过一小段时间再消失。<br>问题：保存设置时，content2会过一小段时间再消失</p>
<h2 id="5-设置下拉框dropdown并获取选中项"><a href="#5-设置下拉框dropdown并获取选中项" class="headerlink" title="5.设置下拉框dropdown并获取选中项"></a>5.设置下拉框dropdown并获取选中项</h2><p>示例：<br>&lt; select id&#x3D;”myDropdown”&gt;<br>  &lt; option value&#x3D;”option1”&gt;Option 1&lt;&#x2F; option&gt;<br>  &lt; option value&#x3D;”option2”&gt;Option 2&lt;&#x2F; option&gt;<br>  &lt; option value&#x3D;”option3”&gt;Option 3&lt;&#x2F; option&gt;<br>&lt;&#x2F; select&gt;</p>
<p>&lt; button onclick&#x3D;”getSelectedOption()”&gt;Get Selected Option&lt;&#x2F; button&gt;</p>
<p>&lt; script&gt;<br>function getSelectedOption() {<br>  var dropdown &#x3D; document.getElementById(“myDropdown”);<br>  var selectedOption &#x3D; dropdown.options[dropdown.selectedIndex].value;<br>  console.log(“Selected option:”, selectedOption);<br>  &#x2F;&#x2F; 在这里你可以使用 selectedOption 的值进行其他操作<br>}<br>&lt; &#x2F;script&gt;</p>
<p>dropdown的方法：<br>selectedIndex： 获取或设置下拉框中当前选中项的索引值。<br>var selectedIndex &#x3D; dropdown.selectedIndex; &#x2F;&#x2F; 获取当前选中项的索引值<br>dropdown.selectedIndex &#x3D; 2; &#x2F;&#x2F; 设置选中索引为第3个选项<br>value： 获取或设置下拉框中当前选中项的值。<br>var selectedValue &#x3D; dropdown.value; &#x2F;&#x2F; 获取当前选中项的值<br>dropdown.value &#x3D; “option2”; &#x2F;&#x2F; 设置选中值为 “option2”<br>options： 获取下拉框中所有选项的集合。<br>var options &#x3D; dropdown.options; &#x2F;&#x2F; 获取所有选项的集合<br>var firstOptionValue &#x3D; options[0].value; &#x2F;&#x2F; 获取第一个选项的值<br>add() 和 remove()： 向下拉框中添加或移除选项。<br>&#x2F;&#x2F; 向下拉框中添加新选项<br>dropdown.add(new Option(“Option 4”, “option4”));<br>&#x2F;&#x2F; 从下拉框中移除指定索引的选项<br>dropdown.remove(1); &#x2F;&#x2F; 移除第2个选项<br>onchange 事件： 当下拉框的选中项发生变化时触发。<br>dropdown.onchange &#x3D; function() {<br>    console.log(“选中项发生变化”);<br>};</p>
<p>6.使用iframe标签在博客中嵌套html页面<br>&lt; iframe width&#x3D;”100%” height&#x3D;”100%”  src&#x3D;”.\Find_same_patterns.html”&gt;&lt;&#x2F; iframe&gt;<br>iframe标签中scrolling属性默认为”yes”，即允许滚动，当高度不足以展示页面内容时显示滚动条。<br>博客嵌套html页面主要的问题是height&#x3D;”100%”这个属性不使用于博客页面。博客里面有其它元素，直接设置百分比只会填充预留区域（此时如在matery中下方会有“文章作者”等内容会挤占页面空间，导致height值实际上很小，如下图hegiht&#x3D;154）<br><img src="/2024/02/28/240228Find-same-patterns-notes/001.png" alt="示例图片" width="50%"><br>因此，在博客中内嵌html，height值不能使用百分比设置，只要设定足够的、能够展示完整页面的height就行了。例如针对图中示例，height&#x3D;910px时就能展示完全，此时滚动条也消失了。（但是这无法自适应浏览器尺寸变化导致的html高度的变化。）<br><img src="/2024/02/28/240228Find-same-patterns-notes/002.png" alt="示例图片" width="50%"><br>但是，可以看到现在iframe界面有边框，不够美观，经检测可以发现这是源自user agent stylesheet，也就是浏览器默认样式（见下图）。手动设置边框样式就可以覆盖掉默认样式，如使用style&#x3D;”border: 0px”加上内联样式。也可以使用到html属性frameborder，即frameborder&#x3D;”0”。但这里用到了外部CSS文件设置样式，所以更推荐后者。<br><img src="/2024/02/28/240228Find-same-patterns-notes/003.png" alt="示例图片" width="80%"><br>至于参考文章<a href="https://www.haoyizebo.com/posts/e9071e74/">https://www.haoyizebo.com/posts/e9071e74/</a>中的获取高度的函数，没看懂。测试了下会让iframe的height比设置时多50像素，在手机中显示不完全。但我的理解是这个函数要获取到嵌套的html的高度，但好像没有实现。所以我为了显示全部内容干脆scrolling &#x3D; yes了。</p>
<p>24&#x2F;03&#x2F;01<br>修改的基本原理是：所有展示的卡牌改为cloneNode()产生的复制品；在废弃后借助JavaScript引擎的垃圾回收机制自行删除。initial()时进行复制。<br>首先，在设置中添加切换难度的单选框。若成功切换难度要重置card-deck与两个target-card，并立刻重启游戏。<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> var setversion = document.getElementById(&quot;setversion&quot;).value;</span><br><span class="line"> if(setversion != version)&#123;</span><br><span class="line">     version = setversion;</span><br><span class="line">     initial(version);</span><br><span class="line">     startGame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来更改initial()与startGame()函数。<br>更改时，将cards命名为空数组，用total_cards装有全部图案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.body.onload = function()&#123;initial(0);&#125;</span><br><span class="line">//主要作用：复制cards数组</span><br><span class="line">function initial(version)&#123;</span><br><span class="line">    //先删除cards中原有内容</span><br><span class="line">    cards.forEach(function(item)&#123;</span><br><span class="line">        item.remove();</span><br><span class="line">    &#125;);</span><br><span class="line">    //洗牌，确定使用图案的顺序</span><br><span class="line">    let usedImages = shuffle([0,1,2,3,4,5,6,7]);</span><br><span class="line">    if(version === 0)</span><br><span class="line">    &#123;//普通难度直接使用前四种图案，用i遍历usedImages；j用于遍历选中的图案(偏移量)</span><br><span class="line">        for(let i = 0;i &lt; 4;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(let j = 0;j &lt; 4;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cards.push(total_cards[usedImages[i]*4+j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if(version === 1)&#123;</span><br><span class="line">        for(let i = 0;i &lt; 4;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cards.push(total_cards[usedImages[i]*4 + i%4]);</span><br><span class="line">            cards.push(total_cards[usedImages[i]*4 + (i+1)%4]);</span><br><span class="line">            cards.push(total_cards[usedImages[i+4]*4 + (i+2)%4]);</span><br><span class="line">            cards.push(total_cards[usedImages[i+4]*4 + (i+3)%4]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //目标栏删除全部元素后复制</span><br><span class="line">    targetedCards1 = [];</span><br><span class="line">    targetedCards2 = [];</span><br><span class="line">    [].forEach.call(cards,function(item)&#123;</span><br><span class="line">        let clone1 = item.cloneNode(true);</span><br><span class="line">        let clone2 = item.cloneNode(true);</span><br><span class="line">        targetedCards1.push(clone1);</span><br><span class="line">        targetedCards2.push(clone2);</span><br><span class="line">        console.log(&quot;Test3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    startGame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实现过程中，曾错误地使用DOM方法remove来清空数组。这里的targetedcard并非DOM对象，remove无法清除。因此会出现每使用一次targetcard中原有元素不消失的错误。正确方法使用数组方法清除，如targetedCards1 &#x3D; [];<br>另外，发现version一开始是num类型，由于setversion是str类型，version也变为str类型，导致version&#x3D;&#x3D;&#x3D;0&#x2F;1的判断式失效。</p>
<h2 id="6-从HTML中获取值时，javaScript都会将它们解析为字符串"><a href="#6-从HTML中获取值时，javaScript都会将它们解析为字符串" class="headerlink" title="6.从HTML中获取值时，javaScript都会将它们解析为字符串"></a>6.从HTML中获取值时，javaScript都会将它们解析为字符串</h2><p>如果想要更改类型，可以使用js内置函数parseInt()或parseFloat()</p>
]]></content>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>一些感兴趣的逻辑问题 | 240408LogicQuestions</title>
    <url>/2024/04/08/240408LogicQuestions/</url>
    <content><![CDATA[<p><strong>取水问题</strong><br>【1】假设有一个池塘，里面有无穷多的水。现有2个空水壶，容积分别为5升和6升。问题是如何只用这2个水壶从池塘里取得3升的水。</p>
<p>【71】据说有人给酒肆的老板娘出了一个难题：此人明明知道店里只有两个舀酒的勺子，分别能舀7两和11两酒，却硬要老板娘卖给他2两酒。聪明的老板娘毫不含糊，用这两个勺子在酒缸里舀酒，并倒来倒去，居然量出了2两酒，聪明的你能做到吗？</p>
<p><strong>逻辑学问题 有点难 难在你要搞清楚为什么猜得出来</strong><br>【9】一个教授逻辑学的教授，有三个学生，而且三个学生均非常聪明！<br>一天教授给他们出了一个题，教授在每个人脑门上贴了一张纸条并告诉他们，每个人的纸条上都写了一个正整数，且某两个数的和等于第三个！（每个人可以看见另两个数，但看不见自己的）<br>教授问第一个学生：你能猜出自己的数吗？回答：不能，问第二个，不能，第三个，不能，再问第一个，不能，第二个，不能，第三个：我猜出来了，是144！教授很满意的笑了。请问您能猜出另外两个人的数吗？</p>
<p><strong>较简单的条件推理</strong><br>【18】5个人来自不同地方，住不同房子，养不同动物，吸不同牌子香烟，喝不同饮料，喜欢不同食物。根据以下线索确定谁是养猫的人。<br>1． 红房子在蓝房子的右边，白房子的左边（不一定紧邻）<br>2． 黄房子的主人来自香港，而且他的房子不在最左边。<br>3． 爱吃比萨的人住在爱喝矿泉水的人的隔壁。<br>4． 来自北京的人爱喝茅台，住在来自上海的人的隔壁。<br>5． 吸希尔顿香烟的人住在养马人的右边隔壁。<br>6． 爱喝啤酒的人也爱吃鸡。<br>7． 绿房子的人养狗。<br>8． 爱吃面条的人住在养蛇人的隔壁。<br>9． 来自天津的人的邻居（紧邻）一个爱吃牛肉，另一个来自成都。<br>10．养鱼的人住在最右边的房子里。<br>11．吸万宝路香烟的人住在吸希尔顿香烟的人和吸“555”香烟的人的中间（紧邻）<br>12．红房子的人爱喝茶。<br>13．爱喝葡萄酒的人住在爱吃豆腐的人的右边隔壁。<br>14．吸红塔山香烟的人既不住在吸健牌香烟的人的隔壁，也不与来自上海的人相邻。<br>15．来自上海的人住在左数第二间房子里。<br>16．爱喝矿泉水的人住在最中间的房子里。<br>17．爱吃面条的人也爱喝葡萄酒。<br>18．吸“555”香烟的人比吸希尔顿香烟的人住的靠右</p>
<p><strong>经典时间规划</strong><br>【21】U2合唱团在17分钟 内得赶到演唱会场，途中必需跨过一座桥，四个人从桥的同一端出发，你得帮助他们到达另一端，天色很暗，而他们只有一只手电筒。一次同时最多可以有两人一起过桥，而过桥的时候必须持有手电筒，所以就得有人把手电筒带来带去，来回桥两端。手电筒是不能用丢的方式来传递的。四个人的步行速度各不同，若两人同行则 以较慢者的速度为准。Bono需花1分钟过桥，Edge需花2分钟过桥，Adam需花5分钟过桥，Larry需花10分钟过桥。他们要如何在17分钟内过桥呢？</p>
<p><strong>经典编码问题</strong><br>【26】话说有十二个鸡蛋，有一个是坏的（重量与其余鸡蛋不同），现要求用天平称三次，称出哪个鸡蛋是坏的！</p>
<p><strong>思考题</strong><br>【30】烧一根不均匀的绳要用一个小时，如何用它来判断半个小时？<br>烧一根不均匀的绳,从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子,问如何用烧绳的方法来计时一个小时十五分钟呢?</p>
<p><strong>最大学物理的一集</strong><br>【40】两个空心球，大小及重量相同，但材料不同。一个是金，一个是铅。空心球表面图有相同颜色的油漆。现在要求在不破坏表面油漆的条件下用简易方法指出哪个是金的，哪个是铅的。</p>
<p><strong>逻辑题之完全理性人</strong><br>【45】5名海盗抢得了窖藏的100块金子，并打算瓜分这些战利品。这是一些讲民主的海盗（当然是他们自己特有的民主），他们的习惯<br>是按下面的方式进行分配：最厉害的一名海盗提出分配方案，然后所有的海盗（包<br>括提出方案者本人）就此方案进行表决。如果50%或更多的海盗赞同此方案，此方<br>案就获得通过并据此分配战利品。否则提出方案的海盗将被扔到海里，然后下一名<br>最厉害的海盗又重复上述过程。<br>所有的海盗都乐于看到他们的一位同伙被扔进海里，不过，如果让他们选择的<br>话，他们还是宁可得一笔现金。他们当然也不愿意自己被扔到海里。所有的海盗都<br>是有理性的，而且知道其他的海盗也是有理性的。此外，没有两名海盗是同等厉害<br>的——这些海盗按照完全由上到下的等级排好了座次，并且每个人都清楚自己和其<br>他所有人的等级。这些金块不能再分，也不允许几名海盗共有金块，因为任何海盗<br>都不相信他的同伙会遵守关于共享金块的安排。这是一伙每人都只为自己打算的海<br>盗。<br>最凶的一名海盗应当提出什么样的分配方案才能使他获得最多的金子呢？</p>
<hr>
<p>答案部分分界线</p>
<hr>
<p>【1】<br>1、先把5升的灌满，倒在6升里，这时6升的壶里有5升水<br>2.再把5升的灌满，用5升的壶把6升的灌满，这时5升的壶里剩4升水<br>3.把6升的水倒掉，再把5升壶里剩余的水倒入6升的壶里，这时6升的壶里有4升水<br>4.把5升壶灌满，倒入6升的壶，5-2&#x3D;3</p>
<p>【71】<br>7两倒入11两, 再用7两倒入11两装满, 7两中剩余3两, 倒出11两, 将3两倒入11两, 用7两两次倒入11两装满, 7两中剩余6两, 将11两倒出, 将6两倒入, 然后用7两倒入11两, 剩余2两. 于是得到.<br>11,0–&gt;4,7–&gt;4,0–&gt;0,4–&gt;11,4–&gt;8,7–&gt;8,0–&gt;1,7–&gt;1,0–&gt;0,1–&gt;11,1–&gt;5,7–&gt;5,0–&gt;0,5–&gt;11,5–&gt;9,7–&gt;9,0–&gt;2,7</p>
<p>【9】<br>经过第一轮，说明任何两个数都是不同的。第二轮，前两个人没有猜出，说明任何一个数都不是其它数的两倍。现在有了以下几个条件：1.每个数大于02.两两不等3.任意一个数不是其他数的两倍。每个数字可能是另两个之和或之差，第三个人能猜出144，必然根据前面三个条件排除了其中的一种可能。假设：是两个数之差，即x－y＝144。这时1（x，y&gt;0）和2（x！＝y）都满足，所以要否定x＋y必然要使3不满足，即x＋y＝2y，解得x＝y，不成立（不然第一轮就可猜出），所以不是两数之差。因此是两数之和，即x＋y＝144。同理，这时1，2都满足，必然要使3不满足，即x－y＝2y，两方程联立，可得x＝108，y＝36。<br>    这两轮猜的顺序其实分别为这样：第一轮（一号，二号），第二轮（三号，一号，二号）。这样分大家在每轮结束时获得的信息是相同的（即前面的三个条件）。<br>    那么就假设我们是C，来看看C是怎么做出来的：C看到的是A的36和B的108，因为条件，两个数的和是第三个，那么自己要么是72要么是144（猜到这个是因为72的话，108就是36和72的和，144的话就是108和36的和。这样子这句话看不懂的举手）:<br>    假设自己（C）是72的话，那么B在第二回合的时候就可以看出来，下面是如果C是72，B的思路：这种情况下，B看到的就是A的36和C的72，那么他就可以猜自己，是36或者是108（猜到这个是因为36的话，36加36等于72，108的话就是36和108的和）：<br>    如果假设自己（B）头上是36，那么，C在第一回合的时候就可以看出来，下面是如果B是36，C的思路：这种情况下，C看到的就是A的36和B的36，那么他就可以猜自己，是72或者是0（这个不再解释了）：<br>如果假设自己（C）头上是0，那么，A在第一回合的时候就可以看出来，下面是如果C是0，A的思路：这种情况下，A看到的就是B的36和C的0，那么他就可以猜自己，是36或者是36（这个不再解释了），那他可以一口报出自己头上的36。（然后是逆推逆推逆推），现在A在第一回合没报出自己的36，C（在B的想象中）就可以知道自己头上不是0，如果其他和B的想法一样（指B头上是36），那么C在第一回合就可以报出自己的72。现在C在第一回合没报出自己的36，B（在C的想象中）就可以知道自己头上不是36，如果其他和C的想法一样（指C头上是72），那么B在第二回合就可以报出自己的108。现在B在第二回合没报出自己的108，C就可以知道自己头上不是72，那么C头上的唯一可能就是144了。</p>
<p>【18】<br>1　　　 2　　　 3　　 4　 　　5<br>蓝房子　　绿　 黄　 　 红　　　白<br>北京人　 上海　 香港　 天津　　 成都<br>茅台酒　 葡萄　 矿泉水　 茶　　 啤酒<br>豆腐　　　面条 牛肉　 比萨　　 鸡<br>健牌　　希尔顿　万宝路　 555　 红塔山<br>马　　　 狗　　 蛇　　 猫　　 鱼</p>
<p>【21】<br>假设这四个人分别为甲（1分钟）乙（2分钟）丙（5分钟）丁（10分钟）<br>第一次去：甲和乙 （2分钟）<br>第一次回：甲（1分钟）<br>第二次去：丙和丁（10分钟）<br>第二次回：乙（2分钟）<br>第三次去：甲和乙（2分钟）<br>总计 ：17分钟</p>
<p>【26】<br>12个时可以找出那个是重还是轻，13个时只能找出是哪个球，轻重不知。<br>　　把球编为①②③④⑤⑥⑦⑧⑨⑩⑾⑿。（13个时编号为⒀）<br>　　第一次称：先把①②③④与⑤⑥⑦⑧放天平两边，<br>　　　　㈠如相等，说明特别球在剩下4个球中。<br>　　　　　　把①⑨与⑩⑾作第二次称量，<br>　　　　　　⒈如相等，说明⑿特别，把①与⑿作第三次称量即可判断是⑿是重还是轻<br>　　　　　　⒉如①⑨＜⑩⑾说明要么是⑩⑾中有一个重的，要么⑨是轻的。<br>　　　　　　　　把⑩与⑾作第三次称量，如相等说明⑨轻，不等可找出谁是重球。<br>　　　　　　⒊如①⑨＞⑩⑾说明要么是⑩⑾中有一个轻的，要么⑨是重的。<br>　　　　　　　　把⑩与⑾作第三次称量，如相等说明⑨重，不等可找出谁是轻球。<br>　　　　㈡如左边＜右边，说明左边有轻的或右边有重的<br>　　　　　　把①②⑤与③④⑥做第二次称量<br>　　　　　　⒈如相等，说明⑦⑧中有一个重，把①与⑦作第三次称量即可判断是⑦与⑧中谁是重球<br>　　　　　　⒉如①②⑤＜③④⑥说明要么是①②中有一个轻的，要么⑥是重的。<br>　　　　　　　　把①与②作第三次称量，如相等说明⑥重，不等可找出谁是轻球。<br>　　　　　　⒊如①②⑤＞③④⑥说明要么是⑤是重的，要么③④中有一个是轻的。<br>　　　　　　　　把③与④作第三次称量，如相等说明⑤重，不等可找出谁是轻球。<br>　　　　㈢如左边＞右边，参照㈡相反进行。<br>　　当13个球时，第㈠步以后如下进行。<br>　　　　把①⑨与⑩⑾作第二次称量，<br>　　　　⒈如相等，说明⑿⒀特别，把①与⑿作第三次称量即可判断是⑿还是⒀特别，但判断不了轻重了。<br>　　　　⒉不等的情况参见第㈠步的⒉⒊</p>
<p>【30】<br>一，一根绳子从两头烧，烧完就是半个小时。<br>二，一根要一头烧，一根从两头烧，两头烧完的时候（30分），将剩下的一根另一端点着，烧尽就是45分钟。再从两头点燃第三根，烧尽就是1时15分。</p>
<p>【40】<br>旋转看速度，金的密度大，质量相同，所以金球的实际体积较小，因为外半径相同，所以金球的内半径较大，所以金球的转动惯量大，在相同的外加力矩之下，金球的角加速度较小，所以转得慢。</p>
<p>【45】<br>如果轮到第四个海盗分配：100，0<br>轮到第三个：99，0，1<br>轮到第二个：98，0，1，0<br>轮到第一个：97，0，1，0，2，这就是第一个海盗的最佳方案。</p>
]]></content>
  </entry>
  <entry>
    <title>GPT编程01——翻转游戏</title>
    <url>/2024/05/27/240524Filp_Game/</url>
    <content><![CDATA[<blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>GPT4-o的发行，标志着可用的大语言模型的进一步发展。现在，GPT在编程方面的能力已经很强了。这个系列将以GPT作为助手，基本使用GPT实现项目的需求，完成项目。与此同时辅以手动debug。<br>目前，我的期待是锻炼GPT编程水平，同时通过GPT给出的代码学习相关函数的使用，积累知识。</p>
</blockquote>
<p>2405270859版本：修正代码块(之前用的不是反引号‘&#96;’)；完善标题结构；注：output不是GPT的输出，是我自拟的表示该文件里有GPT当次回答所提供的代码。<br>2406111057版本：手机端代码块显示问题等待解决。修复演示程序中生成过随机题目后更改大小导致不合理版面的bug；给演示程序的源html加上了N范围为2~10的限制，防止标题以及按钮被覆盖。</p>
<h1 id="Project-No1-Flip-Game-翻转问题-游戏交互"><a href="#Project-No1-Flip-Game-翻转问题-游戏交互" class="headerlink" title="Project_No1:Flip_Game 翻转问题-&gt;游戏交互"></a>Project_No1:Flip_Game 翻转问题-&gt;游戏交互</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>翻转问题（亮灯问题），多次在解密游戏中碰到。十分有魅力。</p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol>
<li>基本实现界面，有重置、查看可行解的功能；</li>
<li>可以给出具体N值时的特例，作为一道谜题；</li>
<li>可以记录点击的步数；</li>
<li>可以支持对同一道题的多次尝试，记录玩家的最优步数。</li>
</ol>
<p>灵感列表：</p>
<ol>
<li>点击后，触发翻转事件的格子不是我点击的格子，该格子与我点击的格子沿水平中线对称（将直角坐标系移到中心后，两个格子关于x轴对称）。(要给操作上难度的确可以对称位置操作，竞速时倒可以作为干扰因素)</li>
<li>可以添加选择渐变色的功能，给出几种选择。</li>
</ol>
<p>提问-&gt;解析的形式</p>
<p>之前看过一篇对翻转问题进行分析的文章，文章中通过渐变色格子展示N*N时的最优解，很是壮观。因此，私心想用渐变色表示~~</p>
<h3 id="渐变色表示与基本游戏逻辑实现"><a href="#渐变色表示与基本游戏逻辑实现" class="headerlink" title="渐变色表示与基本游戏逻辑实现"></a>渐变色表示与基本游戏逻辑实现</h3><p>Q:使用python，画N<em>N的方格，其中指定下标的方格为渐变颜色，其余为白色，有粗边框，方格间有细边框<br>A:当然可以！你可以使用Python的matplotlib库来画出这样的渐变色方格。下面是一个实现的示例代码：output:001.py<br>代码解释<br>导入必要的库：matplotlib.pyplot用于绘图，numpy用于处理数值数组，matplotlib.colors用于处理颜色。<br>创建绘图函数：draw_grid函数接收网格大小N和需要渐变颜色的方格坐标列表gradient_cells。<br>设置图像和轴：<br>关闭坐标轴刻度。<br>设置粗边框。<br>绘制N</em>N网格：<br>使用双重循环创建方格。如果方格在gradient_cells中，则创建渐变颜色。否则，填充白色。<br>添加细边框：<br>使用循环和ax.plot函数添加细边框。<br>设置轴的限制和纵横比：<br>确保整个网格显示在图像中，并且每个方格都是正方形。<br>显示图像：使用plt.show()显示图像。<br>通过此代码，你可以生成一个包含渐变颜色和边框的N<em>N网格。你可以根据需要调整渐变颜色和指定方格的坐标。<br>Q:如何设置渐变色？有什么已有的渐变色模板吗？<br>Q:其中有没有渐变色只有一种主色系的？ output:002.py<br>Q:有没有浅蓝到紫晶蓝的渐变色 output:003.py<br>Q:能否做一个翻转问题的界面，要求能与界面交互。界面大小为4</em>4，被翻转的为渐变色，未被翻转的为白色 output:004.py<br>Q:翻转问题，是翻转一个格子，上下左右的格子也会一并翻转的问题，当全部格子被翻面即成功。根据这个信息进行修改 output:005.py<br>Q:渐变色能不能由中心向外？ output:006.py<br>Q:那个格子自身也要翻转 output:007.py<br>Q:……<br>File “E:\Project_storage\方格.venv\Lib\site-packages\matplotlib\artist.py”, line 1011, in set_alpha<br>    raise ValueError(f’alpha ({alpha}) is outside 0-1 range’)<br>ValueError: alpha (1.118033988749895) is outside 0-1 range<br>A:这个错误是因为尝试设置了超出范围的 alpha 值。我们需要确保 alpha 值在 0 到 1 的范围内。修改代码，使得 alpha 值不会超出这个范围。下面是修正后的代码：<br>output:008.py</p>
<h3 id="对界面交互的修正"><a href="#对界面交互的修正" class="headerlink" title="对界面交互的修正"></a>对界面交互的修正</h3><p>通过与界面进行交互，发现了几个问题：</p>
<ol>
<li>点击后，触发翻转事件的格子不是我点击的格子，该格子与我点击的格子沿水平中线对称（将直角坐标系移到中心后，两个格子关于x轴对称）。(要给操作上难度的确可以对称位置操作，竞速时倒可以作为干扰因素)</li>
<li>触发事件的格子并没有翻转，但周围的格子的正常翻转了</li>
<li>坐标为（3，3）的格子翻转状态无法正确显示，虽然边框好像会变<br><img src="/2024/05/27/240524Filp_Game/001_001.png"></li>
</ol>
<h4 id="翻转的逻辑"><a href="#翻转的逻辑" class="headerlink" title="翻转的逻辑"></a>翻转的逻辑</h4><blockquote>
<p>Q:在def flip_tile(self, x, y):中，第一行的self.grid[y, x] &#x3D; not self.grid[y, x]与后面的逻辑重复了，导致目标格子会被翻转两次，导致无法翻转。请自行修正。  另外，点击后，触发翻转事件的格子不是我点击的格子，该格子与我点击的格子沿水平中线对称（将直角坐标系移到中心后，两个格子关于x轴对称）。  此外，坐标为（3，3）的格子翻转状态无法正确显示。</p>
</blockquote>
<p>把发现的错误讲给GPT后，GPT没能有效修正(009.py)，只能手动修正了。<br>手动修正，必须理解代码的运行逻辑。如果不理解代码，只能看着错误干瞪眼。还是对着008.py修改。<br>手动修正时，还是可以借助GPT理解各部分代码的，但要谨防瞎说，不确定得自行验证or查文档。</p>
<blockquote>
<p>Q:……请解释这些代码</p>
</blockquote>
<p>在我对着解释理解各句代码的作用并在对应位置写入注释时，突发奇想，GPT应该也能完成这种机械化工作吧。于是：</p>
<blockquote>
<p>Q:能否讲你的解释，压缩后嵌入代码中？</p>
</blockquote>
<p>GPT的确能做到，没问到的部分它也做出了解释，但这种提问的解释必定不细致。不过重要的是理解各个参数与函数是怎么用的。</p>
<p>经过测试，发现一个新的线索：目前的平面直角坐标系原点在左下角。这应该是坐标逻辑出错的原因。多半就是坐标确定的逻辑出错了。在自己手动修改前还是试试GPT在知道问题时能不能自己改吧。</p>
<blockquote>
<p>Q:经过测试发现，目前的直角坐标系原点在左下角，导致格子的y坐标计算错误。请根据这个情况进行修正</p>
</blockquote>
<p>010.py<br>的确修正了。但是现在点击格子之后，触发事件的格子会向上偏移。最后一行的格子甚至压根无法触发事件。照例先告诉GPT这个问题。</p>
<blockquote>
<p>Q:现在点击格子之后，触发事件的格子会向上偏移。尤其是点击最后一行的格子时，触发的永远是倒数第二行的格子。</p>
</blockquote>
<p>011.py<br>问题并没有得到解决，顺带一提，新加的坐标显示，左上角格子编号(0,0)。与刚才的左下是坐标原点的逻辑基础相违背。刚才列出的问题1、3都没有得到解决。再给GPT一次机会。分析主要抓住坐标的逻辑，难不成y上取整了？<br>坐标确定代码为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x, y = <span class="built_in">int</span>(event.xdata), <span class="built_in">int</span>(self.N - event.ydata - <span class="number">1</span>)  <span class="comment"># 获取点</span></span><br></pre></td></tr></table></figure>
<p>跟上取整了差不多了，math.floor(N-y坐标-1)，第四行$$y \in (0,1)$$，所以$$(N-y-1) \in (2,3)$$，取下于它的最大整数（floor函数的功能）只能是2了，所以根本取不到最后一行(y&#x3D;3)。<br>将int(self.N - event.ydata - 1)改为int(self.N - event.ydata)，逻辑就正确了。<br>把这个线索交给GPT，这是它最后的机会了。</p>
<blockquote>
<p>Q:对于int(self.N - event.ydata - 1)，当y属于(0,1)时，好像int(self.N - event.ydata - 1)永远都是2<br>A:如果 y 的值在 (0, 1) 之间，确实会出现这个问题，因为 int() 函数会将小数部分舍去，而且 self.N 的值是整数，所以结果可能不如预期。为了解决这个问题，我们可以使用 np.floor() 或 np.ceil() 来确保正确地向下或向上取整。<br>……<br>x, y &#x3D; int(event.xdata), int(np.floor(self.N - event.ydata - 1))<br>……</p>
</blockquote>
<p>基本方向是对了，改的话就……emm。三次机会已到，不给它机会了。int()在非负取整结果上跟floor差不多，舍弃了浮点部分。GPT引用了numpy模块里的floor，也是常规用法吧，import math之后math.floor()也行。<br>关于int()与floor()，需要注意。int()对于负数而言会向“上”（向0）舍入到最接近的整数，而np.floor()总是向下舍入。np.floor()（来自numpy）能够对数组批量操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = -<span class="number">1.1</span></span><br><span class="line"><span class="built_in">print</span>(np.floor(y),<span class="built_in">int</span>(y))</span><br><span class="line"></span><br><span class="line">output: -<span class="number">2.0</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>就是GPT的表述，有点模糊吧，也放出来：（因为GPT表述太迷糊，上面的测试代码是自己写的）</p>
<blockquote>
<p>int() 将向零舍入，因此对于正数，它会截取小数部分；而对于负数，它会向下舍入到最接近的整数。<br>np.floor() 总是向下舍入到最接近的整数，即使是负数也是如此。</p>
</blockquote>
<h4 id="渐变色“消失”"><a href="#渐变色“消失”" class="headerlink" title="渐变色“消失”"></a>渐变色“消失”</h4><p>对于“3. 坐标为（3，3）的格子翻转状态无法正确显示，虽然边框好像会变”这个问题，估计是前期让它“渐变色中心向四周扩散”时出错了。试着问问GPT：</p>
<blockquote>
<p>Q:现在有一些格子的渐变色与其它的不一样？能否指出是为什么吗？<br>在原始的代码中，每个格子的渐变色是根据其到网格中心的距离来确定的，距离越远，渐变色越接近透明。但是在处理点击事件时，触发事件的格子及其相邻格子被翻转，这导致它们的渐变色也被重新计算，可能与其他格子的渐变色不同。因此，触发事件的格子和相邻格子的渐变色可能会与其他格子不一样。<br>为了解决这个问题，我们可以在处理点击事件时，不重新计算触发事件格子的渐变色，而是保持它们的渐变色与原始状态相同。这样可以确保触发事件的格子及其相邻格子的渐变色与其他格子保持一致。</p>
</blockquote>
<p>看来必须研究渐变色的代码了。另外，在目前的程序中，游戏一旦完成，点击事件的监听就被断开了，reset之后不会恢复对点击事件的监听，需要修改。</p>
<blockquote>
<p>Q:请介绍这段代码涉及的函数：<br>self.ax.imshow(gradient, aspect&#x3D;’auto’, extent&#x3D;(j, j + 1, self.N - i - 1, self.N - i),cmap&#x3D;self.cmap, alpha&#x3D;alpha)  # 绘制渐变色格子<br>Q:能否精简函数参数的介绍，尽量各用几个短语介绍<br>A:当然可以：</p>
</blockquote>
<ul>
<li><code>gradient</code>: 渐变色数组，表示从白色到指定颜色的渐变。</li>
<li><code>aspect=&#39;auto&#39;</code>: 自动调整图形的纵横比。</li>
<li><code>extent=(j, j + 1, self.N - i - 1, self.N - i)</code>: 定义图像的范围。</li>
<li><code>cmap=self.cmap</code>: 指定用于颜色映射的 colormap。</li>
<li><code>alpha=alpha</code>: 控制图像的透明度。</li>
</ul>
<p>与之前版本的代码对比，发现是这段代码的效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">distance = np.sqrt((i - self.N / <span class="number">2</span>) ** <span class="number">2</span> + (j - self.N / <span class="number">2</span>) ** <span class="number">2</span>)  <span class="comment"># 计算到网格中心的距离</span></span><br><span class="line">alpha = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(<span class="number">1</span>, distance / (self.N / <span class="number">2</span>)))  <span class="comment"># 限制 alpha 在 0 到 1 的范围内</span></span><br></pre></td></tr></table></figure>
<p>看来GPT对我的从中心到四周的渐变有些误解……估计就是alpha&#x3D;0了。调alpha有效果，但是<strong>整体很不美观</strong>。还是得<strong>试试搞好渐变色</strong>。为了不受已有代码影响，我开了新对话。<br>与GPT拉扯了许久，下面是最终有效的提问</p>
<blockquote>
<p>Q:import matplotlib.pyplot as plt<br>from matplotlib.colors import LinearSegmentedColorma 请问可以用这两个画出哪些形状的渐变色？<br>Q:如何用LinearSegmentedColorma画出一个颜色从中心开始，由深蓝向紫晶蓝渐变的矩形？<br>Q:能否改为由天蓝渐变为深蓝再渐变为紫晶蓝<br>Q:如何将现在的自定义颜色覆盖到这段代码中？ ……<br>Q:能否将# Fill in the rectangle with gradient colors<br>    for i in range(height):<br>        for j in range(width):<br>            # Calculate distance from center<br>            distance &#x3D; np.sqrt((j - center_x) ** 2 + (i - center_y) ** 2)<br>            # Normalize distance to range [0, 1]<br>            normalized_distance &#x3D; distance &#x2F; np.sqrt(center_x ** 2 + center_y ** 2)<br>            # Map normalized distance to colormap<br>            color &#x3D; cmap(normalized_distance)<br>            image[i, j] &#x3D; color<br>    return image<br>    这段代码融入。注意，目的是让每个格子都能应用到这段你代码。需要对这段代码进行一些修改。</p>
</blockquote>
<p>经过拉扯，最终的结果是这样的：012.py<br><img src="/2024/05/27/240524Filp_Game/001_002.png"><br>好歹在N值大的时候能接受吧。不过当N为偶数时会逼死强迫症，不对称。但还是想试试之前的想法。</p>
<blockquote>
<p>Q:我的意思是，每个格子都像之前的单个矩形一样，在单个格子内渐变</p>
</blockquote>
<p>拉扯失败，自己改吧。017.py是期待的效果，但效果也不好。并且那段代码(018.py)是以像素为单位的。得深刻理解。先放一放。现在就做出了可用的游戏界面。另外再修改一下移除监视的部分。回到前面的那个对话。</p>
<h4 id="reset的逻辑"><a href="#reset的逻辑" class="headerlink" title="reset的逻辑"></a>reset的逻辑</h4><blockquote>
<p>Q:现在如果游戏被完成，按reset后也无法重新开始游戏<br>A:……<br>修正坐标转换：<br>x, y &#x3D; int(event.xdata), int(self.N - event.ydata - 1)  # 获取点击位置并转换 y 坐标</p>
</blockquote>
<p>我可真谢谢你，给我改回错的版本了。把那个错误修正后，测试（020.py），现在完成后reset后仍然可以正常游戏了。<br>接下来，先添加记录步数的功能吧。代码越堆越多，可能会受到GPT输出长度限制。</p>
<blockquote>
<p>Q:能否在屏幕上显示当前玩家操作的次数；并记录玩家完成游戏的历史最小次数。<br>Q:请生成完整代码<br>Q:请继续生成<br>Q:请注意：on_click中的x, y &#x3D; int(event.xdata), int(self.N - event.ydata - 1)需改成x, y &#x3D; int(event.xdata), int(self.N - event.ydata)</p>
</blockquote>
<p>（021.py）运行过程中，文本框虽然不会被修改，但是会吸附焦点。试了一下，看起来GPT改不了(022.py)，直接把文本框改没了。先不管了。</p>
<h3 id="可解题目的生成"><a href="#可解题目的生成" class="headerlink" title="可解题目的生成"></a>可解题目的生成</h3><p>现在需求3、4已经完成了，也就是界面内容已经完成了。剩下的主要是翻转游戏游戏性的拓展。<br>需求主要有： 1. 在游戏开始时随机一到两个格子处于翻转状态；该功能应该可以选择打开或关闭；reset也应该有“重试”或“获得新题目”的区分。 2. 题解：穷举剪枝（<br>为了在生成后可获取可行解，先实现题解的生成。但“对于这样一个程序，请添加’查看题解的功能‘”在前面问貌似不符合GPT的实现逻辑。还是得先生成初始态。</p>
<blockquote>
<p>Q:能否添加一个设置菜单，其中可以选择reset后是否生成一个有两个格子被随机翻转的谜题，或是重置回目前的谜题的初始状态。</p>
</blockquote>
<h4 id="生成谜题与求解"><a href="#生成谜题与求解" class="headerlink" title="生成谜题与求解"></a>生成谜题与求解</h4><p>现在可以生成初始两个被翻转的随机谜题，但是无法重现谜题的初始版图。</p>
<blockquote>
<p>Q:勾选Randomize后，点击Reset，会生成随机的谜题（记为谜题1）；要求：  此时取消勾选Randomize，点击Reset之后，需要重现谜题1 。请进行修改 。 没有修改的代码部分不用给出。<br>GPT:<br>修改说明：<br>在类初始化方法中增加 self.random_puzzle 变量，用于存储当前生成的随机谜题状态。<br>在 reset_grid 方法中，当复选框被勾选并生成随机谜题后，将随机谜题状态存储到 self.random_puzzle。<br>在 reset_grid 方法中，当复选框未勾选时，检查 self.random_puzzle 是否不为 None，如果不为 None，恢复到上次生成的随机谜题状态，否则恢复到初始状态。<br>output:024.py （我才不会说是我忘记复制，直接把刚才那版覆盖了……）<br>这次GPT达到的我的目的，要继续修改应该比较容易。之后便是探索解集。<br>Q:能否添加一个功能：添加一个“获得答案”的按钮，按下之后可以生成答案。答案指：使得完成游戏需要点击的最少方格的各个方格的位置。用一个小的N*N板块显示。<br>output:025.py<br>Q:请给出具体的解决谜题的算法<br>output:026.py</p>
</blockquote>
<p>026.py无法处理无解的谜题，会直接报错，</p>
<blockquote>
<p>Q:Traceback (most recent call last):<br>  ……<br>TypeError: ‘NoneType’ object is not subscriptable  这有可能是因为问题无解<br>output:027.py<br>修改说明：<br>在 show_answer 方法中增加了对 solution 是否为 None 的检查。如果 solution 为 None，则打印 “No solution found.”。<br>在 solve_puzzle 方法的最后，如果没有找到解决方案，则返回 None。<br>通过这些修改，当没有解时，不会尝试显示 None，而是会输出一条消息。</p>
</blockquote>
<p>目前的界面是这样的：<br><img src="/2024/05/27/240524Filp_Game/001_003.png"><br>点击”Get Answer”按钮后:<br><img src="/2024/05/27/240524Filp_Game/001_004.png"></p>
<p>看起来，初始时若是2个格子被翻转，没有可行解。</p>
<blockquote>
<p>Q:如何修改勾选Randomize后随机翻转的格子数？能否帮我改成3？<br>A:当然可以。你需要修改 <code>randomize_grid</code> 方法，使其在勾选 <code>Randomize</code> 后翻转三个随机的格子，而不是两个。<br>这里是修改后的代码片段：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FlipGame</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, N=<span class="number">4</span></span>):</span><br><span class="line">        <span class="comment"># 初始化代码省略，保持不变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其余代码省略，保持不变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">randomize_grid</span>(<span class="params">self</span>):</span><br><span class="line">        indices = np.random.choice(self.N * self.N, <span class="number">3</span>, replace=<span class="literal">False</span>)  <span class="comment"># 选择 3 个随机的格子</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> indices:</span><br><span class="line">            x, y = index // self.N, index % self.N</span><br><span class="line">            self.grid[x, y] = <span class="keyword">not</span> self.grid[x, y]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其余代码省略，保持不变</span></span><br></pre></td></tr></table></figure>
<p>这个修改将 <code>randomize_grid</code> 方法中的 <code>np.random.choice</code> 函数的参数改为 <code>3</code>，从而选择 3 个随机格子进行翻转。其余的代码保持不变。这样，勾选 <code>Randomize</code> 后点击 <code>Reset</code> 按钮，将会有三个随机的格子被翻转。</p>
<p>通过提问，我了解了它随机初始化的逻辑。要点就是形成一个(x,y)的元组，之后通过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.grid[x, y] = <span class="keyword">not</span> self.grid[x, y]</span><br></pre></td></tr></table></figure>
<p>一句，将所有指定的坐标对于的格子翻转。理解这点后，我新建了一个对话，探讨翻转游戏的可行解。</p>
<h4 id="可行解的探索"><a href="#可行解的探索" class="headerlink" title="可行解的探索"></a>可行解的探索</h4><blockquote>
<p>Q:对于4*4的翻转游戏，什么时候有解？<br>Q:能否写出一个或多个函数，（共同）实现生成可行谜题的代码 output：029可行解.py<br>Q:这段代码运行地太慢了。能否适当剪枝？ output:030可行解.py</p>
</blockquote>
<p>现在得到了可以运行的初始谜题生成代码，原理是随机初始化点击行为：点击行为对格子状态的影响是可逆的。相比随机格子状态，这算是个生成可解谜题的好方法。<br>接下来就拿着这段代码让GPT融合。</p>
<blockquote>
<p>Q:能否将下面这段代码融入到产生初始解的函数中？原来的函数功能如有冲突，请将其覆盖。  import numpy as np…….<br>output: 031.py</p>
</blockquote>
<p>现在随机谜题的效果挺让我满意的。4*4时平均点4-5下。但修改N后，Get_Answer就崩了。</p>
<blockquote>
<p>Q:当N不等于4时，Get_Answer会崩溃。请修改生成函数或者Get_Answer函数的逻辑，使其能正常运行<br>output:032.py</p>
</blockquote>
<p>看起来，不能奢望GPT能写出解决翻转问题的代码(033.py系列)。因此032.py是暂时的可以产出4*4以内范围谜题与解决方案的程序。现在需求1、2也算是有限制地完成了（N&lt;&#x3D;4）。搞一搞UI美化吧。基于032.py版本。</p>
<blockquote>
<p>Q:这段代码的UI很丑，包括但不限于渐变色不对称且对比度大；按钮排列不规律；文本框都是由被选中的光标等等问题，请尝试进行修改，并告诉我改了什么？</p>
</blockquote>
<p>经过多次修改，UI的最终版面是这样的：<br><img src="/2024/05/27/240524Filp_Game/001_005.png"><br>最终版本03404.py<br>这个项目就先到此结束了。<br>之后看一看要不要重启。</p>
<hr>
<p>24&#x2F;6&#x2F;7<br>针对Filp_Game的解题算法，这几天做了多次搜索。理论可以暴力搜索，但是时间复杂度高（且我僵尸都打了四个多小时，真不会暴力）。我搜索到了一个解题的文章。<a href="https://www.heywhale.com/mw/project/604c6bc074dfc60016e228f1">变色方块(Flip Game)解法与可视化</a>（我真感动，时隔快一个学期，我打出的a标签还是正确格式，其实md语法是这样：<a href="https://www.heywhale.com/mw/project/604c6bc074dfc60016e228f1">变色方块(Flip Game)解法与可视化</a>）。这篇文章中利用了前人的研究，给出了使用高斯消元法对翻转问题求解的思路。我的理解是：对翻转游戏中的每一个格子都列一个线性方程，其中只自身与上下左右对应的xi置为1，’+’定义为异或。对于初始全零的初始状态，线性方程等号右边都是1。高斯消元法解线性方程组的过程，就是将矩阵化为阶梯矩阵，之后再求解。（线性代数相关内容）<br>这种数学逻辑还是得靠自己理解。GPT只有有限的数学处理能力。探索理解解题方法，也算是人不可被GPT替代的部分。<br>GPT成功帮我把求解的代码与原有程序融合。但是，只在初始全0状态时给出正确结果。经过多次提问修正，仍然不能给出能够求解有初始状态游戏的程序。<br>假定格子有0、1两种状态。翻转游戏的目标是让所有格子处于1状态。<strong>在线性方程中目标状态为1，可以理解为需要通过翻转，把对应格子的状态改变</strong>。当初始状态为全0时，<strong>所有格子都需要从0变为1</strong>，因此目标矩阵是<strong>全1的矩阵</strong>。一般情况，对于初始状态为1的格子，该<strong>格子的状态并不用改变</strong>，因此在<strong>目标矩阵的对应位置应该设置为0</strong>。极端情况，初始状态已经是全1，此时目标矩阵应该是全0，也就是要在操作后保持所有格子原有状态均不变。<br>主要涉及更改的函数如下：<br>(最终文件：107可用.py)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show_answer</span>(<span class="params">self, event</span>):</span><br><span class="line">    solution = self.solve_puzzle(self.grid)</span><br><span class="line">    <span class="keyword">if</span> solution <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.display_solution(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No solution found.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve_puzzle</span>(<span class="params">self, grid</span>):</span><br><span class="line">    n = self.N</span><br><span class="line">    a = []  <span class="comment"># 异或方程组存在这里</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建异或方程组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            d = np.zeros([n, n], np.int8)</span><br><span class="line">            d[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                d[i - <span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i != n - <span class="number">1</span>:</span><br><span class="line">                d[i + <span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j != <span class="number">0</span>:</span><br><span class="line">                d[i][j - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j != n - <span class="number">1</span>:</span><br><span class="line">                d[i][j + <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">            a.append(d.flatten())</span><br><span class="line"></span><br><span class="line">    a = np.array(a)</span><br><span class="line">    b = np.ones(n * n, np.int8)  <span class="comment"># 目标状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据初始状态修改b矩阵，若初始状态为True，则不需要改变。</span></span><br><span class="line">    <span class="comment"># 根据高斯消元法，该格子异或的结果应该为0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j]:</span><br><span class="line">                b[i * n + j] ^= <span class="number">1</span>  <span class="comment"># 可以直接置0，异或1也一样</span></span><br><span class="line"></span><br><span class="line">    a = np.hstack((a, b[:, np.newaxis]))</span><br><span class="line"></span><br><span class="line">    n2 = n * n</span><br><span class="line">    line = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 高斯消元法解异或方程组</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n2):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(line, n2):</span><br><span class="line">            <span class="keyword">if</span> a[j][k] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> a[j][k] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        temp1, temp2 = np.copy(a[j]), np.copy(a[line])</span><br><span class="line">        a[line], a[j] = temp1, temp2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(line + <span class="number">1</span>, n2):</span><br><span class="line">            <span class="keyword">if</span> a[i][k] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k, n2 + <span class="number">1</span>):</span><br><span class="line">                    a[i][j] = a[i][j] ^ a[line][j]</span><br><span class="line">        line += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n2 - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j):</span><br><span class="line">            <span class="keyword">if</span> a[i][j] == <span class="number">1</span>:</span><br><span class="line">                a[i][n2] = a[i][n2] ^ a[j][n2]</span><br><span class="line"></span><br><span class="line">    result = a[:, -<span class="number">1</span>].reshape((n, n))</span><br><span class="line">    solution_grid = np.zeros((n, n), dtype=<span class="built_in">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> result[i, j] == <span class="number">1</span>:</span><br><span class="line">                solution_grid[i, j] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> solution_grid</span><br></pre></td></tr></table></figure>

<script type="text/javascript">
function SetCwinHeight(){
  var iframeid = document.getElementById("iframeid"); //iframe id
  if (document.getElementById) {
    if (iframeid && !window.opera) {
      if (iframeid.contentDocument && iframeid.contentDocument.body.offsetHeight) {
        iframeid.height = iframeid.contentDocument.body.offsetHeight + 50;
      } else if (iframeid.Document && iframeid.Document.body.scrollHeight) {
        iframeid.height = iframeid.Document.body.scrollHeight + 50;
      }
    }
  }
}
</script>

<iframe width="100%" id="iframeid" onload="Javascript:SetCwinHeight()" scrolling="yes" height="1300" frameborder="0" src=".\test6_good.html"></iframe>

<p>附重新启动前的源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> mcolors</span><br><span class="line"><span class="keyword">from</span> matplotlib.widgets <span class="keyword">import</span> Button, TextBox, CheckButtons</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimSun&#x27;</span>, <span class="string">&#x27;Microsoft YaHei&#x27;</span>]  <span class="comment"># 设置中文字体</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlipGame</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, N=<span class="number">5</span></span>):</span><br><span class="line">        self.N = N</span><br><span class="line">        self.grid = np.zeros((N, N), dtype=<span class="built_in">bool</span>)</span><br><span class="line">        self.initial_grid = self.grid.copy()</span><br><span class="line">        self.random_puzzle = <span class="literal">None</span></span><br><span class="line">        self.colors = [(<span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1.0</span>), (<span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.8</span>)]  <span class="comment"># 调整颜色为柔和的蓝色渐变</span></span><br><span class="line">        self.cmap = mcolors.LinearSegmentedColormap.from_list(<span class="string">&#x27;custom_cmap&#x27;</span>, self.colors, N=<span class="number">256</span>)</span><br><span class="line">        self.num_moves = <span class="number">0</span></span><br><span class="line">        self.min_moves = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">        self.ax = self.fig.add_subplot(<span class="number">111</span>)  <span class="comment"># 将游戏区域的高度调整为与按钮和选项框相匹配</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调整游戏区域的位置</span></span><br><span class="line">        self.ax.set_position([<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.7</span>, <span class="number">0.8</span>])</span><br><span class="line"></span><br><span class="line">        self.textbox_moves = TextBox(plt.axes([<span class="number">0.85</span>, <span class="number">0.2</span>, <span class="number">0.1</span>, <span class="number">0.05</span>]), <span class="string">&#x27;步数:&#x27;</span>, initial=<span class="built_in">str</span>(self.num_moves))</span><br><span class="line">        self.textbox_moves.color = <span class="string">&#x27;white&#x27;</span>  <span class="comment"># 设置文本框背景颜色</span></span><br><span class="line"></span><br><span class="line">        self.textbox_min_moves = TextBox(plt.axes([<span class="number">0.85</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.05</span>]), <span class="string">&#x27;最小步数:&#x27;</span>, initial=<span class="built_in">str</span>(self.min_moves))</span><br><span class="line">        self.textbox_min_moves.color = <span class="string">&#x27;white&#x27;</span>  <span class="comment"># 设置文本框背景颜色</span></span><br><span class="line"></span><br><span class="line">        reset_ax = plt.axes([<span class="number">0.85</span>, <span class="number">0.4</span>, <span class="number">0.1</span>, <span class="number">0.075</span>])</span><br><span class="line">        self.reset_button = Button(reset_ax, <span class="string">&#x27;Reset&#x27;</span>)  <span class="comment"># 修改按钮边框颜色</span></span><br><span class="line">        self.reset_button.on_clicked(self.reset_grid)</span><br><span class="line"></span><br><span class="line">        check_ax = plt.axes([<span class="number">0.85</span>, <span class="number">0.5</span>, <span class="number">0.1</span>, <span class="number">0.1</span>])</span><br><span class="line">        self.check_button = CheckButtons(check_ax, [<span class="string">&#x27;Randomize&#x27;</span>], [<span class="literal">False</span>])</span><br><span class="line"></span><br><span class="line">        answer_ax = plt.axes([<span class="number">0.85</span>, <span class="number">0.6</span>, <span class="number">0.1</span>, <span class="number">0.075</span>])</span><br><span class="line">        self.answer_button = Button(answer_ax, <span class="string">&#x27;Get Answer&#x27;</span>)  <span class="comment"># 修改按钮边框颜色</span></span><br><span class="line">        self.answer_button.on_clicked(self.show_answer)</span><br><span class="line"></span><br><span class="line">        self.draw_grid()</span><br><span class="line"></span><br><span class="line">        self.cid = self.fig.canvas.mpl_connect(<span class="string">&#x27;button_press_event&#x27;</span>, self.on_click)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset_grid</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="keyword">if</span> self.check_button.get_status()[<span class="number">0</span>]:</span><br><span class="line">            self.grid = self.generate_solvable_puzzle()</span><br><span class="line">            self.random_puzzle = self.grid.copy()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.random_puzzle <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self.grid[:] = self.random_puzzle</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.grid[:] = self.initial_grid</span><br><span class="line"></span><br><span class="line">        self.num_moves = <span class="number">0</span></span><br><span class="line">        self.update_moves_text()</span><br><span class="line">        self.draw_grid()</span><br><span class="line">        self.cid = self.fig.canvas.mpl_connect(<span class="string">&#x27;button_press_event&#x27;</span>, self.on_click)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw_grid</span>(<span class="params">self</span>):</span><br><span class="line">        self.ax.clear()</span><br><span class="line">        self.ax.set_xticks([])</span><br><span class="line">        self.ax.set_yticks([])</span><br><span class="line">        <span class="keyword">for</span> spine <span class="keyword">in</span> self.ax.spines.values():</span><br><span class="line">            spine.set_linewidth(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.N):</span><br><span class="line">                <span class="keyword">if</span> self.grid[i, j]:</span><br><span class="line">                    color = self.calculate_color(j, i)</span><br><span class="line">                    rect = plt.Rectangle([j, self.N - i - <span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>, facecolor=color, edgecolor=<span class="string">&#x27;black&#x27;</span>, linewidth=<span class="number">1.5</span>)  <span class="comment"># 增加边框宽度</span></span><br><span class="line">                    self.ax.add_patch(rect)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    rect = plt.Rectangle([j, self.N - i - <span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>, facecolor=<span class="string">&#x27;white&#x27;</span>, edgecolor=<span class="string">&#x27;black&#x27;</span>, linewidth=<span class="number">1.5</span>)  <span class="comment"># 增加边框宽度</span></span><br><span class="line">                    self.ax.add_patch(rect)</span><br><span class="line">        self.ax.set_xlim(<span class="number">0</span>, self.N)</span><br><span class="line">        self.ax.set_ylim(<span class="number">0</span>, self.N)</span><br><span class="line">        self.ax.set_aspect(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">        self.fig.canvas.draw()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_color</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        center_x = self.N / <span class="number">2</span></span><br><span class="line">        center_y = self.N / <span class="number">2</span></span><br><span class="line">        distance = np.sqrt((x - center_x) ** <span class="number">2</span> + (y - center_y) ** <span class="number">2</span>)</span><br><span class="line">        normalized_distance = distance / np.sqrt(center_x ** <span class="number">2</span> + center_y ** <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> self.cmap(normalized_distance)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_moves_text</span>(<span class="params">self</span>):</span><br><span class="line">        self.textbox_moves.set_val(<span class="built_in">str</span>(self.num_moves))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_min_moves_text</span>(<span class="params">self</span>):</span><br><span class="line">        self.textbox_min_moves.set_val(<span class="built_in">str</span>(self.min_moves))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_click</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="keyword">if</span> event.inaxes != self.ax:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x, y = <span class="built_in">int</span>(event.xdata), <span class="built_in">int</span>(self.N - event.ydata)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Clicked at: (<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)&quot;</span>)</span><br><span class="line">        self.flip_tile(x, y)</span><br><span class="line">        self.num_moves += <span class="number">1</span></span><br><span class="line">        self.update_moves_text()</span><br><span class="line">        self.draw_grid()</span><br><span class="line">        <span class="keyword">if</span> np.<span class="built_in">all</span>(self.grid):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Congratulations! You win!&quot;</span>)</span><br><span class="line">            self.min_moves = <span class="built_in">min</span>(self.min_moves, self.num_moves)</span><br><span class="line">            self.update_min_moves_text()</span><br><span class="line">            self.fig.canvas.mpl_disconnect(self.cid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flip_tile</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]:</span><br><span class="line">            nx, ny = x + dx, y + dy</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; self.N <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; self.N:</span><br><span class="line">                self.grid[ny, nx] = <span class="keyword">not</span> self.grid[ny, nx]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_answer</span>(<span class="params">self, event</span>):</span><br><span class="line">        solution = self.solve_puzzle(self.grid)</span><br><span class="line">        <span class="keyword">if</span> solution <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.display_solution(solution)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No solution found.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve_puzzle</span>(<span class="params">self, grid, max_duration=<span class="number">5</span></span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">flip</span>(<span class="params">grid, x, y</span>):</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]:</span><br><span class="line">                nx, ny = x + dx, y + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; self.N <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; self.N:</span><br><span class="line">                    grid[nx, ny] = <span class="keyword">not</span> grid[nx, ny]</span><br><span class="line"></span><br><span class="line">        initial_state = grid.copy()</span><br><span class="line">        target_state = np.ones((self.N, self.N), dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">        queue = deque([(initial_state, [])])</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        start_time = time.time()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">if</span> time.time() - start_time &gt; max_duration:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Solving the puzzle took too long.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            current_grid, path = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> np.array_equal(current_grid, target_state):</span><br><span class="line">                solution_grid = np.zeros((self.N, self.N), dtype=<span class="built_in">bool</span>)</span><br><span class="line">                <span class="keyword">for</span> x, y <span class="keyword">in</span> path:</span><br><span class="line">                    solution_grid[x, y] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span> solution_grid</span><br><span class="line">            state_tuple = <span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, current_grid))</span><br><span class="line">            <span class="keyword">if</span> state_tuple <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visited.add(state_tuple)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.N):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.N):</span><br><span class="line">                    new_grid = current_grid.copy()</span><br><span class="line">                    flip(new_grid, i, j)</span><br><span class="line">                    new_path = path + [(i, j)]</span><br><span class="line">                    queue.append((new_grid, new_path))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display_solution</span>(<span class="params">self, solution</span>):</span><br><span class="line">        fig, ax = plt.subplots()</span><br><span class="line">        ax.set_xticks([])</span><br><span class="line">        ax.set_yticks([])</span><br><span class="line">        <span class="keyword">for</span> spine <span class="keyword">in</span> ax.spines.values():</span><br><span class="line">            spine.set_linewidth(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.N):</span><br><span class="line">                <span class="keyword">if</span> solution[i, j]:</span><br><span class="line">                    rect = plt.Rectangle([j, self.N - i - <span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>, facecolor=<span class="string">&#x27;red&#x27;</span>, edgecolor=<span class="string">&#x27;black&#x27;</span>, linewidth=<span class="number">1.5</span>)  <span class="comment"># 增加边框宽度</span></span><br><span class="line">                    ax.add_patch(rect)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    rect = plt.Rectangle([j, self.N - i - <span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>, facecolor=<span class="string">&#x27;white&#x27;</span>, edgecolor=<span class="string">&#x27;black&#x27;</span>, linewidth=<span class="number">1.5</span>)  <span class="comment"># 增加边框宽度</span></span><br><span class="line">                    ax.add_patch(rect)</span><br><span class="line">        ax.set_xlim(<span class="number">0</span>, self.N)</span><br><span class="line">        ax.set_ylim(<span class="number">0</span>, self.N)</span><br><span class="line">        ax.set_aspect(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_solvable_puzzle</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">flip</span>(<span class="params">board, i, j</span>):</span><br><span class="line">            n = <span class="built_in">len</span>(board)</span><br><span class="line">            board[i, j] ^= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                board[i - <span class="number">1</span>, j] ^= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; n - <span class="number">1</span>:</span><br><span class="line">                board[i + <span class="number">1</span>, j] ^= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                board[i, j - <span class="number">1</span>] ^= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; n - <span class="number">1</span>:</span><br><span class="line">                board[i, j + <span class="number">1</span>] ^= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        n = self.N</span><br><span class="line">        board = np.zeros((n, n), dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">        num_flips = np.random.randint(<span class="number">1</span>, n * n + <span class="number">1</span>)</span><br><span class="line">        flips = np.random.choice(n * n, num_flips, replace=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> flip_index <span class="keyword">in</span> flips:</span><br><span class="line">            i, j = <span class="built_in">divmod</span>(flip_index, n)</span><br><span class="line">            flip(board, i, j)</span><br><span class="line">        <span class="keyword">return</span> board</span><br><span class="line"><span class="comment"># 创建和显示游戏界面</span></span><br><span class="line">flip_game = FlipGame()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>GPT</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期桌游个人推荐（假期结束板）</title>
    <url>/2024/08/20/240820boardgame-reccommend02/</url>
    <content><![CDATA[<p>介绍一下这几天新尝试的桌游</p>
<p>由于时间限制，主要只聊两个近期玩了也赢了五场以上的游戏。</p>
<p>两个游戏分别是：<br>超级巨大幸运盒子（supermegaluckybox） 与 夏洛特13（SHERLOCK13）<br>游戏类型分别是 骰写、运气 与 策略、逻辑、运气</p>
<h2 id="超级巨大幸运盒子（supermegaluckybox）"><a href="#超级巨大幸运盒子（supermegaluckybox）" class="headerlink" title="超级巨大幸运盒子（supermegaluckybox）"></a>超级巨大幸运盒子（supermegaluckybox）</h2><p>这个游戏也<strong>比较热门</strong>。个人认为<strong>上手门槛低，上限中等，有一定的深度</strong>。</p>
<p>和前面介绍的乐队游戏（也是我在BGA上竞技场世界排名截图时第2的游戏）一样，都是<strong>骰写游戏</strong>。<br><strong>骰写，就是指根据获得的卡牌（通常获得哪些卡牌具有一定随机性，像投骰子一样），划掉相应位置的格子。主要决策就是你要划哪个格子。骰写的游戏属性在这个游戏中尤为凸显。</strong></p>
<p>简单介绍一下<strong>游戏规则</strong>：开局选三个幸运盒子。每一轮结束补充一个盒子，共四轮。<br>每轮会随机抽数字卡牌，好像每个数字同一回合最多出现两次。（英语表述挺有问题，但人家听懂了:)，给大家看个笑话吧）</p>
<p><img src="/2024/08/20/240820boardgame-reccommend02/001the_chat.png" alt="001the_chat" title="001the_chat"></p>
<p><img src="/2024/08/20/240820boardgame-reccommend02/002_select_boxes.png" alt="002_select_boxes" title="002_select_boxes"></p>
<p><strong>完成一行一列可以获得幸运盒子上的奖励（如果有的话）</strong>，数字代表立刻划去指定数字的一个格子；？则可以任意选择；闪电则是获得对应数量的闪电（<strong>可以使用闪电，让数字+-1后再划格子，可以同时使用多个闪电，1、9之间只用一个闪电</strong>）；<strong>一轮内获得一个星星+1.两个+4，三个+9，再多无效果</strong>；游戏结束时，<strong>拥有最多月亮数玩家分数+6，最少月亮数-6</strong>，<strong>若并列则一起加（或减）</strong>。<strong>分数相同时看月亮数，月亮数多获胜</strong>。</p>
<p><img src="/2024/08/20/240820boardgame-reccommend02/003_action_example.png" alt="003_action_example" title="003_action_example"></p>
<p>在不同轮完成幸运盒子，<strong>有四档不同分数奖励</strong>，结束时场面上的<strong>未完成盒子每划掉两格加1分</strong>（安慰奖）。</p>
<p><img src="/2024/08/20/240820boardgame-reccommend02/004_scores_example.png" alt="004_scores_example" title="004_scores_example"></p>
<p>这算是一个<strong>比较轻松的决策游戏</strong>。<strong>只用有选盒子和划格子的思考</strong>。虽然<strong>很看运气</strong>。但<strong>决策水平高低差距在场次多的情况下还是比较明显</strong>的。<strong>行列的划额外数字的奖励也可以达成combo</strong>，在一回合完成多个幸运盒子。<strong>（玩法上，3星星收益比当轮完成盒子还高，不过要是月亮太少，待会就被拉回12分的分差；闪电太少，最后一轮可能会多次被迫无法行动）</strong></p>
<h2 id="SHERLOCK13-夏洛特13"><a href="#SHERLOCK13-夏洛特13" class="headerlink" title="SHERLOCK13 夏洛特13"></a>SHERLOCK13 夏洛特13</h2><p>十三张侦探小说相关的角色牌，其中的十二张平均分给所有玩家（1V1除外），抢先通过询问确定剩下的角色的玩家获胜。</p>
<p>回合的行动规则：<br>轮到你的时候，你<strong>必须</strong>选择调查<strong>或</strong>指控。</p>
<p>调查<br>调查分为2种方式：</p>
<ol>
<li>指定一个图标，询问所有其他玩家是否有该图标，拥有图标的玩家举手。发问的玩家无需举手，<strong>你无法知道举手的玩家有几个图标</strong>。</li>
<li><strong>选择一位玩家并指定一个图标，询问该玩家拥有几个该图标</strong>。</li>
</ol>
<p>指控<br>指控一个角色并检查是否犯人，若是，你立即获胜。否则，你出局，其余玩家继续游戏，你仍然可以被其他玩家调查。</p>
<p>在两人局，还有一个将手牌与安置牌交换的操作。由于我1V1只玩了一局，在这里就不提了。后面都是基于三人及以上的人数。</p>
<p><img src="/2024/08/20/240820boardgame-reccommend02/011_solo_interface.png" alt="011_solo_interface" title="011_solo_interface"></p>
<p>《夏洛特13》这个游戏是将13张卡牌中抽出一张作为凶手牌，凶手的身份牌均分给场上各位玩家。各位玩家通过询问操作，争取第一个猜出那张被拿出去的卡牌对应的角色是谁。</p>
<p>相比同类游戏，比如《逻辑对决》和《13道线索》，《夏洛特13》与《逻辑对决》有些相似之处。所有玩家需要猜的是同一张（一组）牌到底是什么。而《13道线索》则是每个玩家猜自己头上被暗示的那3张牌是什么，这些牌对其他玩家是可见的。因此<strong>相比《13道线索》，《夏洛特13》中各位玩家的信息差会小一些，难度也会小一些。</strong></p>
<p>我觉得这个游戏还是一个创造信息差的游戏。你需要通过已有的线索，争取在不过多帮助其他玩家判断的同时，给自己争取出判断正确凶手的独有优势。一个特别优秀的操作是在时机允许的时候，通过一个巧妙的提问，结合自己的已有视角，去直接检验一张或多张牌是否是凶手。即便不是，也不会给其他玩家过多信息；如果是，就可以利用信息差的优势，在下一轮中直接指控。</p>
<p>由于玩家在一个行动中不能同时调查与指控，如果调查行动帮助对手获取了排除范围的决定信息，对手就可以在你之前正确指控，直接获胜。因此要玩好这个游戏，需要考虑对手的视角。</p>
<p>对于我的个人体验来说，<strong>在游戏过程中可以考虑各位玩家选择提问类型的思路</strong>。比如，当你持有的标记数量较少时，你会去问关于标记特定数量的问题。而当你拥有大量标记时，你会选择问其他玩家是否有标记，因为其他玩家大概率处于有一个或没有的状态。这种样子的提问能够更快地缩减“凶手”的范围，还能创造与其它玩家的信息差，为自己创造优势。</p>
<p>通过这种逻辑，<strong>可以通过其他玩家给出的提问类型，猜测他们手中对应标记的数量</strong>。这也是<strong>在迫不得已时</strong>，其他玩家要猜出来时，<strong>抢先进行多选一阻断的重要线索</strong>。不过，对我而言，这类游戏很容易赢得有思路，但输得不明不白。这种输得不明不白的感觉会导致游戏体验非常差，特别是在每局游戏后，如果不进行复盘或复盘不明白的话，很容易陷入负面体验，觉得这游戏根本玩不好。这也是这类游戏的一个缺点。</p>
<p>当然，我之前有一种想法，稍微消除这种体验，就是在自己线下玩的时候立一个村规。村规要求，其他玩家可以知道自己要猜的那三张牌是什么，直接在线下宣告，然后由其他玩家给出答复。最终，当所有玩家都已经猜出自己的牌时，在游戏中让第一个猜对的人获胜。</p>
<p>下面是对一局游戏的分析。也算是复盘吧。这局三人游戏在第九个行动就结束了。虽然结束了，但是有猜的成分，并不能通过逻辑严谨证明犯人100%是那个角色。</p>
<p><img src="/2024/08/20/240820boardgame-reccommend02/012_game_example_interface.png" alt="012_game_example_interface" title="012_game_example_interface"></p>
<p>游戏开始时，紫色玩家为起始玩家，先询问了其它玩家有没有灯泡。<br>灯泡的询问结果是 0 (绿) _(紫) √(蓝)   （紫色玩家问的，所以紫色玩家处无信息）</p>
<p>接着蓝色玩家询问其它玩家有没有拳头。<br>拳头的的询问结果是 √ (绿) √_(紫) _(蓝)</p>
<p>我认为灯泡图标，我的”0”应该会让其它两位玩家对彼此的灯泡数量很感兴趣，所以我先问其它信息。按照“问其它玩家有没有，大概率是2+”的逻辑，问了蓝色拳头的数量，问出了1。这时局面就很尴尬了，有可能是对紫色玩家的优势局面（若紫色的拳头数是3，则拳头全部排除）。</p>
<p>之后紫色蓝色玩家互问灯泡的数量。得知灯泡的分布数量是0 3 2。凶手没有灯泡标识。</p>
<p>此时紫色玩家由于灯泡3，拳头2+，所以他一定有夏洛克·福尔摩斯这个人物。（只有这个人物同时有灯泡和拳头，如果没有手牌数至少为5，超出4的上限了，所以这个人物只能在他手里）。但这又匪夷所思：他有拳头+灯泡的组合，还去问灯泡，这对排除拳头没有帮助。<br>我一头雾水，胆战心惊地询问紫色玩家警徽的数量（如果紫色玩家拳头数量为2，那么他离胜利是最近的，是三选一）</p>
<p>紫色玩家询问了其它玩家骷髅的数量。现在灯泡已经确定不是凶手了，剩下一张没有灯泡的骷髅牌带力量图标。也就是说紫色玩家的行动在排除力量。紫色玩家如果有3个力量，在他的视角力量是3 1 1，已经排除嫌疑了，这个行动会是个无意义的行动。假设紫色玩家的行动有意义，那么他手上一定只有两个力量标记，视角是√ 2 1，力量仍未排除。同时，由于紫色玩家在排除 塞巴斯蒂安·莫兰 这个人物的嫌疑，因此这个人物要么在蓝色玩家手里，要么就是凶手。（不过我玩的时候只觉得凶手多半在力量里，紫色玩家至少一张骷髅牌）</p>
<p>蓝色玩家选择了询问我警徽的数量。他在排警徽。（当时混沌地觉得他不排骷髅估计就是有骷髅+力量了）</p>
<p>最后到我行动。我场上玩时认为对手已经能猜了，用尽剩下两三分钟的思考时间来决定指控哪位角色。我觉得骷髅+力量在蓝色手里，想在剩下两个警徽里二选一。又有为啥其它玩家都不问书的想法，赌带书标记的在其它玩家手里，二选一选到了正确答案。如果我不猜，得赌别人不猜或猜错才有机会了。</p>
<p><img src="/2024/08/20/240820boardgame-reccommend02/013_game_example_action_lists.png" alt="013_game_example_action_lists" title="013_game_example_action_lists"></p>
]]></content>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期桌游个人推荐（假期中期板）</title>
    <url>/2024/07/29/boardgame-reccommend01/</url>
    <content><![CDATA[<p>涉及游戏列表：</p>
<p>Mojo： 跟UNO像但不一样的打牌游戏<br>Cat In the Box 薛定谔的猫<br>Can’t stop 欲罢不能<br>Draft &amp; Write Records 组建乐队与创作唱片</p>
<p>假期已经快要过半了，大家都在干什么呢？<br>我最近经常在BGA上玩桌游 <a href="https://boardgamearena.com/?sp=1khg9j">https://boardgamearena.com/?sp=1khg9j</a> ，最近尝试了几个此前没有玩过的桌游。这篇动态&#x2F;博客主要分享一下新玩的比较感兴趣的四个桌游。</p>
<h2 id="Mojo：-休闲的类UNO游戏"><a href="#Mojo：-休闲的类UNO游戏" class="headerlink" title="Mojo： 休闲的类UNO游戏"></a>Mojo： 休闲的类UNO游戏</h2><p>单局时长一般是十几二十分钟。<br>与UNO类似，当有人“出完牌”时，计算手里剩余卡牌的点数总和，进行下一轮。当有人的点数累加到50时就立刻结束。<br>其中没有功能牌，只有出牌的选项。在你的回合里，出的牌比弃牌堆上的牌大得重抽一张牌并结束回合，相等则继续出牌，小则直接结束回合。在计分时，相同颜色（都是紧挨着的数字）的牌只记最大数字。另外若回合结束后手牌只有三张以下，则不能再出牌，等待轮次进行结算。触发结算的玩家如果数字点数之和不是最小的（之一），要额外加10分，是最小的则不加分。<br>Mojo算是比较休闲的牌类游戏，有一定策略性，但很好上手。两个弃牌堆的拓展增强了策略性，略微削弱运气成分。</p>
<p><img src="/2024/07/29/boardgame-reccommend01/001.png" alt="001" title="001"></p>
<h2 id="Cat-In-the-Box-盒中猫：薛定谔的猫，有趣新颖的策略游戏"><a href="#Cat-In-the-Box-盒中猫：薛定谔的猫，有趣新颖的策略游戏" class="headerlink" title="Cat In the Box 盒中猫：薛定谔的猫，有趣新颖的策略游戏"></a>Cat In the Box 盒中猫：薛定谔的猫，有趣新颖的策略游戏</h2><p>（只有会员可以创建房间，非会员只能搜索加入已有房间）</p>
<p><img src="/2024/07/29/boardgame-reccommend01/002.png" alt="002" title="002"></p>
<p>新颖点1：在一轮开始时，需要预测自己这轮能吃到的墩数，只有在回合结束时正好吃到对应墩数，才能获得额外奖励分（奖励分等于棋子连接的最大数量，斜向连接不算）<br>新颖点2：手中牌只有数字，牌的颜色由玩家宣告。但是，如果宣称自己没有某个颜色（从而在如蓝色为基本色的回合宣告出红色的猫），之后的便不能违反这个宣告（不能宣告自己出的猫是蓝色）。（吃墩优先级 红色&gt;基本色，优先级相同看数字大小，大的吃墩，下回合从吃墩者开始。）<br>新颖点3：每个数字的猫都有5只，除去当轮开始时弃的1张与最后剩的1张，剩下的数量正好把所有格子填满。如果某位玩家宣告出现了悖论（无法符合规则地出任何一张手牌），该轮立刻结束，该玩家倒扣该轮吃的墩数，并且得不到奖励分。 只要有意驱使，悖论是不可避免的。</p>
<p>个人游戏体验，如果想不垫底，往死里防自己悖论，与此同时尽量吃到奖励分，再不行多吃墩。一般蓝绿黄各自第一次做基本色时，没人会起红色的，第二次基本一定有人起红色，如果想吃墩要注意。<br>上面的图片直接展示了悖论是什么样的。该玩家先前已经宣告自己没有黄色、蓝色、红色，对于数字3和8，只有蓝色的3和红色的8没被宣告过，若宣告这两，则与先前的宣告违背，形成悖论。下一次轮到他时就宣告产生悖论，该轮结束了。</p>
<h2 id="Can’t-stop-欲罢不能"><a href="#Can’t-stop-欲罢不能" class="headerlink" title="Can’t stop 欲罢不能"></a>Can’t stop 欲罢不能</h2><p>这个是很经典的赌狗游戏。胜利是属于运气好和胆大的人的。<br>投四个骰子，骰子两两组合，数字相加则为可走的路线。一位玩家一回合中最多能同时走三条路线。掷出后必须选择路线前进。如果掷出的点数无法组成三条路线中的任意一条，你这回合内的进度全部丢失。你可以选择不断重投，一回合内投15次，也可以及时收手，保留已有的攀登进度。先占到三个山头的玩家获胜。</p>
<p><img src="/2024/07/29/boardgame-reccommend01/003.png" alt="003" title="003"></p>
<p>我的评价是：撑死胆大的，饿死胆小的。别人都听牌了，此时不博下回直接游戏结束，没得博了。但还是要服从概率。56789可以连投七八次，要是是4 10 12什么的，除非劣势大，还是收了吧。（上面这图，两轮结束了，只有绿色有进度，其它两人开局爆炸了）<br>不过我玩着玩着越来越感觉胜利永远是属于赌狗的。</p>
<p><img src="/2024/07/29/boardgame-reccommend01/004.png" alt="004" title="004"><br>👇<br><img src="/2024/07/29/boardgame-reccommend01/005.png" alt="005" title="005"><br>👇<br><img src="/2024/07/29/boardgame-reccommend01/006.png" alt="006" title="006"><br>👇<br><img src="/2024/07/29/boardgame-reccommend01/007.png" alt="007" title="007"><br>👇<br><img src="/2024/07/29/boardgame-reccommend01/008.png" alt="008" title="008"><br>绿色表示：我的前期优势呢？蓝色你*****</p>
<h2 id="Draft-Write-Records-组建乐队与创作唱片"><a href="#Draft-Write-Records-组建乐队与创作唱片" class="headerlink" title="Draft &amp; Write Records 组建乐队与创作唱片"></a>Draft &amp; Write Records 组建乐队与创作唱片</h2><p>规则吓人但玩得还好的骰写策略游戏，一局二十五到四十分钟<br>下面这张大图是截码战群里的一位群友写的教程。但要纠正一个关键的已知的错误：<br>游戏目标中，并不是“1个月”，至少在3人局中一共有7周。第7周会使用前面几周没被使用的牌。</p>
<p><img src="/2024/07/29/boardgame-reccommend01/009.jpg" alt="009" title="009"></p>
<h3 id="原文本：（翻译：现在认知更新了，可以看新的）"><a href="#原文本：（翻译：现在认知更新了，可以看新的）" class="headerlink" title="原文本：（翻译：现在认知更新了，可以看新的）"></a>原文本：（翻译：现在认知更新了，可以看新的）</h3><p>如果开局奔着日程的×3×4去，最好赶紧通过招募齐乐队成员，在第四五周或第六周前两个行动赶紧把乐队成员招满，提前结束游戏。如果日程和提升勾掉的多，后期一个行动触发一波combo直接加几十分的。不这样rush的话，小心其他人一个行动直接把你分数优势抹平+反超。另外要是第四周或五周前两个行动就rush（得有任务奖励支撑）的话，其他人大概率都会扣满20分（游戏结束时每缺一个乐队成员要打一个×，左上角，打满五个最后扣20分），优势更大。<br>在所有公共任务都不好完成时，可以考虑主提升副日程，有成员羁绊就放成员，利用乐谱（正下方）与提升的巡演标记，沿着右上的路线走，吃掉路线上的25分（主要路上有专辑，并且第二张专辑给的奖励是巡演标记，可以快速推进，在rush的同时快速拿巡演的高分）。<br>不过要是运气太差，可以选的成员构不成羁绊，可能计划就破产了。这种玩法要拿第一，乐谱那里也得拿分，估计得划至少一横一竖。</p>
<p>公共任务好完成的话，很有可能会是完成6个任务导致游戏结束。运气好抢任务在四周直接完成6个，其它分数支持一下排名就稳定靠前了。（算分时注意乐队成员不满的扣分）。要注意的是，如果已经完成了6个任务，即使当周你还有已完成的任务，都不再能宣告任务完成了。</p>
<p>对于任务奖励，越是打到五六周（后期），划掉任一一个提升的奖励就能引起越多combo。前期自己完成了提升奖励的个人任务，可以留着等后面宣告。</p>
<h3 id="240820："><a href="#240820：" class="headerlink" title="240820："></a>240820：</h3><p>成功在某一时刻拿到了这个游戏竞技场的世界第二。</p>
<p>策略主要是<strong>如何与对手争抢公共任务</strong>，在<strong>进行分析后做出抉择</strong>。</p>
<p><strong>公共任务是必须争</strong>的，甚至想着<strong>“独占”</strong>任务，获得奖励和分数优势。拉不开优势也别被落下。</p>
<p>个人任务的宣告服务于公共任务，如果其奖励于公共任务无关，你暂时也不需要，<strong>可以选择不宣告个人目标</strong>。<strong>但要注意当周游戏是否结束了</strong>，不要弄巧成拙。</p>
<p>卡牌的选取还是看自己的理解。特别是主唱这个数量应该较少的特殊乐队成员，早放下去很容易与后面的音乐家构成和声，对手可能会由于你的<strong>拦截</strong>迟迟拿不到主唱。</p>
<p>一般还是<strong>多板块联动</strong>，由于现金限制开局没法动巡演板块。但<strong>后期巡演板块能带来很高的分数上限</strong>。</p>
<p><strong>尽量把游戏结束的机会握在手里。如果没有结束游戏的机会，至少也要留有争上限的机会。</strong></p>
]]></content>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot中WebSocket的连接 笔记</title>
    <url>/2024/10/31/WebSocketNote/</url>
    <content><![CDATA[<h1 id="SpringBoot中WebSocket的连接-笔记"><a href="#SpringBoot中WebSocket的连接-笔记" class="headerlink" title="SpringBoot中WebSocket的连接 笔记"></a>SpringBoot中WebSocket的连接 笔记</h1><h2 id="1-WebSocket前端调用"><a href="#1-WebSocket前端调用" class="headerlink" title="1. WebSocket前端调用"></a>1. WebSocket前端调用</h2><p>在我的 Vue3 Vite 前端中，WebSocket 的调用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">socket.<span class="property">value</span> = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">`<span class="subst">$&#123;<span class="keyword">import</span>.meta.env.VITE_WEBSOCKET_URL&#125;</span>/<span class="subst">$&#123;questionRoomId.value&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<p>其中，涉及的环境变量的定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VITE_WEBSOCKET_URL=ws://localhost:8080/ws</span><br></pre></td></tr></table></figure>

<p>当前端执行 <code>new WebSocket(url)</code> 时，浏览器会尝试与指定的 WebSocket 服务器建立连接。</p>
<p>WebSocket 使用 HTTP 协议进行初始的握手过程。浏览器会发送一个 HTTP 请求，包含特定的头信息来请求建立 WebSocket 连接。服务器接收到这个请求后，会返回一个带有 HTTP 状态码 101（切换协议）的响应，表示同意建立 WebSocket 连接。一旦服务器确认了请求，连接就建立成功。此时，浏览器和服务器之间可以进行双向通信。</p>
<p>可以通过监听 WebSocket 的事件（如 <code>onopen</code>、<code>onmessage</code>、<code>onclose</code> 和 <code>onerror</code>）来处理连接的状态和数据。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">socket.<span class="property">value</span>.<span class="property">onopen</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket connection established&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.<span class="property">value</span>.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message from server:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-后端对WebSocket连接的处理"><a href="#2-后端对WebSocket连接的处理" class="headerlink" title="2. 后端对WebSocket连接的处理"></a>2. 后端对WebSocket连接的处理</h2><p>在 Spring Boot 的后端，<code>WebSocketConfig</code> 实现了 <code>WebSocketConfigurer</code> 接口，通过实现其方法 <code>registerWebSocketHandlers(WebSocketHandlerRegistry registry)</code> 来定义和注册 WebSocket 端点。此方法通过 <code>registry.addHandler()</code> 关联 WebSocket 端点 URL 和消息处理器，指定前端 WebSocket 请求的接入路径。Spring 会在应用启动时自动调用此方法，完成 WebSocket 端点的配置，使后端能够在前端请求时自动接收并处理 WebSocket 连接。</p>
<h3 id="2-1-WebSocket端点的配置"><a href="#2-1-WebSocket端点的配置" class="headerlink" title="2.1 WebSocket端点的配置"></a>2.1 WebSocket端点的配置</h3><p>对该方法中 <code>registry.addHandler(new WebSocketHandler(), &quot;/ws/&#123;roomId&#125;&quot;).setAllowedOrigins(&quot;*&quot;);</code> 的实现逻辑进行分析：</p>
<ul>
<li><p><code>registry.addHandler</code> 中的第一个参数 <code>new WebSocketHandler()</code> 表示自定义的 WebSocketHandler 实现类，包含处理 WebSocket 消息的逻辑，该类需要实现 <code>WebSocketHandler</code> 接口。</p>
</li>
<li><p>第二个参数 <code>&quot;/ws/&#123;roomId&#125;&quot;</code> 指定 WebSocket 端点的 URL 模式。前端可以通过这个 URL 与后端建立 WebSocket 连接。其中 <code>&#123;roomId&#125;</code> 是路径变量，允许在 URL 中动态指定。例如，<code>/ws/123</code> 会为房间 ID 为 123 的房间创建连接。</p>
</li>
<li><p><code>setAllowedOrigins(&quot;*&quot;)</code> 用于设置跨域请求的来源，允许哪些源可以访问该 WebSocket 端点。<code>&quot;*&quot;</code> 表示允许所有来源进行跨域连接。<code>setAllowedOrigins</code> 可指定多个具体的域名（如 <code>http://example.com</code>），以控制 WebSocket 的跨域访问权限。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addHandler(<span class="keyword">new</span> <span class="title class_">WebSocketHandler</span>(), <span class="string">&quot;/ws/&#123;roomId&#125;&quot;</span>).setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-WebSocket连接建立"><a href="#3-WebSocket连接建立" class="headerlink" title="3. WebSocket连接建立"></a>3. WebSocket连接建立</h2><p>在 WebSocket 连接建立时，Spring 框架会自动创建并传递 <code>session</code> 参数（Spring 框架创建了一个新的代表与特定客户端连接的 <code>WebSocketSession</code> 实例，并回调 <code>WebSocketHandler</code> 中的 <code>afterConnectionEstablished</code> 方法，将新创建的 <code>WebSocketSession</code> 作为参数传入）。接下来分析 <code>WebSocketHandler</code> 中的 <code>afterConnectionEstablished</code> 方法，我在项目中的实现如下。在我定义的方法中，我将 <code>roomId</code> 存储到了 <code>session</code> 的属性中。</p>
<h3 id="3-1-WebSocketSession对象信息"><a href="#3-1-WebSocketSession对象信息" class="headerlink" title="3.1 WebSocketSession对象信息"></a>3.1 WebSocketSession对象信息</h3><p><code>session</code> 是 <code>WebSocketSession</code> 对象，它本身包含的重要信息如下：</p>
<ul>
<li><strong>会话 ID</strong>：通过 <code>getId()</code> 获取唯一标识每个连接的 ID。</li>
<li><strong>URI 和路径</strong>：<ul>
<li><code>getUri()</code>: 获取连接的 URI，用于解析请求来源和路径参数。</li>
<li><code>getUri().getPath()</code>: 可提取动态路径变量（如 <code>&#123;roomId&#125;</code>）。</li>
</ul>
</li>
<li><strong>属性</strong>：<code>getAttributes()</code> 返回一个 <code>Map&lt;String, Object&gt;</code>，用于存储与会话相关的任意数据（如我存储的房间 ID）。</li>
<li><strong>连接状态</strong>：<code>isOpen()</code> 检查连接是否有效。</li>
<li><strong>消息处理</strong>：使用 <code>sendMessage(TextMessage message)</code> 向客户端发送消息。</li>
<li><strong>用户信息</strong>：<code>getPrincipal()</code>（如有安全性设置）可获取代表连接用户的 Principal 对象。</li>
<li><strong>连接时间</strong>：可用于获取连接时间或最后活动时间（具体取决于实现）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">roomId</span> <span class="operator">=</span> session.getUri().getPath().split(<span class="string">&quot;/&quot;</span>)[<span class="number">2</span>];</span><br><span class="line">    session.getAttributes().put(<span class="string">&quot;roomId&quot;</span>, roomId);  <span class="comment">// 存储 roomId</span></span><br><span class="line">    System.out.println(<span class="string">&quot;连接建立：房间 ID = &quot;</span> + roomId + <span class="string">&quot;, 会话 ID = &quot;</span> + session.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-消息处理与广播"><a href="#4-消息处理与广播" class="headerlink" title="4. 消息处理与广播"></a>4. 消息处理与广播</h2><p>在重写的 <code>handleTextMessage</code> 方法中，通过 <code>session</code> 获取了 <code>roomId</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String) session.getAttributes().get(<span class="string">&quot;roomId&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>另外，在 <code>ConnectionManager</code> 的 <code>broadcastToConnections(String roomId, Map&lt;String, Object&gt; message)</code> 方法（用于广播信息）中，利用 <code>session</code> 广播的信息。下面这个循环，对 <code>Room</code> 对象 <code>room</code> 中的 <code>private List&lt;WebSocketSession&gt; connections</code> 进行遍历，遍历房间中的所有 WebSocket 连接，若连接开放则发送文本格式消息到连接的客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (WebSocketSession connection : room.getConnections()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (connection.isOpen()) &#123;</span><br><span class="line">            connection.sendMessage(<span class="keyword">new</span> <span class="title class_">TextMessage</span>(messageJson));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace(); <span class="comment">// 处理异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接建立之后，当客户端通过 WebSocket 发送消息时，<code>handleTextMessage(WebSocketSession session, TextMessage message)</code> 方法被调用。默认情况下，<code>handleTextMessage</code> 方法会直接接收并处理 <code>TextMessage</code> 对象。这个对象包含了客户端发送的文本内容。但是默认实现不会执行任何操作，处理过程的异常也不会被传递给客户端，只会在控制台中捕获记录。</p>
<p>在我的 Vue3 前端中，创建的 WebSocket 对象存储在 <code>socket.value</code> 中，发送信息的形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getLatestAnswers</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> requestData = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;get_latest_answers&#x27;</span>,</span><br><span class="line">        <span class="attr">questionerId</span>: playerId.<span class="property">value</span></span><br><span class="line">    &#125;;</span><br><span class="line">    socket.<span class="property">value</span>.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(requestData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我重写的 <code>handleTextMessage</code> 方法中，接收到的消息被解析并根据消息类型调用相应的逻辑。具体的类型定义与解析方法根据自己定义的信息结构实现。对于上面这个信息，依据逻辑会进入分支：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;get_latest_answers&quot;</span>:</span><br><span class="line">    manager.getLatestAnswers(roomId);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>并在我实现的 <code>manager</code> 对象中实现相关逻辑。（<code>manager</code> 是我自定义的 <code>ConnectionManager</code> 对象实例，不涉及 WebSocket 相关接口的继承，用于处理信息）</p>
<h2 id="5-WebSocket连接关闭"><a href="#5-WebSocket连接关闭" class="headerlink" title="5. WebSocket连接关闭"></a>5. WebSocket连接关闭</h2><p>在 WebSocket 应用中，<code>afterConnectionClosed(WebSocketSession session, CloseStatus status)</code> 方法会在 WebSocket 连接被关闭时自动执行。具体来说，它会在以下几种情况下被调用：</p>
<ul>
<li><p><strong>正常关闭</strong>：</p>
<ul>
<li>客户端或服务器通过调用 <code>session.close()</code> 显式关闭连接。</li>
</ul>
</li>
<li><p><strong>意外关闭</strong>：</p>
<ul>
<li>连接由于网络问题、浏览器关闭、页面刷新等原因而意外关闭。</li>
</ul>
</li>
<li><p><strong>超时</strong>：</p>
<ul>
<li>服务器端检测到某种超时条件（如未发送消息）后关闭连接。</li>
</ul>
</li>
</ul>
<p>对于项目来说，需要在连接关闭后妥善处理连接信息。在我的项目代码中，涉及到房间中存储 WebSocket 连接的 List 对象的相关删除操作，以及玩家信息的处理操作。</p>
]]></content>
      <categories>
        <category>major</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>A*解决八数码问题</title>
    <url>/2024/11/12/241112A-%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Astars算法的基本思想是：<br>定义合适的代价函数gx和启发式函数hx，当gx和hx都满足条件时，Astars算法就可以保证得到最优解。<br>我对状态的定义如下：<br>状态由名为Node的结构体表示，其中包含一个三行三列的二维数组A，A中0的坐标x0、y0，Astars算法相关的fx、gx、hx参数组成。<br>gx意味到达该状态移动的次数，hx为启发式函数，这里设定为不在位的数字的数量，这个条件从不高估从节点x到目标节点的实际代价。八数字中的0表示空位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> A[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> x0;</span><br><span class="line">    <span class="type">int</span> y0;</span><br><span class="line">    <span class="type">int</span> gx;</span><br><span class="line">    <span class="type">int</span> hx; <span class="comment">// 其实不用存</span></span><br><span class="line">    <span class="type">int</span> fx;</span><br><span class="line">    <span class="type">bool</span> visited;<span class="comment">// 最后版本无用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(Node* existNode) &#123;</span><br><span class="line">        <span class="comment">// 复制已有对象</span></span><br><span class="line">        <span class="keyword">if</span> (existNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;A[i][j] = existNode-&gt;A[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;x0 = existNode-&gt;x0;</span><br><span class="line">            <span class="keyword">this</span>-&gt;y0 = existNode-&gt;y0;</span><br><span class="line">            <span class="keyword">this</span>-&gt;gx = existNode-&gt;gx;</span><br><span class="line">            <span class="keyword">this</span>-&gt;hx = existNode-&gt;hx;</span><br><span class="line">            <span class="keyword">this</span>-&gt;fx = existNode-&gt;fx;</span><br><span class="line">            <span class="keyword">this</span>-&gt;visited = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Node</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;A[i][j] = i + j * <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;gx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;hx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;fx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;visited = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行过程中，现对初始状态进行判断，若不是目标状态，进行Astars算法（调用search函数）。先通过x0,y0定位0的位置，进行状态拓展（expand函数，根据当前状态复制一个node，然后调整相关参数，包括移动的两个数字，0的坐标，fx gx hx)。之后通过排序算法选取fx最小的状态，进行判断。<br>这个过程中涉及到两个关键问题：一是如何避免产生重复的状态，二是排序的效率问题（代码通过洛谷的相应题目进行检验，排序效率过低会Time Limit Exceed）。</p>
<p>对于“如何避免产生重复状态”的问题，8数码问题可以用字符串区分不同状态的字符串。采用同一种方式给各个状态编码。我在Node类内定义了一个序列化函数serialize()，将当前状态的数组转换为一个字符串。额外使用unordered_set对转换后的序列进行哈希存储。当要拓展新状态时，查找unordered_set对象中，是否有与新状态序列化的结果相同的序列。查找到则不拓展这个状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;string&gt; visitedStates;</span><br><span class="line">Node* newNode = <span class="built_in">expand</span>(x + <span class="number">1</span>, y, current, B);</span><br><span class="line"><span class="keyword">if</span> (visitedStates.<span class="built_in">find</span>(newNode-&gt;<span class="built_in">serialize</span>()) == visitedStates.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    nodeQueue.<span class="built_in">push</span>(newNode);</span><br><span class="line">    visitedStates.<span class="built_in">insert</span>(newNode-&gt;<span class="built_in">serialize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对于“排序的效率问题”，我先在忽略效率问题的前提下，采用了O(n)的遍历策略。之后（现版本）采用了std标准库中的priority_queue，自定义了CompareNode进行元素优先级的比较。具体定义为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;Node*, vector&lt;Node*&gt;, CompareNode&gt; nodeQueue;</span><br></pre></td></tr></table></figure>

<p>Node<em>表示容器中包含的元素类型为Node</em>；vector&lt;Node*&gt;为优先队列的容器模板；CompareNode为自定义的比较逻辑，不实现时默认使用std::less创造最大堆。我们这里要使fx最小的排最前面，优先取出，因此用Node1-&gt;fx &gt; Node2-&gt;fx。具体定义为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareNode</span> &#123;</span><br><span class="line">    <span class="comment">// priority_queue默认会调用std::less，最终构成最大堆</span></span><br><span class="line">    <span class="comment">// 当定义比较器为 CompareNode 且 CompareNode::operator() 返回 true 时，</span></span><br><span class="line">    <span class="comment">// priority_queue 会认为第一个参数比第二个参数优先级低，因此不会把它放在堆顶</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node* a, Node* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;fx &gt; b-&gt;fx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>各个元素在被取出后从优先队列中删除。<br>另外，虽然行列的设置只要统一，行列反了也不影响，如果反了，就是在对矩阵转置，目标状态和当前状态对应的两个矩阵都会转置，在解题逻辑中没有影响。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后要获取0的位置</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> A[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> x0;</span><br><span class="line">    <span class="type">int</span> y0;</span><br><span class="line">    <span class="type">int</span> gx;</span><br><span class="line">    <span class="type">int</span> hx; <span class="comment">// 其实不用存</span></span><br><span class="line">    <span class="type">int</span> fx;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(Node* existNode) &#123;</span><br><span class="line">        <span class="comment">// 复制已有对象</span></span><br><span class="line">        <span class="keyword">if</span> (existNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;A[i][j] = existNode-&gt;A[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;x0 = existNode-&gt;x0;</span><br><span class="line">            <span class="keyword">this</span>-&gt;y0 = existNode-&gt;y0;</span><br><span class="line">            <span class="keyword">this</span>-&gt;gx = existNode-&gt;gx;</span><br><span class="line">            <span class="keyword">this</span>-&gt;hx = existNode-&gt;hx;</span><br><span class="line">            <span class="keyword">this</span>-&gt;fx = existNode-&gt;fx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Node</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;A[i][j] = i + j * <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;gx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;hx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;fx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化状态为一个字符串，用于哈希集合存储</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                s += <span class="built_in">to_string</span>(A[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareNode</span> &#123;</span><br><span class="line">    <span class="comment">// priority_queue默认会调用&lt;，最终构成最大堆</span></span><br><span class="line">    <span class="comment">// 当定义比较器为 CompareNode 且 CompareNode::operator() 返回 true 时，</span></span><br><span class="line">    <span class="comment">// priority_queue 会认为第一个参数比第二个参数优先级低，因此不会把它放在堆顶</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node* a, Node* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;fx &gt; b-&gt;fx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compareMap</span><span class="params">(Node* node, <span class="type">int</span> target[<span class="number">3</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 比较</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 由于数组插入的差异，二者横纵相反</span></span><br><span class="line">            <span class="keyword">if</span> (target[i][j] != <span class="number">0</span> &amp;&amp; node-&gt;A[i][j] != target[i][j]) &#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">expand</span><span class="params">(<span class="type">int</span> tx, <span class="type">int</span> ty, Node* node, <span class="type">int</span> target[<span class="number">3</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(node);</span><br><span class="line">    newNode-&gt;A[node-&gt;x0][node-&gt;y0] = newNode-&gt;A[tx][ty];</span><br><span class="line">    newNode-&gt;A[tx][ty] = <span class="number">0</span>;</span><br><span class="line">    newNode-&gt;x0 = tx;</span><br><span class="line">    newNode-&gt;y0 = ty;</span><br><span class="line">    newNode-&gt;gx = node-&gt;gx + <span class="number">1</span>; <span class="comment">// 步数加一</span></span><br><span class="line">    newNode-&gt;hx = <span class="built_in">compareMap</span>(newNode, target);</span><br><span class="line">    newNode-&gt;fx = newNode-&gt;gx + newNode-&gt;hx;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(Node* node, <span class="type">int</span> target[<span class="number">3</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始状态非目标状态，开始搜索</span></span><br><span class="line">    priority_queue&lt;Node*, vector&lt;Node*&gt;, CompareNode&gt; nodeQueue;</span><br><span class="line">    unordered_set&lt;string&gt; visitedStates;</span><br><span class="line"></span><br><span class="line">    nodeQueue.<span class="built_in">push</span>(node);</span><br><span class="line">    visitedStates.<span class="built_in">insert</span>(node-&gt;<span class="built_in">serialize</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!nodeQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* current = nodeQueue.<span class="built_in">top</span>();</span><br><span class="line">        nodeQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">compareMap</span>(current, target) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> current-&gt;gx;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = current-&gt;x0;</span><br><span class="line">        <span class="type">int</span> y = current-&gt;y0;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Node* newNode = <span class="built_in">expand</span>(x + <span class="number">1</span>, y, current, target);</span><br><span class="line">            <span class="keyword">if</span> (visitedStates.<span class="built_in">find</span>(newNode-&gt;<span class="built_in">serialize</span>()) == visitedStates.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                nodeQueue.<span class="built_in">push</span>(newNode);</span><br><span class="line">                visitedStates.<span class="built_in">insert</span>(newNode-&gt;<span class="built_in">serialize</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">delete</span> newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Node* newNode = <span class="built_in">expand</span>(x - <span class="number">1</span>, y, current, target);</span><br><span class="line">            <span class="keyword">if</span> (visitedStates.<span class="built_in">find</span>(newNode-&gt;<span class="built_in">serialize</span>()) == visitedStates.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                nodeQueue.<span class="built_in">push</span>(newNode);</span><br><span class="line">                visitedStates.<span class="built_in">insert</span>(newNode-&gt;<span class="built_in">serialize</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">delete</span> newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Node* newNode = <span class="built_in">expand</span>(x, y + <span class="number">1</span>, current, target);</span><br><span class="line">            <span class="keyword">if</span> (visitedStates.<span class="built_in">find</span>(newNode-&gt;<span class="built_in">serialize</span>()) == visitedStates.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                nodeQueue.<span class="built_in">push</span>(newNode);</span><br><span class="line">                visitedStates.<span class="built_in">insert</span>(newNode-&gt;<span class="built_in">serialize</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">delete</span> newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Node* newNode = <span class="built_in">expand</span>(x, y - <span class="number">1</span>, current, target);</span><br><span class="line">            <span class="keyword">if</span> (visitedStates.<span class="built_in">find</span>(newNode-&gt;<span class="built_in">serialize</span>()) == visitedStates.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                nodeQueue.<span class="built_in">push</span>(newNode);</span><br><span class="line">                visitedStates.<span class="built_in">insert</span>(newNode-&gt;<span class="built_in">serialize</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">delete</span> newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除当前结点</span></span><br><span class="line">        <span class="keyword">delete</span> current;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 理论上不会到这，未找到解决方案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node* initS = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="type">char</span> temp = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;<span class="comment">//行循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;<span class="comment">//列循环</span></span><br><span class="line">            <span class="comment">//cin &gt;&gt; initS-&gt;A[i][j];</span></span><br><span class="line">            cin &gt;&gt; temp;</span><br><span class="line">            initS-&gt;A[i][j] = (<span class="type">int</span>)temp - (<span class="type">int</span>)<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (initS-&gt;A[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                initS-&gt;x0 = i;</span><br><span class="line">                initS-&gt;y0 = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洛谷题中定义的状态</span></span><br><span class="line">    <span class="type">int</span> C[<span class="number">9</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 其实用数组预定义后，由于用i+3*j访问数组，遍历先后顺序都是一样的赋值情况。</span></span><br><span class="line">    <span class="type">int</span> B2[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// i是行，j是列</span></span><br><span class="line">            B2[i][j] = C[<span class="number">3</span> * i + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initS-&gt;gx = <span class="number">0</span>;</span><br><span class="line">    initS-&gt;hx = <span class="built_in">compareMap</span>(initS, B2);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">search</span>(initS, B2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>major</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>241122论文阅读</title>
    <url>/2024/11/22/241122%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>论文代码阅读——手打版</p>
<p>论文链接：</p>
<p>github仓库链接：<br><a href="https://github.com/qingzhenduyu/TAMER">https://github.com/qingzhenduyu/TAMER</a></p>
<p>这里会更多地关注该项目用到的模型架构和训练流程。</p>
<p>从 <code>tamer</code> 文件夹中的 <code>lit_tamer.py</code> 开始阅读。</p>
<p>在 <code>class LitTAMER(pl.LightningModule)</code> 中，定义了模型为 <code>self.tamer_model = TAMER(...)</code>，并定义了 <code>self.exprate_recorder = ExpRateRecorder()</code>。</p>
<p>TAMER 模型（<code>tamer.py</code>）由 <code>Encoder(encoder.py)</code> 和 <code>Decoder(decoder.py)</code> 组成。在定义的 <code>beam_search</code> 函数中，除了 <code>self.encoder</code>，还调用了 <code>self.decoder.beam_search</code>。</p>
<p>关于 <code>beam_search</code>，下面是 GPT 对它的介绍：</p>
<details>
<summary>点击查看 Beam Search 的详细介绍</summary>

<h3 id="Beam-Search-的原理与方法"><a href="#Beam-Search-的原理与方法" class="headerlink" title="Beam Search 的原理与方法"></a><strong>Beam Search 的原理与方法</strong></h3><h4 id="1-Beam-Search-是什么？"><a href="#1-Beam-Search-是什么？" class="headerlink" title="1. Beam Search 是什么？"></a>1. <strong>Beam Search 是什么？</strong></h4><p>Beam Search 是一种序列解码算法，通常用于自然语言生成任务（如机器翻译、文本摘要、图像字幕生成等）。它在逐步生成序列时，不是只选择一个最优候选，而是维护一个固定大小的候选集合，从中寻找全局最优的生成结果。</p>
<hr>
<h4 id="2-核心思想"><a href="#2-核心思想" class="headerlink" title="2. 核心思想"></a>2. <strong>核心思想</strong></h4><ul>
<li><p><strong>扩展搜索树</strong>：<br>将序列生成问题看作树的扩展，每次扩展节点时，基于模型预测的概率，选择前几个（如 beam size &#x3D; 3）概率最高的候选。</p>
</li>
<li><p><strong>权衡搜索空间和效率</strong>：<br>相比贪婪搜索（一次只保留最优路径），Beam Search 能探索更多路径，避免局部最优；相比暴力穷举（尝试所有可能路径），它限制了搜索宽度，提升效率。</p>
</li>
</ul>
<hr>
<h4 id="3-工作流程"><a href="#3-工作流程" class="headerlink" title="3. 工作流程"></a>3. <strong>工作流程</strong></h4><p>以下是逐步生成序列的过程：</p>
<ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>起始标记（如 <code>&lt;SOS&gt;</code>）作为初始序列，分数为 0。</li>
<li>初始化候选集合（称为 Beam），大小为 <code>beam_size</code>。</li>
</ul>
</li>
<li><p><strong>扩展 Beam</strong>：</p>
<ul>
<li>对当前 Beam 中的每个序列，用模型预测下一个词的概率分布。</li>
<li>将每个候选序列与其可能的扩展（即词）组合，计算总得分。</li>
<li>保留总得分最高的 <code>beam_size</code> 个候选序列。</li>
</ul>
</li>
<li><p><strong>终止条件</strong>：</p>
<ul>
<li>所有候选序列都生成了终止标记 <code>&lt;EOS&gt;</code>。</li>
<li>或生成的序列长度达到预设最大值 <code>max_len</code>。</li>
</ul>
</li>
<li><p><strong>输出结果</strong>：</p>
<ul>
<li>从最终的候选集合中，选择分数最高的序列作为输出。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-关键公式"><a href="#4-关键公式" class="headerlink" title="4. 关键公式"></a>4. <strong>关键公式</strong></h4><p><strong>总得分计算</strong>：<br>[<br>\text{Score} &#x3D; \frac{\sum_{t&#x3D;1}^L \log P(y_t | y_{1:t-1})}{L^\alpha}<br>]</p>
<ul>
<li>( L )：序列长度。</li>
<li>( \alpha )：长度惩罚系数（( \alpha &gt; 0 ) 时，惩罚短序列）。</li>
</ul>
<p><strong>长度惩罚的作用</strong>：</p>
<ul>
<li>防止模型过于偏向短序列（短序列的得分累积更高）。</li>
<li>调整模型对不同长度的偏好。</li>
</ul>
<h4 id="5-优势与不足"><a href="#5-优势与不足" class="headerlink" title="5. 优势与不足"></a>5. <strong>优势与不足</strong></h4><ul>
<li><p><strong>优势</strong>：</p>
<ul>
<li>在可接受的计算开销下，生成质量较高的序列。</li>
<li>能发现更优解，避免陷入局部最优。</li>
</ul>
</li>
<li><p><strong>不足</strong>：</p>
<ul>
<li>生成的序列仍可能不是全局最优（近似搜索）。</li>
<li>Beam Size 过大会显著增加计算量。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-与-TAMER-的关系"><a href="#6-与-TAMER-的关系" class="headerlink" title="6. 与 TAMER 的关系"></a>6. <strong>与 TAMER 的关系</strong></h4><p>在 TAMER 中：</p>
<ul>
<li><p><strong>Encoder</strong>：<br>提取图像特征，作为解码器的上下文信息。</p>
</li>
<li><p><strong>Decoder 的 Beam Search</strong>：</p>
<ul>
<li>使用解码器 <code>beam_search</code>，根据编码器输出的特征，逐步生成序列。</li>
<li>每个时间步中扩展候选序列，保留 <code>beam_size</code> 个得分最高的序列，直到生成完成。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-Beam-Search-的改进方向"><a href="#7-Beam-Search-的改进方向" class="headerlink" title="7. Beam Search 的改进方向"></a>7. <strong>Beam Search 的改进方向</strong></h4><ul>
<li><strong>加速优化</strong>：采用动态 Beam Size 或并行化实现，减少计算负担。</li>
<li><strong>多样性增强</strong>：引入随机性（如 Top-K 或采样）来生成更具多样性的候选序列。</li>
<li><strong>混合方法</strong>：结合贪婪搜索和 Beam Search，平衡速度与质量。</li>
</ul>
<hr>
</details><br>

<p>Encoder中，主要使用了<code>DenseNet-B</code>的架构。给出的can项目代码的encoder也使用到了 <code>DenseNet-B</code>。</p>
<p>笔记图片</p>
<p>Decoder中，使用到了<code>Transformer 解码器</code>以及结构相似性计算模块（<code>StructSim</code>）等组件。其中对Transformer相关部分的定义调用了<code>Transformer</code>文件夹中封装的encoder 、decoder等。</p>
<details>
<summary>点击查看 GPT对 Decoder.py 的详细介绍</summary>


<h3 id="decoder-py-的模块和主要原理"><a href="#decoder-py-的模块和主要原理" class="headerlink" title="decoder.py 的模块和主要原理"></a><code>decoder.py</code> 的模块和主要原理</h3><p><code>decoder.py</code> 定义了 <strong>Decoder</strong> 模块，该模块实现了目标序列生成的核心功能，使用了 <strong>Transformer 解码器</strong>、结构相似性计算模块（<code>StructSim</code>）等组件。以下是各模块及其原理的详细解释：</p>
<hr>
<h4 id="1-主要组件和功能"><a href="#1-主要组件和功能" class="headerlink" title="1. 主要组件和功能"></a>1. <strong>主要组件和功能</strong></h4><h5 id="1-LBR-Linear-BatchNorm-ReLU"><a href="#1-LBR-Linear-BatchNorm-ReLU" class="headerlink" title="(1) LBR (Linear + BatchNorm + ReLU)"></a>(1) <strong>LBR (Linear + BatchNorm + ReLU)</strong></h5><ul>
<li>模块定义：<ul>
<li>线性变换 + 层归一化（LayerNorm）+ 激活函数（ReLU）。</li>
</ul>
</li>
<li>功能：作为一种轻量的预处理单元，对输入进行简单变换，增强非线性表达能力。</li>
</ul>
<h5 id="2-StructSim-和-StructSimOneDir"><a href="#2-StructSim-和-StructSimOneDir" class="headerlink" title="(2) StructSim 和 StructSimOneDir"></a>(2) <strong>StructSim 和 StructSimOneDir</strong></h5><ul>
<li>模块定义：<ul>
<li><code>StructSim</code> 包含两个方向的相似性计算模块：<strong>从左到右（l2r）</strong>和<strong>从右到左（r2l）</strong>。</li>
<li>每个方向使用 <code>TransformerEncoder</code> 提取表示，并通过 <code>q + k</code> 的方式计算结构相似性。</li>
</ul>
</li>
<li>功能：<ul>
<li><strong>结构相似性计算</strong>：用来评估序列在目标方向上的一致性，确保生成序列结构合理。</li>
<li>输出一个矩阵，表示目标序列内部的相似性分布。</li>
</ul>
</li>
</ul>
<h5 id="3-build-transformer-decoder"><a href="#3-build-transformer-decoder" class="headerlink" title="(3) _build_transformer_decoder"></a>(3) <strong>_build_transformer_decoder</strong></h5><ul>
<li>模块定义：<ul>
<li>基于 <code>nn.TransformerDecoder</code>，结合 <code>AttentionRefinementModule</code>（ARM）进一步增强解码器性能。</li>
</ul>
</li>
<li>功能：<ul>
<li><strong>ARM 模块</strong>：通过自监督（self-coverage）或交叉覆盖（cross-coverage）的方式，改善注意力权重的分布，从而生成更加准确的序列。</li>
<li><strong>Transformer 解码器层</strong>：实现目标序列的生成逻辑。</li>
</ul>
</li>
</ul>
<h5 id="4-Decoder-类"><a href="#4-Decoder-类" class="headerlink" title="(4) Decoder 类"></a>(4) <strong>Decoder 类</strong></h5><ul>
<li>主要模块：<ul>
<li>**词嵌入 (word_embed)**：将目标序列的单词 ID 映射为向量表示。</li>
<li>**位置编码 (pos_enc)**：通过 <code>WordPosEnc</code> 为嵌入添加位置信息。</li>
<li>**Transformer 解码器 (model)**：通过多层 Transformer 解码序列。</li>
<li>**输出投影 (proj)**：将解码结果映射回词汇表空间，输出每个单词的概率分布。</li>
<li>**结构相似性模块 (struct_sim)**：通过 <code>StructSim</code> 评估解码器的输出序列。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-主要原理"><a href="#2-主要原理" class="headerlink" title="2. 主要原理"></a>2. <strong>主要原理</strong></h4><p>Decoder 模块采用 <strong>Transformer 解码器</strong> 的架构，结合目标任务需求，增加了结构相似性和注意力优化模块。以下是核心原理：</p>
<h5 id="1-Transformer-解码器"><a href="#1-Transformer-解码器" class="headerlink" title="(1) Transformer 解码器"></a>(1) <strong>Transformer 解码器</strong></h5><ul>
<li>解码器由多层堆叠的解码器层组成，每一层包括：<ul>
<li>**自注意力机制 (Self-Attention)**：关注目标序列已生成部分的内部关系。</li>
<li>**交叉注意力机制 (Cross-Attention)**：关注输入特征（图片编码）与目标序列之间的关系。</li>
<li>**前馈网络 (Feedforward Neural Network)**：对注意力结果进一步提取非线性特征。</li>
</ul>
</li>
<li>解码器通过 mask 限制模型只能看到当前时间步之前的输出。</li>
</ul>
<h5 id="2-ARM-Attention-Refinement-Module"><a href="#2-ARM-Attention-Refinement-Module" class="headerlink" title="(2) ARM (Attention Refinement Module)"></a>(2) <strong>ARM (Attention Refinement Module)</strong></h5><ul>
<li>通过调整注意力权重的分布，解决：<ul>
<li><strong>自监督问题</strong>（自注意力的权重集中问题）。</li>
<li><strong>交叉覆盖问题</strong>（输入特征未充分利用问题）。</li>
</ul>
</li>
</ul>
<h5 id="3-结构相似性"><a href="#3-结构相似性" class="headerlink" title="(3) 结构相似性"></a>(3) <strong>结构相似性</strong></h5><ul>
<li><code>StructSim</code> 模块引入两种相似性度量：<ul>
<li>从左到右生成的结构是否合理。</li>
<li>从右到左生成的结构是否一致。</li>
</ul>
</li>
<li>通过 Transformer Encoder 学习表示，并通过加和查询 (<code>q</code>) 和键 (<code>k</code>) 的方式计算相似性。</li>
</ul>
<h5 id="4-目标序列生成过程"><a href="#4-目标序列生成过程" class="headerlink" title="(4) 目标序列生成过程"></a>(4) <strong>目标序列生成过程</strong></h5><ol>
<li><strong>词嵌入和位置编码</strong>：目标序列转换为向量，并加入位置信息。</li>
<li><strong>Transformer 解码</strong>：<ul>
<li>自注意力机制理解序列上下文。</li>
<li>交叉注意力与图片特征交互。</li>
</ul>
</li>
<li><strong>输出预测</strong>：通过全连接层输出词汇表上的概率分布。</li>
<li><strong>相似性评估</strong>：计算生成序列的结构一致性，提供额外的监督信号。</li>
</ol>
<hr>
<h4 id="3-函数解析"><a href="#3-函数解析" class="headerlink" title="3. 函数解析"></a>3. <strong>函数解析</strong></h4><p>以下是模块主要函数及其功能：</p>
<h5 id="Decoder-forward"><a href="#Decoder-forward" class="headerlink" title="Decoder.forward"></a><strong><code>Decoder.forward</code></strong></h5><ul>
<li>输入：图片特征（<code>src</code>）、目标序列（<code>tgt</code>）。</li>
<li>输出：词汇表概率分布（<code>out</code>）和结构相似性（<code>sim</code>）。</li>
<li>过程：<ol>
<li>对目标序列 <code>tgt</code> 进行词嵌入和位置编码。</li>
<li>构造目标序列的掩码（<code>tgt_mask</code> 和 <code>tgt_pad_mask</code>）。</li>
<li>使用 Transformer 解码器处理 <code>tgt</code> 和 <code>src</code>。</li>
<li>计算目标序列的结构相似性。</li>
<li>投影到词汇表空间输出概率分布。</li>
</ol>
</li>
</ul>
<h5 id="Decoder-build-attention-mask"><a href="#Decoder-build-attention-mask" class="headerlink" title="Decoder._build_attention_mask"></a><strong><code>Decoder._build_attention_mask</code></strong></h5><ul>
<li>构造一个<strong>因果掩码</strong>，确保生成序列时只能看到当前时间步之前的内容。</li>
</ul>
<h5 id="Decoder-transform"><a href="#Decoder-transform" class="headerlink" title="Decoder.transform"></a><strong><code>Decoder.transform</code></strong></h5><ul>
<li>封装 <code>forward</code>，专用于生成任务的调用，接收图片特征和输入 ID。</li>
</ul>
<hr>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. <strong>总结</strong></h4><p><code>decoder.py</code> 实现了一个面向图文序列生成任务的解码器，核心特点包括：</p>
<ol>
<li><strong>Transformer 架构</strong>：高效处理序列生成任务。</li>
<li><strong>ARM 和结构相似性模块</strong>：解决注意力分布不均和生成结构不一致问题。</li>
<li><strong>多功能设计</strong>：支持训练和推理过程（如 <code>beam search</code>）。</li>
</ol>
</details><br>


<details>
<summary>某人偷懒没修改的pos_enc.py功能简介</summary>
这段代码定义了几种**位置编码（Positional Encoding）**方法，主要用于为输入特征添加位置信息，从而在模型中保留顺序或空间信息。这些编码方式被应用在不同类型的数据上，如序列数据（单词）或二维图像数据。

<h3 id="功能分类"><a href="#功能分类" class="headerlink" title="功能分类"></a>功能分类</h3><ol>
<li><p><strong>基于正弦和余弦的绝对位置编码</strong>：</p>
<ul>
<li>**<code>WordPosEnc</code>**：<ul>
<li>实现了用于序列输入（如文本）的标准正弦和余弦位置编码。</li>
<li>被用于给序列特征（形状 <code>[b, l, d]</code>）添加位置感知信息。</li>
</ul>
</li>
<li>**<code>ImgPosEnc</code>**：<ul>
<li>将绝对位置编码扩展到二维图像特征，处理形状 <code>[b, h, w, d]</code> 的输入。</li>
<li>通过累积mask反转计算生成二维位置坐标，并添加正弦和余弦的编码值。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基于旋转变换的相对位置编码（Rotary Positional Embedding）</strong>：</p>
<ul>
<li>**<code>WordRotaryEmbed</code>**：<ul>
<li>应用于序列输入，结合正弦和余弦，通过旋转操作实现相对位置编码。</li>
<li>提供更灵活的位置感知能力，适合更复杂的上下文关联建模。</li>
</ul>
</li>
<li>**<code>ImageRotaryEmbed</code>**：<ul>
<li>处理二维图像特征，支持旋转的二维位置编码。</li>
<li>类似于<code>WordRotaryEmbed</code>，但扩展到二维输入（形状 <code>[b, h, w, d]</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>工具函数</strong>：</p>
<ul>
<li>**<code>rotate_every_two</code>**：实现二维旋转，用于旋转嵌入的偶数和奇数维度的值。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="在前述代码中的调用"><a href="#在前述代码中的调用" class="headerlink" title="在前述代码中的调用"></a>在前述代码中的调用</h3><p>这些位置编码模块被用在以下地方：</p>
<ul>
<li>**<code>Decoder</code> 类中的 <code>self.pos_enc</code>**：<ul>
<li><code>WordPosEnc</code> 用于对目标序列（<code>tgt</code>）添加位置编码，以增强 Transformer 解码器对序列顺序的感知。</li>
</ul>
</li>
<li><strong>可能的其他调用场景</strong>（未直接展示）：  <ul>
<li>对图像或序列数据进行位置编码（如<code>ImgPosEnc</code>或<code>ImageRotaryEmbed</code>）可在编码器或解码器的预处理阶段使用，尤其是在 CAN 项目中对图像-文本跨模态任务可能需要的场景。</li>
</ul>
</li>
</ul>
<p>总结：这段代码提供了多种灵活的位置编码方案，可根据输入数据的维度和模型需求灵活选择合适的方法，以增强输入的位置信息表达能力。</p>
</details><br>


<p>对于transformer文件夹，里面包含了支持AttentionRefinementModule（注意力精细化模块）的transformer解码器，也包含MaskBatchNorm2d（自定义掩码批标准化）、AttentionRefinementModule（注意力精细化模块）、MultiheadAttention（多头注意力模块）的具体实现。</p>
<p><code>utils</code> 文件夹是 “utilities”（工具）的缩写，通常在其中存放封装好的各个辅助功能或工具函数。</p>
<details>
<summary>某人偷懒没修改的pos_enc.py功能简介</summary>
</details><br>]]></content>
  </entry>
</search>
