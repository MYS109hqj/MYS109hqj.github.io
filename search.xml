<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一篇简单的博客a simple blog</title>
    <url>/2023/12/12/231212blog/</url>
    <content><![CDATA[<p>(注：bing搜索随笔的英文，结果如下：<br>随笔，英文称“essay”，词源来自法文动词“essayer”，意为“尝试”、“探索”。<br>经过后继搜索，essay由短文，尝试的意思；也可作动词表企图试图<br>所以这个category绝对不是正式的论文的意思)<br>有些丧，觉得自己应该多跟人主动交流，也许现在在做的事情在自我评价体系中得不到正面反馈，要跟他人聊天，多关注周围的事情。<br>觉得这观点并不新颖，如果说概括关键词的话，扩大关注范围、刻意练习表达、频繁交际。<br>基于现在头脑中的映像，我是个喜欢单干又单干不好，兴趣点在游戏实况、游戏赛事与排球，没能在某个领域专精的人。没有频繁尝试。</p>
<p>我现在对打排球有着极高的热忱，不过毕竟排球的反馈直观地来自球，“能力不行-&gt;球垫不好-&gt;球乱飞”的链条是能轻松感受到的。也不断地在学排球的理论知识，但也改变不了目前能力不足的现况。接球嘛，看球的轨迹，移动找击球点。两天没打球，上来垫球就不知道怎么垫了，扣球不能奢望能扣准，毕竟人球关系没有高概率找好的保障，现在这个水平只要愿意尝试、练习也就够了。<br>大一下（之所以说是大一下，而非高三，主要是基于频次和技术，大一下初感觉啥也不会。之前建立的友谊也难得可贵）到现在快一年，我的技术有一定提升，能够在攻防时进行有限的移动，养成了在接球时喊一下的习惯。（经过查看知乎上几篇“关于排球打不好”的文章，启发了后续观点）但毕竟排球的每一项技术（eg.接一传）都需要基本功，需要持续练习。<br>顺带一提，在今天早一点思考时尝试验证了“反应力不行”的想法，结果如下：<a href="https://humanbenchmark.com/tests/reactiontime">反应力测试网站</a><br><img src="/2023/12/12/231212blog/reaction.png" alt="reaction" title="reaction"></p>
]]></content>
      <categories>
        <category>essay</category>
      </categories>
      <tags>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构个人复习总结</title>
    <url>/2023/12/13/231216DataStructureRecovery02/</url>
    <content><![CDATA[<p>注:<a href="http://t.csdnimg.cn/HQvqN">markdown语法参考</a></p>
<p>231217第三次更新，更新完全覆盖之前的内容，查询可以GitHub历史记录<br>（25&#x2F;03&#x2F;01优化部分叙述）<br>单纯个人复习输出，很多图片参考<a href="https://www.icourse163.org/learn/ZJU-93001">MOOC浙江大学数据结构</a>的课件<br>同时参考任课老师<strong>吕建明</strong>的课件内容<br>由于是个人输出，基于对生疏概念复习的需求，只是<strong>有选择性</strong>的做记录，很多内容都没有包含，仅供参考。<br><strong>如果有出错或者疑问的，我愿意一同探究解惑。</strong>按道理能看到这篇博客就有我的联系方式。没有就发邮件。考虑到可能承担未妥善管控不当言论的风险，暂不考虑开评论区&#x2F;留言板。</p>
<h2 id="一、时间复杂度"><a href="#一、时间复杂度" class="headerlink" title="一、时间复杂度"></a>一、时间复杂度</h2><p>1.时间复杂度的符号（上界下界确界）<br>参考文章：<a href="https://blog.csdn.net/anshuai_aw1/article/details/108449000">https://blog.csdn.net/anshuai_aw1/article/details/108449000</a><br><img src="/2023/12/13/231216DataStructureRecovery02/018.png" alt="时间复杂度的相关符号"><br>2.常见操作时间复杂度：<br>参考<a href="http://t.csdnimg.cn/oAog6">http://t.csdnimg.cn/oAog6</a><br>链表、堆栈、队列：插入删除O(1)；查找O(n)<br>二叉搜索树：都是O(logN)<br><img src="/2023/12/13/231216DataStructureRecovery02/002.png" alt="二叉堆时间复杂度"><br><img src="/2023/12/13/231216DataStructureRecovery02/003.png" alt="邻接列表的时间复杂度"></p>
<h2 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h2><p> 1.fence:课件中的定义：”The position of a list to execute operations is defined as a fence.”栅栏体现的是当前操作的位置。不同操作对应位置会有区别，结合下图更好理解。<br><img src="/2023/12/13/231216DataStructureRecovery02/004.png" alt="操作实例"></p>
<h2 id="三、树"><a href="#三、树" class="headerlink" title="三、树"></a>三、树</h2><p>1.树的深度与高度<br>教材定义：结点的深度是从根到结点的距离(The depth of a node M in the tree is the length of the path from the root of the tree to M)，高度比最大深度大一；<br>设总层数为n，则height&#x3D;n; depth_max&#x3D;n-1。<br>网上查阅时，有些教材定义根所在层数为1的，但按用的教材定义是根所在层数是0，导致最大深度是n-1，高度不受影响还是n。（顺带一提，2-3树也一样，注意根的深度是0）<br>2.满(<strong>full</strong>)二叉树与完全(<strong>complete</strong>)二叉树<br><strong>full binary tree</strong>，满二叉树要求每层都达到最大结点树，即结点个数是2^n-1；<br><strong>complete binary tree</strong>，完全二叉树要求最后一层的结点必须从左到右连续，尤其以数组存储时最大结点下标为n，则n以前的有效下标都得有数据<br>(至于下标为0的就看怎么构建了，注意一下在堆中0有没有放哨兵，0不存有效数据是父子下标对应关系会变的，不过课上讲的好像没用哨兵；哨兵放比数据范围更大或更小的值，比较时哨兵就可以起到防止越界的作用)<br>3.注：普通树考点有集合union</p>
<h2 id="四、图"><a href="#四、图" class="headerlink" title="四、图"></a>四、图</h2><p>1.最短路径问题：<br>单源最短路径：从某固定源点出发，求其到所有其它顶点的最短路径<br>多源最短路径：求任意两顶点间的最短路径<br>有权图的单源最短路算法：Dijkstra算法<br><img src="/2023/12/13/231216DataStructureRecovery02/005.png" alt="源自MOOC浙江大学数据结构课件"><br><img src="/2023/12/13/231216DataStructureRecovery02/006.png" alt="源自MOOC浙江大学数据结构课件"><br>（多源最短路算法：Floyd算法，教材上没有，思想差不多）<br><img src="/2023/12/13/231216DataStructureRecovery02/007.png" alt="源自MOOC浙江大学数据结构课件"><br><img src="/2023/12/13/231216DataStructureRecovery02/008.png" alt="源自MOOC浙江大学数据结构课件"><br>2.最小生成树问题<br>(1)Prim算法：贪心法，每次取与邻接点间的边中的最短边<br><img src="/2023/12/13/231216DataStructureRecovery02/009.png" alt="源自MOOC浙江大学数据结构课件"><br>(2)Kruskal算法：将森林合并成树，每次取所有边中的最短边，如果不构成回路就加入。（用并查集，跟集合差不多。根结点存放-n，n表示所在集合中的元素个数；非根元素存放父亲结点，即父亲结点的下标）<br><img src="/2023/12/13/231216DataStructureRecovery02/010.png" alt="源自MOOC浙江大学数据结构课件"></p>
<h2 id="五、散列-哈希"><a href="#五、散列-哈希" class="headerlink" title="五、散列&#x2F;哈希"></a>五、散列&#x2F;哈希</h2><p>1.open hashing，简单来说，指针存储，无限空间。别的都是closed hashing，只能在有限的哈希表里。<br>2.冲突处理Collision Resolution Methods<br>下面的都属于探测散列表(probing hash table)，与之相对的另一类方法是分离链接法(separate chaining)，就是存指针弄链表。<br>线性侦测法(Linear Probing)向后逐个试探,主要还是看它给的p(K,i)是什么，一般是用h(K)+p(K,i)作为下标检测是否为空&#x2F;命中。<br>对于平方探测法(quadratic probing)，课本里给的形式是通用的，可以理解为p(K,i)是二次函数，课本原话p(K,i)&#x3D;i^2是最简单平方探测法的例子。考的话应该会给p(K,i)的。（写代码用的话我是用正负i^2的）<br>（什么时候可能正负都要试，见下图：源自浙江大学MOOC数据结构的讲义）<br><img src="/2023/12/13/231216DataStructureRecovery02/011.png" alt="源自MOOC浙江大学数据结构课件"><br>（使用平方探测仍会产生二次聚集(secondary clustering)，大致就是h(x)一致，为解决这个缺憾引出了双散列(double hashing)）<br>3.注：删除时要设墓碑。（但对散列要求没这么高吧，不过掌握没坏事）</p>
<h2 id="六、索引"><a href="#六、索引" class="headerlink" title="六、索引"></a>六、索引</h2><p>1.2-3树<br>具体操作可以参考下面这篇文章<br><a href="https://blog.csdn.net/kexuanxiu1163/article/details/87887529">https://blog.csdn.net/kexuanxiu1163/article/details/87887529</a><br>2.B-树与B+树（区分：B+分别索引结点和叶子结点，所有数据都保存在叶子结点中）<br><a href="https://blog.csdn.net/u014453898/article/details/112469113">https://blog.csdn.net/u014453898/article/details/112469113</a></p>
<h2 id="七、排序"><a href="#七、排序" class="headerlink" title="七、排序"></a>七、排序</h2><p>（基本术语：内部排序Internal Sorting 给内存里的排序、外部排序External Sorting 给磁盘里的排序）<br>1.简单排序<br>冒泡排序、插入排序都稳定；选择排序不稳定<br>选择排序可以优化为堆排序(O(nlogn))，快速找到最小值。<br>2.Shellsort希尔排序<br><img src="/2023/12/13/231216DataStructureRecovery02/012.png" alt="源自MOOC浙江大学数据结构课件"><br><img src="/2023/12/13/231216DataStructureRecovery02/013.png" alt="源自MOOC浙江大学数据结构课件"><br>（有归并排序mergesort这个东西，二分法思想）<br>3.快速排序QuickSort<br><img src="/2023/12/13/231216DataStructureRecovery02/014.png" alt="源自MOOC浙江大学数据结构课件"><br><img src="/2023/12/13/231216DataStructureRecovery02/015.png" alt="源自MOOC浙江大学数据结构课件"><br>4.箱&#x2F;桶排序BinSort：很像哈希（散列）的开放定址法，都是空间换时间，T(N,M)&#x3D;O(M+N)<br>5.基排序RadixSort，次位优先主位优先<br><img src="/2023/12/13/231216DataStructureRecovery02/016.png" alt="源自MOOC浙江大学数据结构课件"><br><img src="/2023/12/13/231216DataStructureRecovery02/017.png" alt="源自MOOC浙江大学数据结构课件"></p>
]]></content>
      <categories>
        <category>major</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法练习测试</title>
    <url>/2024/01/06/240106makedowntest/</url>
    <content><![CDATA[<p>引用操作</p>
<blockquote>
<p>学习内容参考文章：<a href="http://t.csdnimg.cn/hj0lV">http://t.csdnimg.cn/hj0lV</a><br>数学公式部分参考文章：<a href="https://zhuanlan.zhihu.com/p/138532124">https://zhuanlan.zhihu.com/p/138532124</a></p>
</blockquote>
<p><del>任务：1.用所学知识完成下面内容的博文的排版</del><br>（vscode表示：你用快捷键怎么能不经过我的同意？参考文章所说的快捷键适用于github的在线编辑器）<br>功能        快捷键<br>加粗        Ctrl+B<br>斜体        Ctrl+I<br>引用        Ctrl+Q<br>插入链接    Ctrl+L<br>插入代码    Ctrl+K<br>插入图片    Ctrl+G<br>提升标题    Ctrl+H<br>有序列表    Ctrl+O<br>无序列表    Ctrl+U<br>横线        Ctrl+R<br>撤销        Ctrl+Z<br>重做        Ctrl+Y</p>
<p>斜体：  <em>test</em> <em>test</em><br>粗体：  <strong>test</strong><br>倾斜加粗：  <em><strong>test</strong></em><br>下划线：    <del>test</del></p>
<hr>
<p>分级标题</p>
<p>#一级标题<br>##二级标题<br>###三级标题<br>####四级标题<br>#####五级标题<br>######六级标题</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>链接：<br>插入本地图片链接<br><img src="/2024/01/06/240106makedowntest/" alt="图片描述"><br>hexo能够使用img标签，参数有src(链接地址)、alt(文本说明)、width height等属性<br><img src="/2024/01/06/240106makedowntest/001.png" width="50%" hegiht="auto"></p>
<p>超链接就用html的a标签咯，可以连接文件如pdf，扔文件夹里，跟图片差不多<br><a href="https://mys109hqj.github.io/">这是跳转到博客首页的链接</a><br><a href="https://mys109hqj.github.io/" title="博客首页">博客首页</a></p>
<video width="480" height="320" controls>
<source src="part01-02版修正.mp4">
</video>

<p>播放音频示例：使用标签audio controls标识表示控制播放暂停<br><audio controls><br>  <source src="002.wav"><br>  您的浏览器不支持 audio 元素。<br></audio><br><audio controls src="003.wav">您的浏览器不支持 audio 元素。</audio></p>
<p>要注意的是，如果你用html格式写，必须要紧邻，不能隔行。否则hexo转html时会自动分段，导致标签出错。<br>html制作弹出框（使用javascript）</p>
<blockquote>
<p>参考CSDN文章<a href="https://blog.csdn.net/qq_35727582/article/details/114868023">https://blog.csdn.net/qq_35727582/article/details/114868023</a></p>
</blockquote>
<head>

  <style>
  /* 遮罩层 */
  #overlay {
    position: fixed;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
    font-size: 16px;
    /* IE9以下不支持rgba模式 */
    background-color: rgba(0, 0, 0, 0.5);
    /* 兼容IE8及以下 */
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#7f000000,endColorstr=#7f000000);
    display: none;
  }
  /* 弹出框主体 */
  .popup {
    background-color: #ffffff;
    max-width: 400px;
    min-width: 200px;
    height: 240px;
    border-radius: 5px;
    margin: 100px auto;
    text-align: center;
  }
  /* 弹出框的标题 */
  .popup_title {
    height: 60px;
    line-height: 60px;
    border-bottom: solid 1px #cccccc;
  }
  /* 弹出框的内容 */
  .popup_content {
    height: 50px;
    line-height: 50px;
    padding: 15px 20px;
  }
  /* 弹出框的按钮栏 */
  .popup_btn {
    padding-bottom: 10px;
  }
  /* 弹出框的按钮 */
  .popup_btn button {
    color: #778899;
    width: 40%;
    height: 40px;
    cursor: pointer;
    border: solid 1px #cccccc;
    border-radius: 5px;
    margin: 5px 10px;
    color: #ffffff;
    background-color: #337ab7;
  }
  </style>
</head>
<body>
  <button id="showPopup" onclick="showPopup()">弹出</button>
  <div id="overlay">
    <div class="popup">
      <p class="popup_title">提示</p>
      <p class="popup_content">学会制作弹出框了吗？</p>
      <div class="popup_btn">
        <button class="cancelBtn" onclick="hidePopup()">取消</button>
        <button class="confirmBtn" onclick="hidePopup()">确认</button>
      </div>
    </div>
  </div>
<script>
  function showPopup(){
    var overlay = document.getElementById("overlay");
    overlay.style.display = "block";
  }
  function hidePopup(){
    var overlay = document.getElementById("overlay");
    overlay.style.display = "none";
  }
  </script>
</body>]]></content>
      <categories>
        <category>major</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>桌游|强盗兄弟burglebros</title>
    <url>/2024/01/17/240117burglebros/</url>
    <content><![CDATA[<p>基础教学推荐bga中的教程：</p>
<p>bga中的规则书链接：（Eng）<br><a href="https://tesera.ru/images/items/1085040/BBRuleBook[MarkIII-v2.02]-Spreads.pdf">https://tesera.ru/images/items/1085040/BBRuleBook[MarkIII-v2.02]-Spreads.pdf</a><br>Burgle Bros中文化卡表链接：（需要科学上网，繁体中文。包含角色能力介绍、事件event、赃物loot、工具tool的列表）<br><a href="https://gggjms.blogspot.com/2016/03/burgle-bros_30.html">https://gggjms.blogspot.com/2016/03/burgle-bros_30.html</a></p>
<p>选定起始点<br>开局时，你可以知道一层警卫的初始位置，并选定起始点位。<br>格子位置的名称列为用字母ABCD表示，即分布为：<br>A1 B1 C1 D1<br>A2 B2 ……<br><img src="/2024/01/17/240117burglebros/001.png" alt="行列展示"></p>
<p>注：行列指示物展示打开方式<br><img src="/2024/01/17/240117burglebros/002.png" alt="行列指示物展示打开方式"></p>
<p>在玩家的第一回合，该玩家的角色出现到板块中。起始点位尽量现在路径开阔的地方。</p>
<p>警卫的寻路逻辑为：<br>目的地为巡逻卡的终点板块，如果有警报则终点改为警报位置，若有多个警报，永远先前往最近的警报，若出现等距离则由玩家选择警卫先查看的警报。<br>永远寻找最短路径。如果有多条等长最短路径，则从左侧开始，选择最顺时针的路径。<br>（原文：The Guard always takes the shortest possible path to the destination. If more than one path is equally short, the Guard takes the path that is the most clockwise, starting from the Guard’s left）<br>一层的警卫初始为2动、二层3动、三层4动；巡逻牌耗尽重洗时基础移动速度加一，如一层警卫在一层巡逻卡耗尽重洗后变为3动。基础移动速度上限为6，速度为几则一次行动有几动。1动可以移动一个板块。若该层有警报，则在警卫原有速度基础上，每有一个警报增加1动。</p>
<p>角色的个人技能：（以bga无进阶版本）<br>鹰眼：每轮可以免费查看一个相邻的隔墙板块。（探图神技）<br><img src="/2024/01/17/240117burglebros/THE_HAWK.png" alt="侦察专家 鹰眼 THE_HAWK"><br>渡鸦：可以在两步距离内放置一个乌鸦，警卫经过该格时多消耗一个步数。放置乌鸦的操作免费，如果不移动乌鸦乌鸦将在格子停留。注意：若乌鸦与警卫起点在同一格，警卫离开该格时乌鸦不起作用。若再次经过正常起作用。（控警卫技能）<br><img src="/2024/01/17/240117burglebros/THE_RAVEN.png" alt="渡鸦 THE_RAVEN"><br>观察者：可以花费一个行动点，查看本层警卫的下一张巡逻终点牌，并选择是否将其放到牌堆底部。（控警卫技能）<br><img src="/2024/01/17/240117burglebros/THE_SPOTTER.png" alt="观察者 THE_SPOTTER"><br>杂技演员：可以免费移动到一步内的警卫所在格，此操作不扣除隐秘标记。但是如果回合结束仍在警卫所在格，仍然正常扣除隐秘标记。（跑图神技）<br><img src="/2024/01/17/240117burglebros/THE_ACROBAT.png" alt="杂技演员 THE_ACROBAT"><br>主谋（骗子）：每回合可以花费一点行动，使一个同伴移动一格。移动仍要遵循基本规则，但（移动到激光检测与门栓时）不用耗费额外点数。（跑图技能）<br><img src="/2024/01/17/240117burglebros/THE_ROOK.png" alt="骗子 THE_ROOK"><br>小偷：在自己开保险箱或者数字门锁时可以多一个骰子。（更容易完成骰子检定）<br><img src="/2024/01/17/240117burglebros/THE_PETERMAN.png" alt="小偷 THE_PETERMAN"><br>钻机安装员：开始持有炸药（可以炸毁相邻墙壁，并在所在格发出警报）。所有玩家获得道具时可以查看两个道具之后保留一个（原本是直接抽一个）。（提供道具上的优势）<br><img src="/2024/01/17/240117burglebros/THE_RIGGER.png" alt="钻机安装员 THE_RIGGER"><br>照明专家：可以免费在相邻格制造一个警报。（控警卫技能）<br><img src="/2024/01/17/240117burglebros/THE_JUICER.png" alt="照明专家 THE_JUICER"><br>黑客：不会触发指纹、激光、动作检测警报（热感应警报与物品检测器仍正常触发），队友不会在自己所在格触发警报。<br><img src="/2024/01/17/240117burglebros/THE_HACKER.png" alt="黑客 THE_HACKER"></p>
<p>玩家在自己的回合内可以选择执行以下行动：<br>一般情况下，玩家有4动。可以选择花1动偷看相邻板块（不能隔墙看）；花1动移动到相邻板块（并进行进入板块的相关判定）；使用角色技能；免费使用道具卡（tool）；在保险箱（safe）板块花1动掷骰子或2动增加骰子；在机房板块进行黑客行动获取相应骇客标记。<br>在玩家的行动回合结束后，进行事件判定。当该轮玩家只使用2动及以下时，触发事件（持有赃物邮票stamp时是3动及以下都会触发事件）。抽取事件卡。之后移动角色结束时所在楼层的警卫。</p>
<p>接下来是各个房间介绍：<br>黄色卡牌：<br>ATRIUM 中庭<br>在中庭板块，可以偷看上一层或下一层相同位置的板块。但同时可以被上一层或下一层的警卫走到对应板块发现。<br>FOYER 门厅</p>
<blockquote>
<p>foyer : a large open area just inside the entrance of a public building such as a theatre or a hotel, where people can wait and meet each other（剧院、宾馆等公共建筑物入口处内的）门厅</p>
</blockquote>
<p>如果你在门厅板块，警卫可以从相邻板块发现你。若警卫在同一轮次从相邻板块移动到门厅，视为再次被发现，再次扣除一个隐匿标记。</p>
<table rules="none" align="center">
    <tr>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/atrium.png" width="60%">
                <br>
                <font color="AAAAAA">atrium</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/foyer.png" width="60%">
                <br>
                <font color="AAAAAA">foyer</font>
            </center>
        </td>
    </tr>
</table>

<p>蓝色卡牌：<br>LABORATORY 实验室<br>当板块被发现时，在板块上放置一个道具标记。第一个到达该板块的角色抽取一张道具牌。<br>LAVATORY 公共厕所<br>板块上初始有三个隐匿标记。角色在这个板块上被发现时，消耗板块上的标记。（道具：烟雾弹的效果同理）<br>WALKWAY 过道<br>如果该板块没被提前偷看，而是在行动中被揭示，则角色往下摔落一层。（若已经在最底层则无事发生）摔落到下面一层不视作正常进入板块，不进行进入板块的相关判定（不会触发警报，若该板块有警卫也不会丢失隐匿标记）。 另外，角色可以通过这个板块单向向下移动（只能从上往下，特定“事件”下能够双向）。</p>
<table rules="none" align="center">
    <tr>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/laboratory.png" width="60%">
                <br>
                <font color="AAAAAA">laboratory</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/lavatory.png" width="60%">
                <br>
                <font color="AAAAAA">lavatory</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/walkway.png" width="60%">
                <br>
                <font color="AAAAAA">walkway</font>
            </center>
        </td>
    </tr>
</table>

<p>棕色卡牌：<br>SECRET DOOR 秘密通道<br>在相邻板块，可以越过墙移动到该板块内。注意只能单向移动。警卫不能通过秘密通道移动。<br>SERVICE DUCT 服务&#x2F;维修管道<br>在两个服务管道板块都被发现后，在该板块上可以花费一点行动移动到管道的另一端（即另一个服务管道板块上）。<br>若携带赃物：名画，携带的玩家无法使用上述两个板块的功能。</p>
<table rules="none" align="center">
    <tr>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/secret_door.png" width="60%">
                <br>
                <font color="AAAAAA">secret_door</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/service_duct.png" width="60%">
                <br>
                <font color="AAAAAA">service_duct</font>
            </center>
        </td>
    </tr>
</table>

<p>警报类卡牌：<br>CAMERA 摄像机<br>若建筑中有警卫在任一摄像机板块，角色进入摄像机板块将触发警报。<br>DETECTOR 探测器<br>携带道具或脏物(loot)时进入板块会触发警报<br>THERMO 热感应器<br>如果回合结束停留在这一板块，触发警报。（持有赃物“同位素”时只要经过就会触发警报）<br>FINGERPRINT 指纹检测 （有对应机房）<br>进入就会触发警报。可使用一个在机房进行黑客行动获得的骇客标记来取消这次警报。<br>LASER 激光检测<br>进入（1动）需要另外花费一动才能不触发警报。可以选择不消耗额外行动，直接触发警报；或使用黑客标记。<br>MOTION 运动检测<br>移入该板块后，若在该回合移动出此板块，触发警报。可以使用黑客标记；也可以通过下一回合再移动躲避警报。<br>注意，如果有触发警报，该层警卫的巡逻终点会立即改为警报点（警报详细介绍见上文），当前的巡逻地点卡会被废除。在适当时机触发警报也许可以营救队友于水火之中。</p>
<table rules="none" align="center">
    <tr>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/camera.png" width="60%">
                <br>
                <font color="AAAAAA">camera</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/detector.png" width="60%">
                <br>
                <font color="AAAAAA">detector</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/thermo.png" width="60%">
                <br>
                <font color="AAAAAA">thermo</font>
            </center>
        </td>
                <td>
            <center>
                <img src="/2024/01/17/240117burglebros/fingerprint.png" width="60%">
                <br>
                <font color="AAAAAA">fingerprint</font>
            </center>
        </td>
                <td>
            <center>
                <img src="/2024/01/17/240117burglebros/laser.png" width="60%">
                <br>
                <font color="AAAAAA">laser</font>
            </center>
        </td>
                <td>
            <center>
                <img src="/2024/01/17/240117burglebros/motion.png" width="60%">
                <br>
                <font color="AAAAAA">motion</font>
            </center>
        </td>
    </tr>
</table>
对应机房：
可以在对应机房中消耗一动获取一个对应骇客标记。注意三种标记与三种警报类型一一对应。
（标记：可以在触发对应类型警报时选择消耗一个标记，取消这次警报）
<table rules="none" align="center">
    <tr>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/hack_fingerprint.png" width="60%">
                <br>
                <font color="AAAAAA">hack_fingerprint</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/hack_laser.png" width="60%">
                <br>
                <font color="AAAAAA">hack_laser</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/hack_motion.png" width="60%">
                <br>
                <font color="AAAAAA">hack_motion</font>
            </center>
        </td>
    </tr>
</table>

<p>楼梯与保险箱：<br>STAIRS 楼梯<br>通过该板块可以上楼。从楼上对应板块也能下楼。上楼视为进入上面一层的对应板块。在顶层时，当团队收集完赃物后（必须都在身上），可以通过楼梯逃脱（逃脱同样消耗一动）。<br>SAFE 保险箱<br>一动投骰子，两动加骰子。所处行列的房间（需要被揭示）右下角对应的数字都被摇出过一次后才能打开保险箱，获得一个道具卡（tool）和一个有特殊效果的赃物（loot）。</p>
<table rules="none" align="center">
    <tr>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/stairs.png" width="60%">
                <br>
                <font color="AAAAAA">stairs</font>
            </center>
        </td>
        <td>
            <center>
                <img src="/2024/01/17/240117burglebros/safe.png" width="60%">
                <br>
                <font color="AAAAAA">safe</font>
            </center>
        </td>
    </tr>
</table>

<blockquote>
<p>赃物列表<br><a href="https://gggjms.blogspot.com/2016/03/burgle-bros-loot.html">https://gggjms.blogspot.com/2016/03/burgle-bros-loot.html</a><br><img src="/2024/01/17/240117burglebros/loot.png" height="30%"><br>工具列表<br><a href="https://gggjms.blogspot.com/2016/03/tool-event-loot-tool-blueprints-crowbar.html">https://gggjms.blogspot.com/2016/03/tool-event-loot-tool-blueprints-crowbar.html</a><br><img src="/2024/01/17/240117burglebros/tool.png" height="30%"><br>事件列表<br><a href="https://gggjms.blogspot.com/2016/03/burgle-bros_30.html">https://gggjms.blogspot.com/2016/03/burgle-bros_30.html</a><br><img src="/2024/01/17/240117burglebros/event.png" height="30%"></p>
</blockquote>
]]></content>
      <categories>
        <category>game</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>短时轻策桌游推荐|Faraway： 介绍/教程</title>
    <url>/2024/02/07/240207faraway/</url>
    <content><![CDATA[<h2 id="Faraway游戏介绍"><a href="#Faraway游戏介绍" class="headerlink" title="Faraway游戏介绍"></a>Faraway游戏介绍</h2><h3 id="游戏简介"><a href="#游戏简介" class="headerlink" title="游戏简介"></a>游戏简介</h3><p>Faraway是2023年新上线的桌游，是一款<strong>轻度策略</strong>的，<strong>支持2-6人游玩</strong>的桌游。玩家一同前往阿鲁拉岛屿，争取在岛民中取得更多的名誉。<strong>游戏时长2-3人时5-15分钟，人数多时20-30分钟</strong>。<br>这个桌游<strong>“顺序放置——逆向结算”的基本玩法</strong>十分新颖；游戏过程中需要在<strong>保持数字顺序、满足居民的计分条件与区域卡牌的优先选择权</strong>三者相互制衡。<br>在了解基本的计分规则后，新手也能打出一定的combo，很好上手；对于老手，不同组合、追求分数上限也让这个游戏有可玩性和重开性。<br><strong>游戏有一定运气成分</strong>，<strong>在3人及以上的游戏中选牌的交涉尤为突出</strong>，线下玩也有追求合作共赢的空间。<br>线下玩这个游戏有个缺点，就是计分极其繁琐，线上网站结算阶段“公开处刑”，简化了繁琐的计分过程。</p>
<p>bga上游戏链接：<a href="https://boardgamearena.com/gamepanel?game=faraway">https://boardgamearena.com/gamepanel?game=faraway</a><br>注：bga为免费在线桌游平台，注册时别用qq邮箱就行。</p>
<p>下面部分是自拟图文教程，以及其它教程的参考链接</p>
<h3 id="基础教程部分"><a href="#基础教程部分" class="headerlink" title="基础教程部分"></a>基础教程部分</h3><p>（本部分结尾有规则书pdf；内容结构为：游戏设定补充、图文教程、其它教程链接）<br><strong>游戏设定补充：</strong>（参照规则书Page1-2）<br>ALULA（阿鲁拉）的岛屿位置可以任意变化，使得任何行动路线都有可能。探索的方式只有行走。<br>这里的岛民有些说原住民，有些是定居的探索者。他们各自独立看守一个岛屿，他们热情招待到来的探索者，并且喜欢谈论有关Uddu（矿产资源，即蓝色标志），Okiko（动物，即红色标志），Goldlog（植物，即绿色标志）的最新发现。（因此获得名誉值的条件会和返回路上岛屿上的这些标志内容有关。）<br>阿鲁拉有四种生物群系：河流（红色区域）、城市（黄色区域）、森林（红色区域）、(岩石)沙漠（蓝色区域）。每个生物群系都有自己独特的季节规律。<strong>（因此获得名誉值的条件会和返回路上的岛屿的生物群系有关。）</strong></p>
<img src="/2024/02/07/240207faraway/001.png" width="50%" hegiht="auto">
<img src="/2024/02/07/240207faraway/002.png" width="50%" hegiht="auto">
<img src="/2024/02/07/240207faraway/003.png" width="50%" hegiht="auto">
<img src="/2024/02/07/240207faraway/004.png" width="50%" hegiht="auto">
<img src="/2024/02/07/240207faraway/005.png" width="50%" hegiht="auto">
<img src="/2024/02/07/240207faraway/006.png" width="50%" hegiht="auto">
<img src="/2024/02/07/240207faraway/007.png" width="50%" hegiht="auto">
<img src="/2024/02/07/240207faraway/008.png" width="50%" hegiht="auto">

<p><strong>这个游戏也有进阶选项，开局每位玩家分别分到5张区域牌，每位玩家自由进行5选3，即放弃两张区域牌。被放弃的区域牌洗回区域牌堆中。熟悉游戏基本机制后建议启用，可以提升游戏体验。</strong></p>
<p>其它的中文教程推荐：<br>视频教程：（b站）<br><a href="https://www.bilibili.com/video/BV1694y1h7Yp">https://www.bilibili.com/video/BV1694y1h7Yp</a><br>图文教程：（b站）<br><a href="https://www.bilibili.com/read/cv27286594/">https://www.bilibili.com/read/cv27286594/</a><br>规则书链接：<br><a href="Faraway-rules-EN.pdf">规则书(en)pdf</a></p>
<h3 id="个人向Faraway进阶部分（附区域-圣殿图片集）"><a href="#个人向Faraway进阶部分（附区域-圣殿图片集）" class="headerlink" title="个人向Faraway进阶部分（附区域&#x2F;圣殿图片集）"></a>个人向Faraway进阶部分（附区域&#x2F;圣殿图片集）</h3><h4 id="个人游戏理解"><a href="#个人游戏理解" class="headerlink" title="个人游戏理解"></a>个人游戏理解</h4><p><strong>在2人对局中，选牌阶段的干扰相对较少</strong>（毕竟是总数N+1，N个人选，2人也是理论干扰最小的），很容易拿到自己想要的牌。经常出现每有干扰的局面。游戏也进行地非常迅速，可以把它称为“自由刷分”的局面，无疑容易出现高分对决的情景。<br>但要是涉及到对抗，那就有“长考”（较长地思考）了:);<br><strong>人数越多，对抗越激烈，你也更有可能没法拿到想要的牌。在这时候小数字先拿牌的优势就体现出来了</strong><br><img src="/2024/02/07/240207faraway/009.png" alt="自由刷分示例" width="50%" hegiht="auto"><br><strong>保持区域卡数字的升序，可以拿到尽可能多的圣殿卡</strong>，圣殿卡可以提供额外资源（即三色标志、线索）与区域（四色+夜晚），提供额外的计分项目。足够数量的圣殿卡能让你取得更高的分数。<br><img src="/2024/02/07/240207faraway/010理论升序.png" alt="升序数字理论" width="50%" height="auto"><br><strong>起手牌数字小并</strong>且<strong>得分条件有一定上限</strong>，<strong>数字小又可以优先选牌</strong>。不过“理论升序”拿满7张圣殿牌也得有一定运气了。<br><img src="/2024/02/07/240207faraway/011起手大牌升序.png" alt="大牌起手理论上限" width="50%" height="auto"><br>虽然<strong>理论上限高</strong>，但<strong>风险在于圣殿不刷植物（需要的标志）与对手的争夺（数字太大了，多人游戏最后选牌，想要的经常被选走）</strong>。在这个例子中如果别人不跟你抢，植物（绿标志）刷的适中，就可以打出效果。（<strong>风险就是（绿标志）原本就少还刷的少+被对手针对抢牌；居民的要求迟迟不能满足时就得考虑保下限了</strong>）</p>
<h4 id="区域-圣殿图片集"><a href="#区域-圣殿图片集" class="headerlink" title="区域&#x2F;圣殿图片集"></a>区域&#x2F;圣殿图片集</h4><blockquote>
<p>图片来源链接:<a href="https://imgur.com/paAf8ih">https://imgur.com/paAf8ih</a>与<a href="https://imgur.com/KOvyJSP">https://imgur.com/KOvyJSP</a>（需要科学上网访问）<br><img src="/2024/02/07/240207faraway/place.jpeg" alt="区域卡牌集合"><br><img src="/2024/02/07/240207faraway/shelter.jpeg" alt="圣殿卡牌集合"><br>68张区域卡中，一共只有10个绿标志（植物），14个红标志（动物），18个蓝标志（矿产），18条线索，数字20-40是夜晚；46张圣殿卡中，一共只有5个绿标志（植物），6个红标志（动物），9个蓝标志（矿产），8条线索，4张夜晚。<br>至于板块颜色（景观&#x2F;生物群系）方面，颜色分布均匀，区域卡中四色各17张，圣殿卡中四色各5张。<br>由此可以建立对游戏更深的、定量的认识。与朋友一同游玩时一起参考集合图片也未尝不可。</p>
</blockquote>
]]></content>
      <categories>
        <category>game</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找相同图案——本地对战版 | Find same patterns</title>
    <url>/2024/02/26/240226Find-same-patterns/</url>
    <content><![CDATA[<p>2403021056更新版本<br>注：已知问题:关闭各窗口后0-5秒后才完全关闭，在此期间窗口覆盖部分可能暂时无法点击<br>设置可以调卡牌正面显示时间与难度；切换难度自动重新开始游戏。</p>
<script type="text/javascript">
function SetCwinHeight(){
  var iframeid = document.getElementById("iframeid"); //iframe id
  if (document.getElementById) {
    if (iframeid && !window.opera) {
      if (iframeid.contentDocument && iframeid.contentDocument.body.offsetHeight) {
        iframeid.height = iframeid.contentDocument.body.offsetHeight + 50;
      } else if (iframeid.Document && iframeid.Document.body.scrollHeight) {
        iframeid.height = iframeid.Document.body.scrollHeight + 50;
      }
    }
  }
}
</script>

<iframe width="100%" id="iframeid" onload="Javascript:SetCwinHeight()" scrolling="yes" height="1300" frameborder="0" src=".\Find_same_patterns.html"></iframe>
]]></content>
      <categories>
        <category>game</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>依据信息视频的抢答游戏 | responder game</title>
    <url>/2024/02/14/240214responder-game/</url>
    <content><![CDATA[<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        .image-container {
            width: 240px; /* 设置图片容器宽度 */
            height: 320px; /* 设置图片容器高度 */
            overflow: hidden; /* 隐藏溢出部分 */
        }
        .image-container img {
            width: 240px; /* 设置图片宽度为容器宽度 */
            height: 320px; /* 设置图片高度为容器高度 */
            object-fit: fill; /* 填充满容器，不保持宽高比 */
            object-position: center; /* 图片居中 */
        }
          /* 遮罩层 */
  .overlay {
    position: fixed;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
    font-size: 16px;
    /* IE9以下不支持rgba模式 */
    background-color: rgba(0, 0, 0, 0.5);
    /* 兼容IE8及以下 */
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#7f000000,endColorstr=#7f000000);
    display: none;
  }
  /* 弹出框主体 */
  .popup {
    background-color: #ffffff;
    max-width: 80%;
    min-width: 50%;
    height: auto;
    border-radius: 5px;
    margin: 100px auto;
    text-align: center;
  }
  /* 弹出框的标题 */
  .popup_title {
    height: 60px;
    line-height: 60px;
    border-bottom: solid 1px #cccccc;
  }
  /* 弹出框的内容 */
  .popup_content {
    height: 80%;
    line-height: 50px;
    padding: 15px 20px;
  }
  /* 弹出框的按钮栏 */
  .popup_btn {
    padding-bottom: 10px;
  }
  /* 弹出框的按钮 */
  .popup_btn button {
    color: #778899;
    width: 40%;
    height: 40px;
    cursor: pointer;
    border: solid 1px #cccccc;
    border-radius: 5px;
    margin: 5px 10px;
    color: #ffffff;
    background-color: #337ab7;
  }
  </style>
</head>
<body>
  抢答游戏<br>
  注：点击每道题的音频开始计时，按下选项按钮停止计时；点击查看答案按钮后该题数据会汇总到最后的表格。<br>
  一旦按下按钮，即锁定答案，同时时间也会暂停，该组按钮也不能再次使用。请慎重选择按下按钮的时机。完成游戏后可以分享汇总表格。（实在误触，刷新后按钮会重置，做过的题点查看答案可以恢复记录；但你重做可能题目的记录就会重置）<button onclick="clearLocalStorage()">清除记录</button>清除记录按钮就是清除缓存从而清除时间记录<br>
    <p>游戏规则：
      这里有十一张有关恐怖游戏的海报，以及为它们作出的歌词，但是它们被弄混了。
      首先，你会看一段视频，接着回答八道题目。每一道题目都会三张备选的游戏海报，
      你必须找出所听到的歌词描述的那张海报。一旦你确定答案，立刻进行抢答，
      最快答对的玩家可以获得一分，累计分数最高的玩家获胜。
      但是请注意，对于特定的游戏海报，为其而作出的曲子未必只有一首。
      在此之前，我会展示主题为“恐怖游戏的冰山一角”的短片，
      它将介绍所有海报上的游戏。</p><br>
      短片及海报栏：<br>
<iframe src="//player.bilibili.com/player.html?aid=1051059492&bvid=BV1EH4y177DN&cid=1450590252&p=1" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"> </iframe>
            <table>
                <tr>
                    <td><img src="/2024/02/14/240214responder-game/002Amnesia.jpg" alt="Amnesia" height="320" width="240"></td>
                    <td><img src="/2024/02/14/240214responder-game/003FNAF02.jpg" alt="FNAF" height="320" width="240"> </td>
                    <td><img src="/2024/02/14/240214responder-game/004Outlast.jpg" alt="Outlast" height="320px" width="240px"></td>
                    <td><img src="/2024/02/14/240214responder-game/005the last of us.jpeg" alt="The Last Of Us" height="320" width="240"></td>
                </tr>
                <tr>
                    <td><img src="/2024/02/14/240214responder-game/007bioshock.jpg" alt="Bioshock" height="320px" width="240px"></td>
                    <td><img src="/2024/02/14/240214responder-game/008slient hill.jpg" alt="Slient Hill" height="320px" width="240px"></td>
                    <td><img src="/2024/02/14/240214responder-game/009heavy rain.jpg" alt="Heavy Rain" height="320px" width="240px"></td>
                    <td><img src="/2024/02/14/240214responder-game/010earth bound.jpg" alt="Earth Bound" height="320px" width="240px"></td>
                </tr>
                <tr>
                    <td><img src="/2024/02/14/240214responder-game/011Majora's mask.jpg" alt="Majora's Mask" height="320px" width="240px"></td>
                    <td><img src="/2024/02/14/240214responder-game/012UntilDawn.jpg" alt="UntilDawn" height="320px" width="240px"></td>
                    <td><img src="/2024/02/14/240214responder-game/013dying light.jpg" alt="Dying Light" height="320px" width="240px"></td>
                    <td></td>
                </tr>
            </table>
    <br>
    Q1:
    <audio controls>
      <source src="012.wav">
      您的浏览器不支持 audio 元素。
    </audio><br>
    <table>
      <tr class="image-container">
        <td><img src="/2024/02/14/240214responder-game/012UntilDawn.jpg" alt width="30%"></td>
        <td><img src="/2024/02/14/240214responder-game/008slient hill.jpg" alt width="30%"></td>
        <td><img src="/2024/02/14/240214responder-game/003FNAF02.jpg" alt width="30%"></td>
      </tr>
      <tr>
        <td><button class="Q1" onclick="selectOption('Q1', 'A')">A</button></td>
        <td><button class="Q1" onclick="selectOption('Q1', 'B')">B</button></td>
        <td><button class="Q1" onclick="selectOption('Q1', 'C')">C</button></td>
      </tr>
    </table>
    <button id="showPopup1" onclick="showPopup('popup1');showSelection('Q1')">查看答案1</button>
    <br>
    <div id="overlay1" class="overlay">
      <div id="popup1" class="popup">
        <p class="popup_title">歌词原文及答案</p>
        <p class="popup_content" align="left">
          <img src="/2024/02/14/240214responder-game/012UntilDawn.jpg" alt="UntilDawn" align="right" width="30%">
        Story and atmosphere, 80s serial killer's reign,<br>
        College kids on a mountain, where dangers remain,<br><br>
        Survive or die trying, their fate intertwines,<br>
        On this vacation, terror creeps and confines.<br><br>
        Decisions weigh heavy, escape death's might,<br>
        Survival's uncertain, in the face of the night.<br><br>
        In this gripping tale, life hangs by a thread,<br>
        Until the dawn breaks, hope clings to their breath.<br><br>
        <div id="answerQ1"></div>
        <div>正确答案是：A</div>
        <div id="timerQ1"></div>
</p>
        <div class="popup_btn">
          <button class="confirmBtn" onclick="hidePopup('popup1')">确认</button>
        </div>
      </div>
    </div>
  <br>
    Q2:
    <audio controls>
      <source src="004.wav">
      您的浏览器不支持 audio 元素。
    </audio>
    <table>
      <tr class="image-container">
        <td><img src="/2024/02/14/240214responder-game/011Majora's mask.jpg" alt width="30%"></td>
        <td><img src="/2024/02/14/240214responder-game/005the last of us.jpeg" alt width="30%"></td>
        <td><img src="/2024/02/14/240214responder-game/004Outlast.jpg" alt width="30%"></td>
      </tr>
      <tr>
          <td><button class="Q2" onclick="selectOption('Q2', 'A')">A</button></td>
          <td><button class="Q2" onclick="selectOption('Q2', 'B')">B</button></td>
          <td><button class="Q2" onclick="selectOption('Q2', 'C')">C</button></td>
        
      </tr>
    </table>
    <br>
    <div id="overlay2" class="overlay">
      <div id="popup2" class="popup">
        <p class="popup_title">歌词原文及答案</p>
        <p class="popup_content" align="left">
          <img src="/2024/02/14/240214responder-game/004Outlast.jpg" alt="Outlast" align="right" width="30%">
          No way to fight, just helpless prey,<br>
          Facing the attacker, at the end of each day.<br><br>
          Investigate through pages, journal unfolds,<br>
          Mental hospital's secrets, stories untold,<br><br>
          Another journey, to find his lost wife,<br>
          Surviving the madness, an unyielding strife.<br><br>
          A new trial awaits, escape is the aim,<br>
          Outlast's sequel, a test of survival's flame.<br><br> 
          <div id="answerQ2"></div>
          <div>正确答案是：C</div>
          <div id="timerQ2"></div>
</p>
        <div class="popup_btn">
          <button class="confirmBtn" onclick="hidePopup('popup2')">确认</button>
        </div>
      </div>
    </div>
    <button id="showPopup2" onclick="showPopup('popup2');showSelection('Q2')">查看答案2</button>
<br>
Q3:
<audio controls>
  <source src="010.wav">
  您的浏览器不支持 audio 元素。
</audio><br>
<table>
  <tr class="image-container">
    <td><img src="/2024/02/14/240214responder-game/013dying light.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/010earth bound.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/002Amnesia.jpg" alt width="30%"></td>
  </tr>
  <tr>
    <td><button class="Q3" onclick="selectOption('Q3', 'A')">A</button></td>
    <td><button class="Q3" onclick="selectOption('Q3', 'B')">B</button></td>
    <td><button class="Q3" onclick="selectOption('Q3', 'C')">C</button></td>
  </tr>
</table>
<br>
<div id="overlay3" class="overlay">
  <div id="popup3" class="popup">
    <p class="popup_title">歌词原文及答案</p>
    <p class="popup_content" align="left">
      <img src="/2024/02/14/240214responder-game/010earth bound.jpg" alt="Earth Bound" align="right" width="30%">
    A classic RPG tale, a journey begins,<br>
    Unveiling a world where darkness and light thins,<br><br>
    From childhood's torment, a masterpiece arose,<br>
    Inspiring countless games, where fear overflows,<br><br>
    In a wrong turn theater, a scene so raw,<br>
    Bloody horror's grip, an unsettling awe.<br><br>
    In a world unknown, darkness sends its signs,<br>
     Final boss Giygas, Earthbound's epic final binds.<br><br>
     <div id="answerQ3"></div>
     <div>正确答案是：B</div>
     <div id="timerQ3"></div>
</p>
    <div class="popup_btn">
      <button class="confirmBtn" onclick="hidePopup('popup3')">确认</button>
    </div>
  </div>
</div>
<button id="showPopup3" onclick="showPopup('popup3');showSelection('Q3')">查看答案3</button>
<br>
<br>
Q4:
<audio controls>
  <source src="007.wav">
  您的浏览器不支持 audio 元素。
</audio><br>
<table>
  <tr class="image-container">
    <td><img src="/2024/02/14/240214responder-game/009heavy rain.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/008slient hill.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/007bioshock.jpg" alt width="30%"></td>
  </tr>
  <tr>
    <td><button class="Q4" onclick="selectOption('Q4', 'A')">A</button></td>
    <td><button class="Q4" onclick="selectOption('Q4', 'B')">B</button></td>
    <td><button class="Q4" onclick="selectOption('Q4', 'C')">C</button></td>
  </tr>
</table>
<br>
<div id="overlay4" class="overlay">
  <div id="popup4" class="popup">
    <p class="popup_title">歌词原文及答案</p>
    <p class="popup_content" align="left">
      <img src="/2024/02/14/240214responder-game/007bioshock.jpg" alt="Bioshock" align="right" width="30%">
      Jack on a plane, crashes through ocean tide,<br>
      Lost in the waves, secrets stirring inside,<br><br>
      Plasmids empower, superhuman might prevails,<br>
      In this underwater city, an epic tale unveils.<br><br>
      Little sisters, Big daddies, a haunting scene,<br>
      Survival in Rapture, where nightmares convene.<br><br>
      In this subaquatic world, darkness takes its toll,<br>
      Bioshock's legend, forever etched in soul.<br><br>
     <div id="answerQ4"></div>
     <div>正确答案是：C</div>
     <div id="timerQ4"></div>
</p>
    <div class="popup_btn">
      <button class="confirmBtn" onclick="hidePopup('popup4')">确认</button>
    </div>
  </div>
</div>
<button id="showPopup4" onclick="showPopup('popup4');showSelection('Q4')">查看答案4</button>
<br>
<br>
Q5:
<audio controls>
  <source src="008.wav">
  您的浏览器不支持 audio 元素。
</audio><br>
<table>
  <tr class="image-container">
    <td><img src="/2024/02/14/240214responder-game/008slient hill.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/004Outlast.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/013dying light.jpg" alt width="30%"></td>
  </tr>
  <tr>
    <td><button class="Q5" onclick="selectOption('Q5', 'A')">A</button></td>
    <td><button class="Q5" onclick="selectOption('Q5', 'B')">B</button></td>
    <td><button class="Q5" onclick="selectOption('Q5', 'C')">C</button></td>
  </tr>
</table>
<br>
<div id="overlay5" class="overlay">
  <div id="popup5" class="popup">
    <p class="popup_title">歌词原文及答案</p>
    <p class="popup_content" align="left">
      <img src="/2024/02/14/240214responder-game/008slient hill.jpg" alt="Slient Hill" align="right" width="30%">
      Here come an iconic survival series,<br>
      Where psychological horror pierces and freezes,<br><br>
      Enter the second game, a journey through despair,<br>
      Depression and frustration, emotions laid bare,<br><br>
      Pyramid Head, an iconic figure emerges,<br>
      Symbolic of guilt, torment never purges,<br><br>
      Surviving the psychological abyss, we remain,<br>
      Forever gripped by Silent Hill's chilling reign.<br><br>
     <div id="answerQ5"></div>
     <div>正确答案是：A</div>
     <div id="timerQ5"></div>
</p>
    <div class="popup_btn">
      <button class="confirmBtn" onclick="hidePopup('popup5')">确认</button>
    </div>
  </div>
</div>
<button id="showPopup5" onclick="showPopup('popup5');showSelection('Q5')">查看答案5</button>
<br>
<br>
Q6:
<audio controls>
  <source src="005.wav">
  您的浏览器不支持 audio 元素。
</audio><br>
<table>
  <tr class="image-container">
    <td><img src="/2024/02/14/240214responder-game/005the last of us.jpeg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/013dying light.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/012UntilDawn.jpg" alt width="30%"></td>
  </tr>
  <tr>
    <td><button class="Q6" onclick="selectOption('Q6', 'A')">A</button></td>
    <td><button class="Q6" onclick="selectOption('Q6', 'B')">B</button></td>
    <td><button class="Q6" onclick="selectOption('Q6', 'C')">C</button></td>
  </tr>
</table>
<br>
<div id="overlay6" class="overlay">
  <div id="popup6" class="popup">
    <p class="popup_title">歌词原文及答案</p>
    <p class="popup_content" align="left">
      <img src="/2024/02/14/240214responder-game/005the last of us.jpeg" alt="The Last Of Us" align="right" width="30%">
      A fungus-born plague, infecting all around,<br>
      Survival is the game, in this post-apocalyptic ground.<br><br>
      Zombie apocalypse, relentless storm,<br>
      Joel and Ellie, thriving through reform.<br><br>
      Fungal parasitism, darkness takes hold,<br>
      Their legacy unfolds, as stories are retold.<br><br>
      Game reset, a version anew,<br>
      The Last of Us, reborn for me and you.<br><br>
     <div id="answerQ6"></div>
     <div>正确答案是：A</div>
     <div id="timerQ6"></div>
</p>
    <div class="popup_btn">
      <button class="confirmBtn" onclick="hidePopup('popup6')">确认</button>
    </div>
  </div>
</div>
<button id="showPopup6" onclick="showPopup('popup6');showSelection('Q6')">查看答案6</button>
<br>
<br>
Q7:
<audio controls>
  <source src="003.wav">
  您的浏览器不支持 audio 元素。
</audio><br>
<table>
  <tr class="image-container">
    <td><img src="/2024/02/14/240214responder-game/003FNAF02.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/007bioshock.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/011Majora's mask.jpg" alt width="30%"></td>
  </tr>
  <tr>
    <td><button class="Q7" onclick="selectOption('Q7', 'A')">A</button></td>
    <td><button class="Q7" onclick="selectOption('Q7', 'B')">B</button></td>
    <td><button class="Q7" onclick="selectOption('Q7', 'C')">C</button></td>
  </tr>
</table>
<br>
<div id="overlay7" class="overlay">
  <div id="popup7" class="popup">
    <p class="popup_title">歌词原文及答案</p>
    <p class="popup_content" align="left">
      <img src="/2024/02/14/240214responder-game/003FNAF02.jpg" alt="Five Nights At Freddy's" align="right" width="30%">
      Scott Cawthon's fright, a hop takes flight,<br>
      Previous game characters, reborn in fright.<br><br>
      Jump scares in pizzeria, dread fills the air,<br>
      From zero to six, scares beyond compare.<br><br>
      Locked in the pizzeria, cameras reveal,<br>
      Freddy, Chica, Foxy, horrors that are real.<br><br>
      Survive till dawn, facing nightmares untold,<br>
      Five Nights at Freddy's, where fear takes hold.<br><br>
     <div id="answerQ7"></div>
     <div>正确答案是：A</div>
     <div id="timerQ7"></div>
</p>
    <div class="popup_btn">
      <button class="confirmBtn" onclick="hidePopup('popup7')">确认</button>
    </div>
  </div>
</div>
<button id="showPopup7" onclick="showPopup('popup7');showSelection('Q7')">查看答案7</button>
<br>
<br>
Q8:
<audio controls>
  <source src="011.wav">
  您的浏览器不支持 audio 元素。
</audio><br>
<table>
  <tr class="image-container">
    <td><img src="/2024/02/14/240214responder-game/011Majora's mask.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/002Amnesia.jpg" alt width="30%"></td>
    <td><img src="/2024/02/14/240214responder-game/009heavy rain.jpg" alt width="30%"></td>
  </tr>
  <tr>
    <td><button class="Q8" onclick="selectOption('Q8', 'A')">A</button></td>
    <td><button class="Q8" onclick="selectOption('Q8', 'B')">B</button></td>
    <td><button class="Q8" onclick="selectOption('Q8', 'C')">C</button></td>
  </tr>
</table>
<br>
<div id="overlay8" class="overlay">
  <div id="popup8" class="popup">
    <p class="popup_title">歌词原文及答案</p>
    <p class="popup_content" align="left">
      <img src="/2024/02/14/240214responder-game/011Majora's mask.jpg" alt="Majora's Mask" align="right" width="30%">
      In a countdown's grasp, time's running low,<br>
      Complete tasks in three days, before shadows grow.<br><br>
      Flute of Time, months pass, secrets unfold,<br>
      Find the mask, power untold.<br><br>
      Dark and disturbing elements take flight,<br>
      Ben Prowned's presence haunts, through day and night.<br><br>
      Haunting echoes linger, in each twisted turn,<br>
      Majora's Mark weaves nightmares, a world to discern.<br><br>
     <div id="answerQ8"></div>
     <div>正确答案是：A</div>
     <div id="timerQ8"></div>
</p>
    <div class="popup_btn">
      <button class="confirmBtn" onclick="hidePopup('popup8')">确认</button>
    </div>
  </div>
</div>
<button id="showPopup8" onclick="showPopup('popup8');showSelection('Q8')">查看答案8</button>
<div>答题情况汇总：（Q_绿色答对，红色误答；时间项红色为超时或误答）</div>
<table border="1">
  <tr>
    <td id="sumcfQ1">Q1</td>
    <td id="sumcfQ2">Q2</td>
    <td id="sumcfQ3">Q3</td>
    <td id="sumcfQ4">Q4</td>
  </tr>
  <tr>
    <td id="sumtimerQ1"></td>
    <td id="sumtimerQ2"></td>
    <td id="sumtimerQ3"></td>
    <td id="sumtimerQ4"></td>
  </tr>
  <tr>
    <td id="sumcfQ5">Q5</td>
    <td id="sumcfQ6">Q6</td>
    <td id="sumcfQ7">Q7</td>
    <td id="sumcfQ8">Q8</td>
  </tr>
  <tr>
    <td id="sumtimerQ5"></td>
    <td id="sumtimerQ6"></td>
    <td id="sumtimerQ7"></td>
    <td id="sumtimerQ8"></td>
  </tr>
</table>
    <script>
      function showPopup(popupId) {
          var overlay = document.getElementById("overlay" + popupId.substring(5));
          overlay.style.display = "block";
      }
      function hidePopup(popupId) {
          var overlay = document.getElementById("overlay" + popupId.substring(5));
          overlay.style.display = "none";
      }
      function selectOption(questionId, option) {
          // 禁用其他两个按钮
          var buttons = document.getElementsByClassName(questionId);
          var buttonsArray = Array.from(buttons);
          buttonsArray.forEach(function(button) {
              button.disabled = true;
          });
          // 在这里执行获取选项信息的操作
          localStorage.setItem(questionId, option);
          alert("您选择了问题 " + questionId + " 的选项 " + option);
          //按钮点击后禁用对应计时器
          //document.getElementById(audioId).removeEventListener('play', startTimer);
          //stopTimer();
          //计算时间间隔，即计时
          if(startTime==0) return;
          var endTime = new Date();
          var elapsedTime = endTime - startTime;
          startTime = 0;
          localStorage.setItem(questionId + "_time",elapsedTime); //存储时间
      }
    function showSelection(questionId) {
    var selectedOption = localStorage.getItem(questionId);
    var answerDiv = document.getElementById("answer" + questionId);
    if (selectedOption) {
        answerDiv.innerText = "您选择的选项是：" + selectedOption;
    } else {
        answerDiv.innerText = "您尚未选择任何选项！";
    }
    // 显示时间间隔 暂且log
    var elapsedTime = localStorage.getItem(questionId + "_time");
    var timerDiv = document.getElementById("timer" + questionId);
    //test:
    //console.log(elapsedTime);
    let sumtimer = document.getElementById('sumtimer'+questionId);
    if(elapsedTime==null || elapsedTime==NaN){
        timerDiv.innerText = "您并未播放过音频！";
        sumtimer.innerText = "--:--";
    }
    else if(elapsedTime > 30000){
        if(timerDiv.innerText.startsWith("用时")) {console.log("出现错误按键");return;}
        timerDiv.innerText = "已超时（超过30秒）；未播放音频直接点击选项也会出现这段文字";
        localStorage.setItem(questionId + "finaltimer",30000);
        sumtimer.innerText = "30:00";
        sumtimer.style.color="red";
    }
    else{
        let seconds =Math.floor(elapsedTime/1000);
        let miliseconds = Math.floor(elapsedTime/10%100);
        timerDiv.innerText = "用时："+seconds+":"+miliseconds;
        localStorage.setItem(questionId + "finaltimer",elapsedTime);
        sumtimer.innerText =seconds+":"+miliseconds;
        sumtimer.style.color="black";
    }
    check(questionId);
    //test:
    console.log("从点击播放按钮到点击答案按钮的时间间隔：" + elapsedTime + "毫秒");
  }
  function clearLocalStorage() {
    localStorage.clear();
    alert("成功清除缓存")
  }
    var timer;
    var startTime;
    function startTimer(){
        startTime = new Date();
        //timer = setInterval(updatetimer,1000);
        //test:
        //console.log(startTime);
    }
    function stopTimer(){
        //clearInterval(timer);
    }
    //监听器，播放按钮被点击时触发
    document.querySelectorAll('audio').forEach(function(audio) {
        audio.addEventListener('play', startTimer);
    });
    function check(questionId){
      var AnswerLot = ['D','A','C','B','C','A','A','A','A'];
      let answer = localStorage.getItem(questionId);
      let sumtimer = document.getElementById('sumtimer'+questionId);
      var sumcf = document.getElementById('sumcf'+questionId);
      if(answer!=AnswerLot[questionId.substring(1,2)]) 
      {
        sumcf.style.color = "red";
        sumtimer.style.color = "red";
      }
      else{
        sumcf.style.color = "green";
      }
      return;
    }
      </script>
</body>

]]></content>
      <categories>
        <category>game</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找相同图案——本地对战版 实现笔记 | Find-same-patterns-notes</title>
    <url>/2024/02/28/240228Find-same-patterns-notes/</url>
    <content><![CDATA[<p>目标：<br>1.理解翻牌游戏的内在逻辑<br>2.学习建立html游戏的基本思路，实践基本流程</p>
<h2 id="1-关于Element-classList"><a href="#1-关于Element-classList" class="headerlink" title="1. 关于Element.classList"></a>1. 关于Element.classList</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/classList">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/classList</a><br>它是一个只读属性，可以返回一个元素的动态DOMTokenList集合，可用于操作class集合。<br>可以用add()，remove()，replace()，toggle()方法修改DOMTokenList：<br>示例：<br>const div &#x3D; document.createElement(“div”);<br>div.className &#x3D; “foo”;<br>console.log(div.outerHTML); &#x2F;&#x2F;&lt; div class&#x3D;”foo”&gt;&lt;&#x2F; div&gt;<br>&#x2F;&#x2F;使用classList API<br>div.classList.remove(“foo”);<br>div.classList.add(“anotherclass”);<br>&#x2F;&#x2F;…class&#x3D;”anotherclass”…<br>div.classList.toggle(“visible”); &#x2F;&#x2F;toggle切换；如果该类值已存在则移除它，否则添加它。</p>
<blockquote>
<p>[toggle(class, true|false)	在元素中切换类名。<br>第一个参数为要在元素中移除的类名，并返回 false。<br>如果该类名不存在则会在元素中添加类名，并返回 true。<br>第二个是可选参数，是个布尔值用于设置元素是否强制添加或移除类，不管该类名是否存 在。例如：</p>
</blockquote>
<p>移除一个 class: element.classList.toggle(“classToRemove”, false);<br>添加一个 class: element.classList.toggle(“classToAdd”, true);</p>
<p>注意： Internet Explorer 或 Opera 12 及其更早版本不支持第二个参数。]<br>div.classList.toggle(“visible”,i&lt;10);<br>console.log(dic.classList.contains(“foo”))<br>&#x2F;&#x2F;添加删除多个类值<br>div.classListadd&#x2F;remove(“foo”,”bar”,…);<br>&#x2F;&#x2F;使用展开语法添加或移除多个类值<br>const cls &#x3D; [“foo”,”bar”];<br>div.classList.add(…cls);<br>div.classList.remove(…cls);<br>div.classList.replace(“foo”,”bar”);</p>
<p>翻牌游戏的js代码中主要就是通过classList这个API添加删除类值，改变卡牌的状态。</p>
<h2 id="2-关于API-应用程序编程接口"><a href="#2-关于API-应用程序编程接口" class="headerlink" title="2.关于API 应用程序编程接口"></a>2.关于API 应用程序编程接口</h2><p>API(Application Programming Interface)程序之间的接口，程序之间的合约。<br>可以理解为：服务商通过API提供服务，进行利益交换&#x2F;互助。</p>
<h2 id="3-Node-appendChild-方法"><a href="#3-Node-appendChild-方法" class="headerlink" title="3.Node.appendChild()方法"></a>3.Node.appendChild()方法</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild">https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild</a><br>将一个结点附加到指定父节点的子节点列表的末尾处；如有该结点本身存在，只会移动而非新建（不用事先删除要移动的结点）<br>若要保留原有结点，可通过Node.cloneNode()方法创造副本（即复制），再对副本操作。<br>如果给定的子节点是 DocumentFragment，那么 DocumentFragment 的全部内容将转移到指定父节点的子节点列表中。<br>备注： 有更加新的 API 可供使用！ &gt; ParentNode.append() (en-US) 方法支持多个参数，接受字符串作为参数，会将字符串转换为文本节点再附加。<br>语法<br>element.appendChild(aChild)<br>参数<br>aChild<br>要追加给父节点（通常为一个元素）的节点。<br>返回值<br>返回追加后的子节点（aChild），除非 aChild 是一个文档片段（DocumentFragment），这种情况下将返回空文档片段（DocumentFragment）。</p>
<p>对数组有push、pop操作。</p>
<p>使板块背面为字母，就是改变.deck .card背后的background元素，给每个type单独赋值一个，但是为了满足字母位置不变的需求，应当让背面的字母与类数组的下标对应。<br>appendChild会移除原对象，需要使用cloneNode()等方法复制原对象后对副本操作。但对于本项目的需求，复制cards数组对三个独立的“cards”数组操作更为便捷。<br>经过实践，复制cards数组的过程中还是需要使用cloneNode()复制DOM结点，否则数组内都是同个DOM结点，只是存有指针的顺序不同，仍然只有最后一个有效。为此我添加了initial()函数用于在页面加载时复制结点到两个target-card数组中。</p>
<h2 id="4-slice-和concat-在JS中复制数组时的常用方法"><a href="#4-slice-和concat-在JS中复制数组时的常用方法" class="headerlink" title="4.slice()和concat() 在JS中复制数组时的常用方法"></a>4.slice()和concat() 在JS中复制数组时的常用方法</h2><p>slice()方法：array.slice(start,end)<br>slice返回一个新数组，从start位置到end位置（不包括end）的元素；若省略end参数则会一直复制到数组的末尾。<br>示例：<br>const array &#x3D; [1, 2, 3, 4, 5];<br>const newArray &#x3D; array.slice(1, 3); &#x2F;&#x2F; 返回 [2, 3]<br>concat()方法：array.concat(value1,value2,…,valueN)<br>concat用于合并两个或多个数组，并返回一个新数组。<br>示例：<br>const array1 &#x3D; [1, 2, 3];<br>const array2 &#x3D; [4, 5, 6];<br>const newArray &#x3D; array1.concat(array2); &#x2F;&#x2F; 返回 [1, 2, 3, 4, 5, 6]</p>
<p>逗号分隔元素单元：<br>#target-card1 .card,#target-card2 .card<br>同时执行多个函数的方法：<br>document.body.onload &#x3D; function(){initial();startGame();}</p>
<p>removeChild()与appendChild()相对。主要使用这两个方法增添减少deck中的card。<br>firstChild DOM中的方法，获取该元素的第一个孩子结点，没有孩子则返回null。</p>
<p>类似于appendChild的属性有：</p>
<p>insertBefore: 这个方法将一个节点插入到指定节点之前的位置。<br>replaceChild: 这个方法替换指定父节点的子节点。<br>append: 这是一个比较新的方法，它允许将一个或多个节点追加到父节点的子节点列表的末尾。<br>prepend: 与append类似，但是它会将节点插入到父节点的子节点列表的开头。<br>insertAdjacentElement: 这个方法允许在指定元素的相对位置插入一个HTML元素节点。<br>这些方法都用于动态地向文档中添加新的节点或对现有节点进行操作。</p>
<p>原有样例的翻面是由“原本字体大小为0”+“反转动画”+“对class::open的字体样式进行设置，即设置font-size: 33px”完成的。因此，要使卡牌”正面显示“，只需要设置font-size的大小。（注意：ID选择器优先级高于类选择器，注意覆盖问题）</p>
<p>在替换图标时，由于之前使用的是字体，可以直接对字体大小font-size操作；而使用svg后要对width和height操作，因此要重新设定样式。<br>经过不断地尝试，我利用id选择器优先级高的特点，利用后代选择器为#card-deck里面的svg图像设置样式。<br>#card-deck .open .icon可以在翻开卡片时被使用；<br>而#card-deck .card:not(.open) .icon会在卡片没被翻开时使用。<br>其余部分都只用直接展示，使用svg标签选择。<br>接下来就是用自选的图案svg机械替换原有文本。（当然SVG标签也可以选择卡片背面的字母）<br>在测试的过程中，unmatched时的红把红色图案融入其中，无法观察，因此修改了unmatched状态下的background-color。<br>废弃了一个图案。指纹的svg代码太长了，给GPT转url都要continue两次……</p>
<p>关于需要找的图案上的标识，debug了半天，发现问题在于：使用……::after{positon: absolute}时，其包含块即父元素（此处是card）的定位属性必须设置为非 static 属性，比如 relative、absolute 或者 fixed。否则，它会继续往父元素的父元素寻找（作为包含块），直到定位到具有非static定位属性的元素（或者到达根元素html）。当到达根元素html伪元素的位置属性top、right、bottom、left都是相对于html网页的。当你的位置属性给出个负值，很有可能会移除视口（viewport）之外，导致无法看见这个元素。</p>
<p>unmatched的动画现在匹配不到targetcard数组<br>学习html内嵌博客的不同方法。。。。。。<br>设置起始位置下拉选项框<br>设置介绍游戏规则的按钮及浮窗<br>难度的切换？（可以另做，最好内嵌）<br>新增next标识，修改代码<br>为了更加贴合原游戏的设定，添加了游戏规则按钮与两色next标识。需要寻找的图案为next标识对应的图案。因此，match相关的一系列代码传参都要改成cur+1，游戏结束判定条件也有所更改。<br>考虑到游戏后期5秒的显示时间可能过长，我添加了设置显示时间的设置。并发现已知性能问题：若保存设置，content2会过一小段时间再消失。<br>问题：保存设置时，content2会过一小段时间再消失</p>
<h2 id="5-设置下拉框dropdown并获取选中项"><a href="#5-设置下拉框dropdown并获取选中项" class="headerlink" title="5.设置下拉框dropdown并获取选中项"></a>5.设置下拉框dropdown并获取选中项</h2><p>示例：<br>&lt; select id&#x3D;”myDropdown”&gt;<br>  &lt; option value&#x3D;”option1”&gt;Option 1&lt;&#x2F; option&gt;<br>  &lt; option value&#x3D;”option2”&gt;Option 2&lt;&#x2F; option&gt;<br>  &lt; option value&#x3D;”option3”&gt;Option 3&lt;&#x2F; option&gt;<br>&lt;&#x2F; select&gt;</p>
<p>&lt; button onclick&#x3D;”getSelectedOption()”&gt;Get Selected Option&lt;&#x2F; button&gt;</p>
<p>&lt; script&gt;<br>function getSelectedOption() {<br>  var dropdown &#x3D; document.getElementById(“myDropdown”);<br>  var selectedOption &#x3D; dropdown.options[dropdown.selectedIndex].value;<br>  console.log(“Selected option:”, selectedOption);<br>  &#x2F;&#x2F; 在这里你可以使用 selectedOption 的值进行其他操作<br>}<br>&lt; &#x2F;script&gt;</p>
<p>dropdown的方法：<br>selectedIndex： 获取或设置下拉框中当前选中项的索引值。<br>var selectedIndex &#x3D; dropdown.selectedIndex; &#x2F;&#x2F; 获取当前选中项的索引值<br>dropdown.selectedIndex &#x3D; 2; &#x2F;&#x2F; 设置选中索引为第3个选项<br>value： 获取或设置下拉框中当前选中项的值。<br>var selectedValue &#x3D; dropdown.value; &#x2F;&#x2F; 获取当前选中项的值<br>dropdown.value &#x3D; “option2”; &#x2F;&#x2F; 设置选中值为 “option2”<br>options： 获取下拉框中所有选项的集合。<br>var options &#x3D; dropdown.options; &#x2F;&#x2F; 获取所有选项的集合<br>var firstOptionValue &#x3D; options[0].value; &#x2F;&#x2F; 获取第一个选项的值<br>add() 和 remove()： 向下拉框中添加或移除选项。<br>&#x2F;&#x2F; 向下拉框中添加新选项<br>dropdown.add(new Option(“Option 4”, “option4”));<br>&#x2F;&#x2F; 从下拉框中移除指定索引的选项<br>dropdown.remove(1); &#x2F;&#x2F; 移除第2个选项<br>onchange 事件： 当下拉框的选中项发生变化时触发。<br>dropdown.onchange &#x3D; function() {<br>    console.log(“选中项发生变化”);<br>};</p>
<p>6.使用iframe标签在博客中嵌套html页面<br>&lt; iframe width&#x3D;”100%” height&#x3D;”100%”  src&#x3D;”.\Find_same_patterns.html”&gt;&lt;&#x2F; iframe&gt;<br>iframe标签中scrolling属性默认为”yes”，即允许滚动，当高度不足以展示页面内容时显示滚动条。<br>博客嵌套html页面主要的问题是height&#x3D;”100%”这个属性不使用于博客页面。博客里面有其它元素，直接设置百分比只会填充预留区域（此时如在matery中下方会有“文章作者”等内容会挤占页面空间，导致height值实际上很小，如下图hegiht&#x3D;154）<br><img src="/2024/02/28/240228Find-same-patterns-notes/001.png" alt="示例图片" width="50%"><br>因此，在博客中内嵌html，height值不能使用百分比设置，只要设定足够的、能够展示完整页面的height就行了。例如针对图中示例，height&#x3D;910px时就能展示完全，此时滚动条也消失了。（但是这无法自适应浏览器尺寸变化导致的html高度的变化。）<br><img src="/2024/02/28/240228Find-same-patterns-notes/002.png" alt="示例图片" width="50%"><br>但是，可以看到现在iframe界面有边框，不够美观，经检测可以发现这是源自user agent stylesheet，也就是浏览器默认样式（见下图）。手动设置边框样式就可以覆盖掉默认样式，如使用style&#x3D;”border: 0px”加上内联样式。也可以使用到html属性frameborder，即frameborder&#x3D;”0”。但这里用到了外部CSS文件设置样式，所以更推荐后者。<br><img src="/2024/02/28/240228Find-same-patterns-notes/003.png" alt="示例图片" width="80%"><br>至于参考文章<a href="https://www.haoyizebo.com/posts/e9071e74/">https://www.haoyizebo.com/posts/e9071e74/</a>中的获取高度的函数，没看懂。测试了下会让iframe的height比设置时多50像素，在手机中显示不完全。但我的理解是这个函数要获取到嵌套的html的高度，但好像没有实现。所以我为了显示全部内容干脆scrolling &#x3D; yes了。</p>
<p>24&#x2F;03&#x2F;01<br>修改的基本原理是：所有展示的卡牌改为cloneNode()产生的复制品；在废弃后借助JavaScript引擎的垃圾回收机制自行删除。initial()时进行复制。<br>首先，在设置中添加切换难度的单选框。若成功切换难度要重置card-deck与两个target-card，并立刻重启游戏。<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> var setversion = document.getElementById(&quot;setversion&quot;).value;</span><br><span class="line"> if(setversion != version)&#123;</span><br><span class="line">     version = setversion;</span><br><span class="line">     initial(version);</span><br><span class="line">     startGame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来更改initial()与startGame()函数。<br>更改时，将cards命名为空数组，用total_cards装有全部图案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.body.onload = function()&#123;initial(0);&#125;</span><br><span class="line">//主要作用：复制cards数组</span><br><span class="line">function initial(version)&#123;</span><br><span class="line">    //先删除cards中原有内容</span><br><span class="line">    cards.forEach(function(item)&#123;</span><br><span class="line">        item.remove();</span><br><span class="line">    &#125;);</span><br><span class="line">    //洗牌，确定使用图案的顺序</span><br><span class="line">    let usedImages = shuffle([0,1,2,3,4,5,6,7]);</span><br><span class="line">    if(version === 0)</span><br><span class="line">    &#123;//普通难度直接使用前四种图案，用i遍历usedImages；j用于遍历选中的图案(偏移量)</span><br><span class="line">        for(let i = 0;i &lt; 4;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(let j = 0;j &lt; 4;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cards.push(total_cards[usedImages[i]*4+j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if(version === 1)&#123;</span><br><span class="line">        for(let i = 0;i &lt; 4;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cards.push(total_cards[usedImages[i]*4 + i%4]);</span><br><span class="line">            cards.push(total_cards[usedImages[i]*4 + (i+1)%4]);</span><br><span class="line">            cards.push(total_cards[usedImages[i+4]*4 + (i+2)%4]);</span><br><span class="line">            cards.push(total_cards[usedImages[i+4]*4 + (i+3)%4]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //目标栏删除全部元素后复制</span><br><span class="line">    targetedCards1 = [];</span><br><span class="line">    targetedCards2 = [];</span><br><span class="line">    [].forEach.call(cards,function(item)&#123;</span><br><span class="line">        let clone1 = item.cloneNode(true);</span><br><span class="line">        let clone2 = item.cloneNode(true);</span><br><span class="line">        targetedCards1.push(clone1);</span><br><span class="line">        targetedCards2.push(clone2);</span><br><span class="line">        console.log(&quot;Test3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    startGame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实现过程中，曾错误地使用DOM方法remove来清空数组。这里的targetedcard并非DOM对象，remove无法清除。因此会出现每使用一次targetcard中原有元素不消失的错误。正确方法使用数组方法清除，如targetedCards1 &#x3D; [];<br>另外，发现version一开始是num类型，由于setversion是str类型，version也变为str类型，导致version&#x3D;&#x3D;&#x3D;0&#x2F;1的判断式失效。</p>
<h2 id="6-从HTML中获取值时，javaScript都会将它们解析为字符串"><a href="#6-从HTML中获取值时，javaScript都会将它们解析为字符串" class="headerlink" title="6.从HTML中获取值时，javaScript都会将它们解析为字符串"></a>6.从HTML中获取值时，javaScript都会将它们解析为字符串</h2><p>如果想要更改类型，可以使用js内置函数parseInt()或parseFloat()</p>
]]></content>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>一些感兴趣的逻辑问题 | 240408LogicQuestions</title>
    <url>/2024/04/08/240408LogicQuestions/</url>
    <content><![CDATA[<p><strong>取水问题</strong><br>【1】假设有一个池塘，里面有无穷多的水。现有2个空水壶，容积分别为5升和6升。问题是如何只用这2个水壶从池塘里取得3升的水。</p>
<p>【71】据说有人给酒肆的老板娘出了一个难题：此人明明知道店里只有两个舀酒的勺子，分别能舀7两和11两酒，却硬要老板娘卖给他2两酒。聪明的老板娘毫不含糊，用这两个勺子在酒缸里舀酒，并倒来倒去，居然量出了2两酒，聪明的你能做到吗？</p>
<p><strong>逻辑学问题 有点难 难在你要搞清楚为什么猜得出来</strong><br>【9】一个教授逻辑学的教授，有三个学生，而且三个学生均非常聪明！<br>一天教授给他们出了一个题，教授在每个人脑门上贴了一张纸条并告诉他们，每个人的纸条上都写了一个正整数，且某两个数的和等于第三个！（每个人可以看见另两个数，但看不见自己的）<br>教授问第一个学生：你能猜出自己的数吗？回答：不能，问第二个，不能，第三个，不能，再问第一个，不能，第二个，不能，第三个：我猜出来了，是144！教授很满意的笑了。请问您能猜出另外两个人的数吗？</p>
<p><strong>较简单的条件推理</strong><br>【18】5个人来自不同地方，住不同房子，养不同动物，吸不同牌子香烟，喝不同饮料，喜欢不同食物。根据以下线索确定谁是养猫的人。<br>1． 红房子在蓝房子的右边，白房子的左边（不一定紧邻）<br>2． 黄房子的主人来自香港，而且他的房子不在最左边。<br>3． 爱吃比萨的人住在爱喝矿泉水的人的隔壁。<br>4． 来自北京的人爱喝茅台，住在来自上海的人的隔壁。<br>5． 吸希尔顿香烟的人住在养马人的右边隔壁。<br>6． 爱喝啤酒的人也爱吃鸡。<br>7． 绿房子的人养狗。<br>8． 爱吃面条的人住在养蛇人的隔壁。<br>9． 来自天津的人的邻居（紧邻）一个爱吃牛肉，另一个来自成都。<br>10．养鱼的人住在最右边的房子里。<br>11．吸万宝路香烟的人住在吸希尔顿香烟的人和吸“555”香烟的人的中间（紧邻）<br>12．红房子的人爱喝茶。<br>13．爱喝葡萄酒的人住在爱吃豆腐的人的右边隔壁。<br>14．吸红塔山香烟的人既不住在吸健牌香烟的人的隔壁，也不与来自上海的人相邻。<br>15．来自上海的人住在左数第二间房子里。<br>16．爱喝矿泉水的人住在最中间的房子里。<br>17．爱吃面条的人也爱喝葡萄酒。<br>18．吸“555”香烟的人比吸希尔顿香烟的人住的靠右</p>
<p><strong>经典时间规划</strong><br>【21】U2合唱团在17分钟 内得赶到演唱会场，途中必需跨过一座桥，四个人从桥的同一端出发，你得帮助他们到达另一端，天色很暗，而他们只有一只手电筒。一次同时最多可以有两人一起过桥，而过桥的时候必须持有手电筒，所以就得有人把手电筒带来带去，来回桥两端。手电筒是不能用丢的方式来传递的。四个人的步行速度各不同，若两人同行则 以较慢者的速度为准。Bono需花1分钟过桥，Edge需花2分钟过桥，Adam需花5分钟过桥，Larry需花10分钟过桥。他们要如何在17分钟内过桥呢？</p>
<p><strong>经典编码问题</strong><br>【26】话说有十二个鸡蛋，有一个是坏的（重量与其余鸡蛋不同），现要求用天平称三次，称出哪个鸡蛋是坏的！</p>
<p><strong>思考题</strong><br>【30】烧一根不均匀的绳要用一个小时，如何用它来判断半个小时？<br>烧一根不均匀的绳,从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子,问如何用烧绳的方法来计时一个小时十五分钟呢?</p>
<p><strong>最大学物理的一集</strong><br>【40】两个空心球，大小及重量相同，但材料不同。一个是金，一个是铅。空心球表面图有相同颜色的油漆。现在要求在不破坏表面油漆的条件下用简易方法指出哪个是金的，哪个是铅的。</p>
<p><strong>逻辑题之完全理性人</strong><br>【45】5名海盗抢得了窖藏的100块金子，并打算瓜分这些战利品。这是一些讲民主的海盗（当然是他们自己特有的民主），他们的习惯<br>是按下面的方式进行分配：最厉害的一名海盗提出分配方案，然后所有的海盗（包<br>括提出方案者本人）就此方案进行表决。如果50%或更多的海盗赞同此方案，此方<br>案就获得通过并据此分配战利品。否则提出方案的海盗将被扔到海里，然后下一名<br>最厉害的海盗又重复上述过程。<br>所有的海盗都乐于看到他们的一位同伙被扔进海里，不过，如果让他们选择的<br>话，他们还是宁可得一笔现金。他们当然也不愿意自己被扔到海里。所有的海盗都<br>是有理性的，而且知道其他的海盗也是有理性的。此外，没有两名海盗是同等厉害<br>的——这些海盗按照完全由上到下的等级排好了座次，并且每个人都清楚自己和其<br>他所有人的等级。这些金块不能再分，也不允许几名海盗共有金块，因为任何海盗<br>都不相信他的同伙会遵守关于共享金块的安排。这是一伙每人都只为自己打算的海<br>盗。<br>最凶的一名海盗应当提出什么样的分配方案才能使他获得最多的金子呢？</p>
<hr>
<p>答案部分分界线</p>
<hr>
<p>【1】<br>1、先把5升的灌满，倒在6升里，这时6升的壶里有5升水<br>2.再把5升的灌满，用5升的壶把6升的灌满，这时5升的壶里剩4升水<br>3.把6升的水倒掉，再把5升壶里剩余的水倒入6升的壶里，这时6升的壶里有4升水<br>4.把5升壶灌满，倒入6升的壶，5-2&#x3D;3</p>
<p>【71】<br>7两倒入11两, 再用7两倒入11两装满, 7两中剩余3两, 倒出11两, 将3两倒入11两, 用7两两次倒入11两装满, 7两中剩余6两, 将11两倒出, 将6两倒入, 然后用7两倒入11两, 剩余2两. 于是得到.<br>11,0–&gt;4,7–&gt;4,0–&gt;0,4–&gt;11,4–&gt;8,7–&gt;8,0–&gt;1,7–&gt;1,0–&gt;0,1–&gt;11,1–&gt;5,7–&gt;5,0–&gt;0,5–&gt;11,5–&gt;9,7–&gt;9,0–&gt;2,7</p>
<p>【9】<br>经过第一轮，说明任何两个数都是不同的。第二轮，前两个人没有猜出，说明任何一个数都不是其它数的两倍。现在有了以下几个条件：1.每个数大于02.两两不等3.任意一个数不是其他数的两倍。每个数字可能是另两个之和或之差，第三个人能猜出144，必然根据前面三个条件排除了其中的一种可能。假设：是两个数之差，即x－y＝144。这时1（x，y&gt;0）和2（x！＝y）都满足，所以要否定x＋y必然要使3不满足，即x＋y＝2y，解得x＝y，不成立（不然第一轮就可猜出），所以不是两数之差。因此是两数之和，即x＋y＝144。同理，这时1，2都满足，必然要使3不满足，即x－y＝2y，两方程联立，可得x＝108，y＝36。<br>    这两轮猜的顺序其实分别为这样：第一轮（一号，二号），第二轮（三号，一号，二号）。这样分大家在每轮结束时获得的信息是相同的（即前面的三个条件）。<br>    那么就假设我们是C，来看看C是怎么做出来的：C看到的是A的36和B的108，因为条件，两个数的和是第三个，那么自己要么是72要么是144（猜到这个是因为72的话，108就是36和72的和，144的话就是108和36的和。这样子这句话看不懂的举手）:<br>    假设自己（C）是72的话，那么B在第二回合的时候就可以看出来，下面是如果C是72，B的思路：这种情况下，B看到的就是A的36和C的72，那么他就可以猜自己，是36或者是108（猜到这个是因为36的话，36加36等于72，108的话就是36和108的和）：<br>    如果假设自己（B）头上是36，那么，C在第一回合的时候就可以看出来，下面是如果B是36，C的思路：这种情况下，C看到的就是A的36和B的36，那么他就可以猜自己，是72或者是0（这个不再解释了）：<br>如果假设自己（C）头上是0，那么，A在第一回合的时候就可以看出来，下面是如果C是0，A的思路：这种情况下，A看到的就是B的36和C的0，那么他就可以猜自己，是36或者是36（这个不再解释了），那他可以一口报出自己头上的36。（然后是逆推逆推逆推），现在A在第一回合没报出自己的36，C（在B的想象中）就可以知道自己头上不是0，如果其他和B的想法一样（指B头上是36），那么C在第一回合就可以报出自己的72。现在C在第一回合没报出自己的36，B（在C的想象中）就可以知道自己头上不是36，如果其他和C的想法一样（指C头上是72），那么B在第二回合就可以报出自己的108。现在B在第二回合没报出自己的108，C就可以知道自己头上不是72，那么C头上的唯一可能就是144了。</p>
<p>【18】<br>1　　　 2　　　 3　　 4　 　　5<br>蓝房子　　绿　 黄　 　 红　　　白<br>北京人　 上海　 香港　 天津　　 成都<br>茅台酒　 葡萄　 矿泉水　 茶　　 啤酒<br>豆腐　　　面条 牛肉　 比萨　　 鸡<br>健牌　　希尔顿　万宝路　 555　 红塔山<br>马　　　 狗　　 蛇　　 猫　　 鱼</p>
<p>【21】<br>假设这四个人分别为甲（1分钟）乙（2分钟）丙（5分钟）丁（10分钟）<br>第一次去：甲和乙 （2分钟）<br>第一次回：甲（1分钟）<br>第二次去：丙和丁（10分钟）<br>第二次回：乙（2分钟）<br>第三次去：甲和乙（2分钟）<br>总计 ：17分钟</p>
<p>【26】<br>12个时可以找出那个是重还是轻，13个时只能找出是哪个球，轻重不知。<br>　　把球编为①②③④⑤⑥⑦⑧⑨⑩⑾⑿。（13个时编号为⒀）<br>　　第一次称：先把①②③④与⑤⑥⑦⑧放天平两边，<br>　　　　㈠如相等，说明特别球在剩下4个球中。<br>　　　　　　把①⑨与⑩⑾作第二次称量，<br>　　　　　　⒈如相等，说明⑿特别，把①与⑿作第三次称量即可判断是⑿是重还是轻<br>　　　　　　⒉如①⑨＜⑩⑾说明要么是⑩⑾中有一个重的，要么⑨是轻的。<br>　　　　　　　　把⑩与⑾作第三次称量，如相等说明⑨轻，不等可找出谁是重球。<br>　　　　　　⒊如①⑨＞⑩⑾说明要么是⑩⑾中有一个轻的，要么⑨是重的。<br>　　　　　　　　把⑩与⑾作第三次称量，如相等说明⑨重，不等可找出谁是轻球。<br>　　　　㈡如左边＜右边，说明左边有轻的或右边有重的<br>　　　　　　把①②⑤与③④⑥做第二次称量<br>　　　　　　⒈如相等，说明⑦⑧中有一个重，把①与⑦作第三次称量即可判断是⑦与⑧中谁是重球<br>　　　　　　⒉如①②⑤＜③④⑥说明要么是①②中有一个轻的，要么⑥是重的。<br>　　　　　　　　把①与②作第三次称量，如相等说明⑥重，不等可找出谁是轻球。<br>　　　　　　⒊如①②⑤＞③④⑥说明要么是⑤是重的，要么③④中有一个是轻的。<br>　　　　　　　　把③与④作第三次称量，如相等说明⑤重，不等可找出谁是轻球。<br>　　　　㈢如左边＞右边，参照㈡相反进行。<br>　　当13个球时，第㈠步以后如下进行。<br>　　　　把①⑨与⑩⑾作第二次称量，<br>　　　　⒈如相等，说明⑿⒀特别，把①与⑿作第三次称量即可判断是⑿还是⒀特别，但判断不了轻重了。<br>　　　　⒉不等的情况参见第㈠步的⒉⒊</p>
<p>【30】<br>一，一根绳子从两头烧，烧完就是半个小时。<br>二，一根要一头烧，一根从两头烧，两头烧完的时候（30分），将剩下的一根另一端点着，烧尽就是45分钟。再从两头点燃第三根，烧尽就是1时15分。</p>
<p>【40】<br>旋转看速度，金的密度大，质量相同，所以金球的实际体积较小，因为外半径相同，所以金球的内半径较大，所以金球的转动惯量大，在相同的外加力矩之下，金球的角加速度较小，所以转得慢。</p>
<p>【45】<br>如果轮到第四个海盗分配：100，0<br>轮到第三个：99，0，1<br>轮到第二个：98，0，1，0<br>轮到第一个：97，0，1，0，2，这就是第一个海盗的最佳方案。</p>
]]></content>
  </entry>
  <entry>
    <title>GPT编程01——翻转游戏</title>
    <url>/2024/05/27/240524Filp_Game/</url>
    <content><![CDATA[<blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>GPT4-o的发行，标志着可用的大语言模型的进一步发展。现在，GPT在编程方面的能力已经很强了。这个系列将以GPT作为助手，基本使用GPT实现项目的需求，完成项目。与此同时辅以手动debug。<br>目前，我的期待是锻炼GPT编程水平，同时通过GPT给出的代码学习相关函数的使用，积累知识。</p>
</blockquote>
<p>2405270859版本：修正代码块(之前用的不是反引号‘&#96;’)；完善标题结构；注：output不是GPT的输出，是我自拟的表示该文件里有GPT当次回答所提供的代码。<br>2406111057版本：手机端代码块显示问题等待解决。修复演示程序中生成过随机题目后更改大小导致不合理版面的bug；给演示程序的源html加上了N范围为2~10的限制，防止标题以及按钮被覆盖。</p>
<h1 id="Project-No1-Flip-Game-翻转问题-游戏交互"><a href="#Project-No1-Flip-Game-翻转问题-游戏交互" class="headerlink" title="Project_No1:Flip_Game 翻转问题-&gt;游戏交互"></a>Project_No1:Flip_Game 翻转问题-&gt;游戏交互</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>翻转问题（亮灯问题），多次在解密游戏中碰到。十分有魅力。</p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol>
<li>基本实现界面，有重置、查看可行解的功能；</li>
<li>可以给出具体N值时的特例，作为一道谜题；</li>
<li>可以记录点击的步数；</li>
<li>可以支持对同一道题的多次尝试，记录玩家的最优步数。</li>
</ol>
<p>灵感列表：</p>
<ol>
<li>点击后，触发翻转事件的格子不是我点击的格子，该格子与我点击的格子沿水平中线对称（将直角坐标系移到中心后，两个格子关于x轴对称）。(要给操作上难度的确可以对称位置操作，竞速时倒可以作为干扰因素)</li>
<li>可以添加选择渐变色的功能，给出几种选择。</li>
</ol>
<p>提问-&gt;解析的形式</p>
<p>之前看过一篇对翻转问题进行分析的文章，文章中通过渐变色格子展示N*N时的最优解，很是壮观。因此，私心想用渐变色表示~~</p>
<h3 id="渐变色表示与基本游戏逻辑实现"><a href="#渐变色表示与基本游戏逻辑实现" class="headerlink" title="渐变色表示与基本游戏逻辑实现"></a>渐变色表示与基本游戏逻辑实现</h3><p>Q:使用python，画N<em>N的方格，其中指定下标的方格为渐变颜色，其余为白色，有粗边框，方格间有细边框<br>A:当然可以！你可以使用Python的matplotlib库来画出这样的渐变色方格。下面是一个实现的示例代码：output:001.py<br>代码解释<br>导入必要的库：matplotlib.pyplot用于绘图，numpy用于处理数值数组，matplotlib.colors用于处理颜色。<br>创建绘图函数：draw_grid函数接收网格大小N和需要渐变颜色的方格坐标列表gradient_cells。<br>设置图像和轴：<br>关闭坐标轴刻度。<br>设置粗边框。<br>绘制N</em>N网格：<br>使用双重循环创建方格。如果方格在gradient_cells中，则创建渐变颜色。否则，填充白色。<br>添加细边框：<br>使用循环和ax.plot函数添加细边框。<br>设置轴的限制和纵横比：<br>确保整个网格显示在图像中，并且每个方格都是正方形。<br>显示图像：使用plt.show()显示图像。<br>通过此代码，你可以生成一个包含渐变颜色和边框的N<em>N网格。你可以根据需要调整渐变颜色和指定方格的坐标。<br>Q:如何设置渐变色？有什么已有的渐变色模板吗？<br>Q:其中有没有渐变色只有一种主色系的？ output:002.py<br>Q:有没有浅蓝到紫晶蓝的渐变色 output:003.py<br>Q:能否做一个翻转问题的界面，要求能与界面交互。界面大小为4</em>4，被翻转的为渐变色，未被翻转的为白色 output:004.py<br>Q:翻转问题，是翻转一个格子，上下左右的格子也会一并翻转的问题，当全部格子被翻面即成功。根据这个信息进行修改 output:005.py<br>Q:渐变色能不能由中心向外？ output:006.py<br>Q:那个格子自身也要翻转 output:007.py<br>Q:……<br>File “E:\Project_storage\方格.venv\Lib\site-packages\matplotlib\artist.py”, line 1011, in set_alpha<br>    raise ValueError(f’alpha ({alpha}) is outside 0-1 range’)<br>ValueError: alpha (1.118033988749895) is outside 0-1 range<br>A:这个错误是因为尝试设置了超出范围的 alpha 值。我们需要确保 alpha 值在 0 到 1 的范围内。修改代码，使得 alpha 值不会超出这个范围。下面是修正后的代码：<br>output:008.py</p>
<h3 id="对界面交互的修正"><a href="#对界面交互的修正" class="headerlink" title="对界面交互的修正"></a>对界面交互的修正</h3><p>通过与界面进行交互，发现了几个问题：</p>
<ol>
<li>点击后，触发翻转事件的格子不是我点击的格子，该格子与我点击的格子沿水平中线对称（将直角坐标系移到中心后，两个格子关于x轴对称）。(要给操作上难度的确可以对称位置操作，竞速时倒可以作为干扰因素)</li>
<li>触发事件的格子并没有翻转，但周围的格子的正常翻转了</li>
<li>坐标为（3，3）的格子翻转状态无法正确显示，虽然边框好像会变<br><img src="/2024/05/27/240524Filp_Game/001_001.png"></li>
</ol>
<h4 id="翻转的逻辑"><a href="#翻转的逻辑" class="headerlink" title="翻转的逻辑"></a>翻转的逻辑</h4><blockquote>
<p>Q:在def flip_tile(self, x, y):中，第一行的self.grid[y, x] &#x3D; not self.grid[y, x]与后面的逻辑重复了，导致目标格子会被翻转两次，导致无法翻转。请自行修正。  另外，点击后，触发翻转事件的格子不是我点击的格子，该格子与我点击的格子沿水平中线对称（将直角坐标系移到中心后，两个格子关于x轴对称）。  此外，坐标为（3，3）的格子翻转状态无法正确显示。</p>
</blockquote>
<p>把发现的错误讲给GPT后，GPT没能有效修正(009.py)，只能手动修正了。<br>手动修正，必须理解代码的运行逻辑。如果不理解代码，只能看着错误干瞪眼。还是对着008.py修改。<br>手动修正时，还是可以借助GPT理解各部分代码的，但要谨防瞎说，不确定得自行验证or查文档。</p>
<blockquote>
<p>Q:……请解释这些代码</p>
</blockquote>
<p>在我对着解释理解各句代码的作用并在对应位置写入注释时，突发奇想，GPT应该也能完成这种机械化工作吧。于是：</p>
<blockquote>
<p>Q:能否讲你的解释，压缩后嵌入代码中？</p>
</blockquote>
<p>GPT的确能做到，没问到的部分它也做出了解释，但这种提问的解释必定不细致。不过重要的是理解各个参数与函数是怎么用的。</p>
<p>经过测试，发现一个新的线索：目前的平面直角坐标系原点在左下角。这应该是坐标逻辑出错的原因。多半就是坐标确定的逻辑出错了。在自己手动修改前还是试试GPT在知道问题时能不能自己改吧。</p>
<blockquote>
<p>Q:经过测试发现，目前的直角坐标系原点在左下角，导致格子的y坐标计算错误。请根据这个情况进行修正</p>
</blockquote>
<p>010.py<br>的确修正了。但是现在点击格子之后，触发事件的格子会向上偏移。最后一行的格子甚至压根无法触发事件。照例先告诉GPT这个问题。</p>
<blockquote>
<p>Q:现在点击格子之后，触发事件的格子会向上偏移。尤其是点击最后一行的格子时，触发的永远是倒数第二行的格子。</p>
</blockquote>
<p>011.py<br>问题并没有得到解决，顺带一提，新加的坐标显示，左上角格子编号(0,0)。与刚才的左下是坐标原点的逻辑基础相违背。刚才列出的问题1、3都没有得到解决。再给GPT一次机会。分析主要抓住坐标的逻辑，难不成y上取整了？<br>坐标确定代码为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x, y = <span class="built_in">int</span>(event.xdata), <span class="built_in">int</span>(self.N - event.ydata - <span class="number">1</span>)  <span class="comment"># 获取点</span></span><br></pre></td></tr></table></figure>
<p>跟上取整了差不多了，math.floor(N-y坐标-1)，第四行$$y \in (0,1)$$，所以$$(N-y-1) \in (2,3)$$，取下于它的最大整数（floor函数的功能）只能是2了，所以根本取不到最后一行(y&#x3D;3)。<br>将int(self.N - event.ydata - 1)改为int(self.N - event.ydata)，逻辑就正确了。<br>把这个线索交给GPT，这是它最后的机会了。</p>
<blockquote>
<p>Q:对于int(self.N - event.ydata - 1)，当y属于(0,1)时，好像int(self.N - event.ydata - 1)永远都是2<br>A:如果 y 的值在 (0, 1) 之间，确实会出现这个问题，因为 int() 函数会将小数部分舍去，而且 self.N 的值是整数，所以结果可能不如预期。为了解决这个问题，我们可以使用 np.floor() 或 np.ceil() 来确保正确地向下或向上取整。<br>……<br>x, y &#x3D; int(event.xdata), int(np.floor(self.N - event.ydata - 1))<br>……</p>
</blockquote>
<p>基本方向是对了，改的话就……emm。三次机会已到，不给它机会了。int()在非负取整结果上跟floor差不多，舍弃了浮点部分。GPT引用了numpy模块里的floor，也是常规用法吧，import math之后math.floor()也行。<br>关于int()与floor()，需要注意。int()对于负数而言会向“上”（向0）舍入到最接近的整数，而np.floor()总是向下舍入。np.floor()（来自numpy）能够对数组批量操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = -<span class="number">1.1</span></span><br><span class="line"><span class="built_in">print</span>(np.floor(y),<span class="built_in">int</span>(y))</span><br><span class="line"></span><br><span class="line">output: -<span class="number">2.0</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>就是GPT的表述，有点模糊吧，也放出来：（因为GPT表述太迷糊，上面的测试代码是自己写的）</p>
<blockquote>
<p>int() 将向零舍入，因此对于正数，它会截取小数部分；而对于负数，它会向下舍入到最接近的整数。<br>np.floor() 总是向下舍入到最接近的整数，即使是负数也是如此。</p>
</blockquote>
<h4 id="渐变色“消失”"><a href="#渐变色“消失”" class="headerlink" title="渐变色“消失”"></a>渐变色“消失”</h4><p>对于“3. 坐标为（3，3）的格子翻转状态无法正确显示，虽然边框好像会变”这个问题，估计是前期让它“渐变色中心向四周扩散”时出错了。试着问问GPT：</p>
<blockquote>
<p>Q:现在有一些格子的渐变色与其它的不一样？能否指出是为什么吗？<br>在原始的代码中，每个格子的渐变色是根据其到网格中心的距离来确定的，距离越远，渐变色越接近透明。但是在处理点击事件时，触发事件的格子及其相邻格子被翻转，这导致它们的渐变色也被重新计算，可能与其他格子的渐变色不同。因此，触发事件的格子和相邻格子的渐变色可能会与其他格子不一样。<br>为了解决这个问题，我们可以在处理点击事件时，不重新计算触发事件格子的渐变色，而是保持它们的渐变色与原始状态相同。这样可以确保触发事件的格子及其相邻格子的渐变色与其他格子保持一致。</p>
</blockquote>
<p>看来必须研究渐变色的代码了。另外，在目前的程序中，游戏一旦完成，点击事件的监听就被断开了，reset之后不会恢复对点击事件的监听，需要修改。</p>
<blockquote>
<p>Q:请介绍这段代码涉及的函数：<br>self.ax.imshow(gradient, aspect&#x3D;’auto’, extent&#x3D;(j, j + 1, self.N - i - 1, self.N - i),cmap&#x3D;self.cmap, alpha&#x3D;alpha)  # 绘制渐变色格子<br>Q:能否精简函数参数的介绍，尽量各用几个短语介绍<br>A:当然可以：</p>
</blockquote>
<ul>
<li><code>gradient</code>: 渐变色数组，表示从白色到指定颜色的渐变。</li>
<li><code>aspect=&#39;auto&#39;</code>: 自动调整图形的纵横比。</li>
<li><code>extent=(j, j + 1, self.N - i - 1, self.N - i)</code>: 定义图像的范围。</li>
<li><code>cmap=self.cmap</code>: 指定用于颜色映射的 colormap。</li>
<li><code>alpha=alpha</code>: 控制图像的透明度。</li>
</ul>
<p>与之前版本的代码对比，发现是这段代码的效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">distance = np.sqrt((i - self.N / <span class="number">2</span>) ** <span class="number">2</span> + (j - self.N / <span class="number">2</span>) ** <span class="number">2</span>)  <span class="comment"># 计算到网格中心的距离</span></span><br><span class="line">alpha = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(<span class="number">1</span>, distance / (self.N / <span class="number">2</span>)))  <span class="comment"># 限制 alpha 在 0 到 1 的范围内</span></span><br></pre></td></tr></table></figure>
<p>看来GPT对我的从中心到四周的渐变有些误解……估计就是alpha&#x3D;0了。调alpha有效果，但是<strong>整体很不美观</strong>。还是得<strong>试试搞好渐变色</strong>。为了不受已有代码影响，我开了新对话。<br>与GPT拉扯了许久，下面是最终有效的提问</p>
<blockquote>
<p>Q:import matplotlib.pyplot as plt<br>from matplotlib.colors import LinearSegmentedColorma 请问可以用这两个画出哪些形状的渐变色？<br>Q:如何用LinearSegmentedColorma画出一个颜色从中心开始，由深蓝向紫晶蓝渐变的矩形？<br>Q:能否改为由天蓝渐变为深蓝再渐变为紫晶蓝<br>Q:如何将现在的自定义颜色覆盖到这段代码中？ ……<br>Q:能否将# Fill in the rectangle with gradient colors<br>    for i in range(height):<br>        for j in range(width):<br>            # Calculate distance from center<br>            distance &#x3D; np.sqrt((j - center_x) ** 2 + (i - center_y) ** 2)<br>            # Normalize distance to range [0, 1]<br>            normalized_distance &#x3D; distance &#x2F; np.sqrt(center_x ** 2 + center_y ** 2)<br>            # Map normalized distance to colormap<br>            color &#x3D; cmap(normalized_distance)<br>            image[i, j] &#x3D; color<br>    return image<br>    这段代码融入。注意，目的是让每个格子都能应用到这段你代码。需要对这段代码进行一些修改。</p>
</blockquote>
<p>经过拉扯，最终的结果是这样的：012.py<br><img src="/2024/05/27/240524Filp_Game/001_002.png"><br>好歹在N值大的时候能接受吧。不过当N为偶数时会逼死强迫症，不对称。但还是想试试之前的想法。</p>
<blockquote>
<p>Q:我的意思是，每个格子都像之前的单个矩形一样，在单个格子内渐变</p>
</blockquote>
<p>拉扯失败，自己改吧。017.py是期待的效果，但效果也不好。并且那段代码(018.py)是以像素为单位的。得深刻理解。先放一放。现在就做出了可用的游戏界面。另外再修改一下移除监视的部分。回到前面的那个对话。</p>
<h4 id="reset的逻辑"><a href="#reset的逻辑" class="headerlink" title="reset的逻辑"></a>reset的逻辑</h4><blockquote>
<p>Q:现在如果游戏被完成，按reset后也无法重新开始游戏<br>A:……<br>修正坐标转换：<br>x, y &#x3D; int(event.xdata), int(self.N - event.ydata - 1)  # 获取点击位置并转换 y 坐标</p>
</blockquote>
<p>我可真谢谢你，给我改回错的版本了。把那个错误修正后，测试（020.py），现在完成后reset后仍然可以正常游戏了。<br>接下来，先添加记录步数的功能吧。代码越堆越多，可能会受到GPT输出长度限制。</p>
<blockquote>
<p>Q:能否在屏幕上显示当前玩家操作的次数；并记录玩家完成游戏的历史最小次数。<br>Q:请生成完整代码<br>Q:请继续生成<br>Q:请注意：on_click中的x, y &#x3D; int(event.xdata), int(self.N - event.ydata - 1)需改成x, y &#x3D; int(event.xdata), int(self.N - event.ydata)</p>
</blockquote>
<p>（021.py）运行过程中，文本框虽然不会被修改，但是会吸附焦点。试了一下，看起来GPT改不了(022.py)，直接把文本框改没了。先不管了。</p>
<h3 id="可解题目的生成"><a href="#可解题目的生成" class="headerlink" title="可解题目的生成"></a>可解题目的生成</h3><p>现在需求3、4已经完成了，也就是界面内容已经完成了。剩下的主要是翻转游戏游戏性的拓展。<br>需求主要有： 1. 在游戏开始时随机一到两个格子处于翻转状态；该功能应该可以选择打开或关闭；reset也应该有“重试”或“获得新题目”的区分。 2. 题解：穷举剪枝（<br>为了在生成后可获取可行解，先实现题解的生成。但“对于这样一个程序，请添加’查看题解的功能‘”在前面问貌似不符合GPT的实现逻辑。还是得先生成初始态。</p>
<blockquote>
<p>Q:能否添加一个设置菜单，其中可以选择reset后是否生成一个有两个格子被随机翻转的谜题，或是重置回目前的谜题的初始状态。</p>
</blockquote>
<h4 id="生成谜题与求解"><a href="#生成谜题与求解" class="headerlink" title="生成谜题与求解"></a>生成谜题与求解</h4><p>现在可以生成初始两个被翻转的随机谜题，但是无法重现谜题的初始版图。</p>
<blockquote>
<p>Q:勾选Randomize后，点击Reset，会生成随机的谜题（记为谜题1）；要求：  此时取消勾选Randomize，点击Reset之后，需要重现谜题1 。请进行修改 。 没有修改的代码部分不用给出。<br>GPT:<br>修改说明：<br>在类初始化方法中增加 self.random_puzzle 变量，用于存储当前生成的随机谜题状态。<br>在 reset_grid 方法中，当复选框被勾选并生成随机谜题后，将随机谜题状态存储到 self.random_puzzle。<br>在 reset_grid 方法中，当复选框未勾选时，检查 self.random_puzzle 是否不为 None，如果不为 None，恢复到上次生成的随机谜题状态，否则恢复到初始状态。<br>output:024.py （我才不会说是我忘记复制，直接把刚才那版覆盖了……）<br>这次GPT达到的我的目的，要继续修改应该比较容易。之后便是探索解集。<br>Q:能否添加一个功能：添加一个“获得答案”的按钮，按下之后可以生成答案。答案指：使得完成游戏需要点击的最少方格的各个方格的位置。用一个小的N*N板块显示。<br>output:025.py<br>Q:请给出具体的解决谜题的算法<br>output:026.py</p>
</blockquote>
<p>026.py无法处理无解的谜题，会直接报错，</p>
<blockquote>
<p>Q:Traceback (most recent call last):<br>  ……<br>TypeError: ‘NoneType’ object is not subscriptable  这有可能是因为问题无解<br>output:027.py<br>修改说明：<br>在 show_answer 方法中增加了对 solution 是否为 None 的检查。如果 solution 为 None，则打印 “No solution found.”。<br>在 solve_puzzle 方法的最后，如果没有找到解决方案，则返回 None。<br>通过这些修改，当没有解时，不会尝试显示 None，而是会输出一条消息。</p>
</blockquote>
<p>目前的界面是这样的：<br><img src="/2024/05/27/240524Filp_Game/001_003.png"><br>点击”Get Answer”按钮后:<br><img src="/2024/05/27/240524Filp_Game/001_004.png"></p>
<p>看起来，初始时若是2个格子被翻转，没有可行解。</p>
<blockquote>
<p>Q:如何修改勾选Randomize后随机翻转的格子数？能否帮我改成3？<br>A:当然可以。你需要修改 <code>randomize_grid</code> 方法，使其在勾选 <code>Randomize</code> 后翻转三个随机的格子，而不是两个。<br>这里是修改后的代码片段：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FlipGame</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, N=<span class="number">4</span></span>):</span><br><span class="line">        <span class="comment"># 初始化代码省略，保持不变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其余代码省略，保持不变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">randomize_grid</span>(<span class="params">self</span>):</span><br><span class="line">        indices = np.random.choice(self.N * self.N, <span class="number">3</span>, replace=<span class="literal">False</span>)  <span class="comment"># 选择 3 个随机的格子</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> indices:</span><br><span class="line">            x, y = index // self.N, index % self.N</span><br><span class="line">            self.grid[x, y] = <span class="keyword">not</span> self.grid[x, y]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其余代码省略，保持不变</span></span><br></pre></td></tr></table></figure>
<p>这个修改将 <code>randomize_grid</code> 方法中的 <code>np.random.choice</code> 函数的参数改为 <code>3</code>，从而选择 3 个随机格子进行翻转。其余的代码保持不变。这样，勾选 <code>Randomize</code> 后点击 <code>Reset</code> 按钮，将会有三个随机的格子被翻转。</p>
<p>通过提问，我了解了它随机初始化的逻辑。要点就是形成一个(x,y)的元组，之后通过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.grid[x, y] = <span class="keyword">not</span> self.grid[x, y]</span><br></pre></td></tr></table></figure>
<p>一句，将所有指定的坐标对于的格子翻转。理解这点后，我新建了一个对话，探讨翻转游戏的可行解。</p>
<h4 id="可行解的探索"><a href="#可行解的探索" class="headerlink" title="可行解的探索"></a>可行解的探索</h4><blockquote>
<p>Q:对于4*4的翻转游戏，什么时候有解？<br>Q:能否写出一个或多个函数，（共同）实现生成可行谜题的代码 output：029可行解.py<br>Q:这段代码运行地太慢了。能否适当剪枝？ output:030可行解.py</p>
</blockquote>
<p>现在得到了可以运行的初始谜题生成代码，原理是随机初始化点击行为：点击行为对格子状态的影响是可逆的。相比随机格子状态，这算是个生成可解谜题的好方法。<br>接下来就拿着这段代码让GPT融合。</p>
<blockquote>
<p>Q:能否将下面这段代码融入到产生初始解的函数中？原来的函数功能如有冲突，请将其覆盖。  import numpy as np…….<br>output: 031.py</p>
</blockquote>
<p>现在随机谜题的效果挺让我满意的。4*4时平均点4-5下。但修改N后，Get_Answer就崩了。</p>
<blockquote>
<p>Q:当N不等于4时，Get_Answer会崩溃。请修改生成函数或者Get_Answer函数的逻辑，使其能正常运行<br>output:032.py</p>
</blockquote>
<p>看起来，不能奢望GPT能写出解决翻转问题的代码(033.py系列)。因此032.py是暂时的可以产出4*4以内范围谜题与解决方案的程序。现在需求1、2也算是有限制地完成了（N&lt;&#x3D;4）。搞一搞UI美化吧。基于032.py版本。</p>
<blockquote>
<p>Q:这段代码的UI很丑，包括但不限于渐变色不对称且对比度大；按钮排列不规律；文本框都是由被选中的光标等等问题，请尝试进行修改，并告诉我改了什么？</p>
</blockquote>
<p>经过多次修改，UI的最终版面是这样的：<br><img src="/2024/05/27/240524Filp_Game/001_005.png"><br>最终版本03404.py<br>这个项目就先到此结束了。<br>之后看一看要不要重启。</p>
<hr>
<p>24&#x2F;6&#x2F;7<br>针对Filp_Game的解题算法，这几天做了多次搜索。理论可以暴力搜索，但是时间复杂度高（且我僵尸都打了四个多小时，真不会暴力）。我搜索到了一个解题的文章。<a href="https://www.heywhale.com/mw/project/604c6bc074dfc60016e228f1">变色方块(Flip Game)解法与可视化</a>（我真感动，时隔快一个学期，我打出的a标签还是正确格式，其实md语法是这样：<a href="https://www.heywhale.com/mw/project/604c6bc074dfc60016e228f1">变色方块(Flip Game)解法与可视化</a>）。这篇文章中利用了前人的研究，给出了使用高斯消元法对翻转问题求解的思路。我的理解是：对翻转游戏中的每一个格子都列一个线性方程，其中只自身与上下左右对应的xi置为1，’+’定义为异或。对于初始全零的初始状态，线性方程等号右边都是1。高斯消元法解线性方程组的过程，就是将矩阵化为阶梯矩阵，之后再求解。（线性代数相关内容）<br>这种数学逻辑还是得靠自己理解。GPT只有有限的数学处理能力。探索理解解题方法，也算是人不可被GPT替代的部分。<br>GPT成功帮我把求解的代码与原有程序融合。但是，只在初始全0状态时给出正确结果。经过多次提问修正，仍然不能给出能够求解有初始状态游戏的程序。<br>假定格子有0、1两种状态。翻转游戏的目标是让所有格子处于1状态。<strong>在线性方程中目标状态为1，可以理解为需要通过翻转，把对应格子的状态改变</strong>。当初始状态为全0时，<strong>所有格子都需要从0变为1</strong>，因此目标矩阵是<strong>全1的矩阵</strong>。一般情况，对于初始状态为1的格子，该<strong>格子的状态并不用改变</strong>，因此在<strong>目标矩阵的对应位置应该设置为0</strong>。极端情况，初始状态已经是全1，此时目标矩阵应该是全0，也就是要在操作后保持所有格子原有状态均不变。<br>主要涉及更改的函数如下：<br>(最终文件：107可用.py)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show_answer</span>(<span class="params">self, event</span>):</span><br><span class="line">    solution = self.solve_puzzle(self.grid)</span><br><span class="line">    <span class="keyword">if</span> solution <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.display_solution(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No solution found.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve_puzzle</span>(<span class="params">self, grid</span>):</span><br><span class="line">    n = self.N</span><br><span class="line">    a = []  <span class="comment"># 异或方程组存在这里</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建异或方程组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            d = np.zeros([n, n], np.int8)</span><br><span class="line">            d[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                d[i - <span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i != n - <span class="number">1</span>:</span><br><span class="line">                d[i + <span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j != <span class="number">0</span>:</span><br><span class="line">                d[i][j - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j != n - <span class="number">1</span>:</span><br><span class="line">                d[i][j + <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">            a.append(d.flatten())</span><br><span class="line"></span><br><span class="line">    a = np.array(a)</span><br><span class="line">    b = np.ones(n * n, np.int8)  <span class="comment"># 目标状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据初始状态修改b矩阵，若初始状态为True，则不需要改变。</span></span><br><span class="line">    <span class="comment"># 根据高斯消元法，该格子异或的结果应该为0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j]:</span><br><span class="line">                b[i * n + j] ^= <span class="number">1</span>  <span class="comment"># 可以直接置0，异或1也一样</span></span><br><span class="line"></span><br><span class="line">    a = np.hstack((a, b[:, np.newaxis]))</span><br><span class="line"></span><br><span class="line">    n2 = n * n</span><br><span class="line">    line = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 高斯消元法解异或方程组</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n2):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(line, n2):</span><br><span class="line">            <span class="keyword">if</span> a[j][k] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> a[j][k] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        temp1, temp2 = np.copy(a[j]), np.copy(a[line])</span><br><span class="line">        a[line], a[j] = temp1, temp2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(line + <span class="number">1</span>, n2):</span><br><span class="line">            <span class="keyword">if</span> a[i][k] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k, n2 + <span class="number">1</span>):</span><br><span class="line">                    a[i][j] = a[i][j] ^ a[line][j]</span><br><span class="line">        line += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n2 - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j):</span><br><span class="line">            <span class="keyword">if</span> a[i][j] == <span class="number">1</span>:</span><br><span class="line">                a[i][n2] = a[i][n2] ^ a[j][n2]</span><br><span class="line"></span><br><span class="line">    result = a[:, -<span class="number">1</span>].reshape((n, n))</span><br><span class="line">    solution_grid = np.zeros((n, n), dtype=<span class="built_in">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> result[i, j] == <span class="number">1</span>:</span><br><span class="line">                solution_grid[i, j] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> solution_grid</span><br></pre></td></tr></table></figure>

<script type="text/javascript">
function SetCwinHeight(){
  var iframeid = document.getElementById("iframeid"); //iframe id
  if (document.getElementById) {
    if (iframeid && !window.opera) {
      if (iframeid.contentDocument && iframeid.contentDocument.body.offsetHeight) {
        iframeid.height = iframeid.contentDocument.body.offsetHeight + 50;
      } else if (iframeid.Document && iframeid.Document.body.scrollHeight) {
        iframeid.height = iframeid.Document.body.scrollHeight + 50;
      }
    }
  }
}
</script>

<iframe width="100%" id="iframeid" onload="Javascript:SetCwinHeight()" scrolling="yes" height="1300" frameborder="0" src=".\test6_good.html"></iframe>

<p>附重新启动前的源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> mcolors</span><br><span class="line"><span class="keyword">from</span> matplotlib.widgets <span class="keyword">import</span> Button, TextBox, CheckButtons</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimSun&#x27;</span>, <span class="string">&#x27;Microsoft YaHei&#x27;</span>]  <span class="comment"># 设置中文字体</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlipGame</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, N=<span class="number">5</span></span>):</span><br><span class="line">        self.N = N</span><br><span class="line">        self.grid = np.zeros((N, N), dtype=<span class="built_in">bool</span>)</span><br><span class="line">        self.initial_grid = self.grid.copy()</span><br><span class="line">        self.random_puzzle = <span class="literal">None</span></span><br><span class="line">        self.colors = [(<span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1.0</span>), (<span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.8</span>)]  <span class="comment"># 调整颜色为柔和的蓝色渐变</span></span><br><span class="line">        self.cmap = mcolors.LinearSegmentedColormap.from_list(<span class="string">&#x27;custom_cmap&#x27;</span>, self.colors, N=<span class="number">256</span>)</span><br><span class="line">        self.num_moves = <span class="number">0</span></span><br><span class="line">        self.min_moves = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">        self.ax = self.fig.add_subplot(<span class="number">111</span>)  <span class="comment"># 将游戏区域的高度调整为与按钮和选项框相匹配</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调整游戏区域的位置</span></span><br><span class="line">        self.ax.set_position([<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.7</span>, <span class="number">0.8</span>])</span><br><span class="line"></span><br><span class="line">        self.textbox_moves = TextBox(plt.axes([<span class="number">0.85</span>, <span class="number">0.2</span>, <span class="number">0.1</span>, <span class="number">0.05</span>]), <span class="string">&#x27;步数:&#x27;</span>, initial=<span class="built_in">str</span>(self.num_moves))</span><br><span class="line">        self.textbox_moves.color = <span class="string">&#x27;white&#x27;</span>  <span class="comment"># 设置文本框背景颜色</span></span><br><span class="line"></span><br><span class="line">        self.textbox_min_moves = TextBox(plt.axes([<span class="number">0.85</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.05</span>]), <span class="string">&#x27;最小步数:&#x27;</span>, initial=<span class="built_in">str</span>(self.min_moves))</span><br><span class="line">        self.textbox_min_moves.color = <span class="string">&#x27;white&#x27;</span>  <span class="comment"># 设置文本框背景颜色</span></span><br><span class="line"></span><br><span class="line">        reset_ax = plt.axes([<span class="number">0.85</span>, <span class="number">0.4</span>, <span class="number">0.1</span>, <span class="number">0.075</span>])</span><br><span class="line">        self.reset_button = Button(reset_ax, <span class="string">&#x27;Reset&#x27;</span>)  <span class="comment"># 修改按钮边框颜色</span></span><br><span class="line">        self.reset_button.on_clicked(self.reset_grid)</span><br><span class="line"></span><br><span class="line">        check_ax = plt.axes([<span class="number">0.85</span>, <span class="number">0.5</span>, <span class="number">0.1</span>, <span class="number">0.1</span>])</span><br><span class="line">        self.check_button = CheckButtons(check_ax, [<span class="string">&#x27;Randomize&#x27;</span>], [<span class="literal">False</span>])</span><br><span class="line"></span><br><span class="line">        answer_ax = plt.axes([<span class="number">0.85</span>, <span class="number">0.6</span>, <span class="number">0.1</span>, <span class="number">0.075</span>])</span><br><span class="line">        self.answer_button = Button(answer_ax, <span class="string">&#x27;Get Answer&#x27;</span>)  <span class="comment"># 修改按钮边框颜色</span></span><br><span class="line">        self.answer_button.on_clicked(self.show_answer)</span><br><span class="line"></span><br><span class="line">        self.draw_grid()</span><br><span class="line"></span><br><span class="line">        self.cid = self.fig.canvas.mpl_connect(<span class="string">&#x27;button_press_event&#x27;</span>, self.on_click)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset_grid</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="keyword">if</span> self.check_button.get_status()[<span class="number">0</span>]:</span><br><span class="line">            self.grid = self.generate_solvable_puzzle()</span><br><span class="line">            self.random_puzzle = self.grid.copy()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.random_puzzle <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self.grid[:] = self.random_puzzle</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.grid[:] = self.initial_grid</span><br><span class="line"></span><br><span class="line">        self.num_moves = <span class="number">0</span></span><br><span class="line">        self.update_moves_text()</span><br><span class="line">        self.draw_grid()</span><br><span class="line">        self.cid = self.fig.canvas.mpl_connect(<span class="string">&#x27;button_press_event&#x27;</span>, self.on_click)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw_grid</span>(<span class="params">self</span>):</span><br><span class="line">        self.ax.clear()</span><br><span class="line">        self.ax.set_xticks([])</span><br><span class="line">        self.ax.set_yticks([])</span><br><span class="line">        <span class="keyword">for</span> spine <span class="keyword">in</span> self.ax.spines.values():</span><br><span class="line">            spine.set_linewidth(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.N):</span><br><span class="line">                <span class="keyword">if</span> self.grid[i, j]:</span><br><span class="line">                    color = self.calculate_color(j, i)</span><br><span class="line">                    rect = plt.Rectangle([j, self.N - i - <span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>, facecolor=color, edgecolor=<span class="string">&#x27;black&#x27;</span>, linewidth=<span class="number">1.5</span>)  <span class="comment"># 增加边框宽度</span></span><br><span class="line">                    self.ax.add_patch(rect)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    rect = plt.Rectangle([j, self.N - i - <span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>, facecolor=<span class="string">&#x27;white&#x27;</span>, edgecolor=<span class="string">&#x27;black&#x27;</span>, linewidth=<span class="number">1.5</span>)  <span class="comment"># 增加边框宽度</span></span><br><span class="line">                    self.ax.add_patch(rect)</span><br><span class="line">        self.ax.set_xlim(<span class="number">0</span>, self.N)</span><br><span class="line">        self.ax.set_ylim(<span class="number">0</span>, self.N)</span><br><span class="line">        self.ax.set_aspect(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">        self.fig.canvas.draw()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_color</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        center_x = self.N / <span class="number">2</span></span><br><span class="line">        center_y = self.N / <span class="number">2</span></span><br><span class="line">        distance = np.sqrt((x - center_x) ** <span class="number">2</span> + (y - center_y) ** <span class="number">2</span>)</span><br><span class="line">        normalized_distance = distance / np.sqrt(center_x ** <span class="number">2</span> + center_y ** <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> self.cmap(normalized_distance)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_moves_text</span>(<span class="params">self</span>):</span><br><span class="line">        self.textbox_moves.set_val(<span class="built_in">str</span>(self.num_moves))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_min_moves_text</span>(<span class="params">self</span>):</span><br><span class="line">        self.textbox_min_moves.set_val(<span class="built_in">str</span>(self.min_moves))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_click</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="keyword">if</span> event.inaxes != self.ax:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x, y = <span class="built_in">int</span>(event.xdata), <span class="built_in">int</span>(self.N - event.ydata)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Clicked at: (<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)&quot;</span>)</span><br><span class="line">        self.flip_tile(x, y)</span><br><span class="line">        self.num_moves += <span class="number">1</span></span><br><span class="line">        self.update_moves_text()</span><br><span class="line">        self.draw_grid()</span><br><span class="line">        <span class="keyword">if</span> np.<span class="built_in">all</span>(self.grid):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Congratulations! You win!&quot;</span>)</span><br><span class="line">            self.min_moves = <span class="built_in">min</span>(self.min_moves, self.num_moves)</span><br><span class="line">            self.update_min_moves_text()</span><br><span class="line">            self.fig.canvas.mpl_disconnect(self.cid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flip_tile</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]:</span><br><span class="line">            nx, ny = x + dx, y + dy</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; self.N <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; self.N:</span><br><span class="line">                self.grid[ny, nx] = <span class="keyword">not</span> self.grid[ny, nx]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_answer</span>(<span class="params">self, event</span>):</span><br><span class="line">        solution = self.solve_puzzle(self.grid)</span><br><span class="line">        <span class="keyword">if</span> solution <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.display_solution(solution)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No solution found.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve_puzzle</span>(<span class="params">self, grid, max_duration=<span class="number">5</span></span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">flip</span>(<span class="params">grid, x, y</span>):</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">0</span>)]:</span><br><span class="line">                nx, ny = x + dx, y + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; self.N <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; self.N:</span><br><span class="line">                    grid[nx, ny] = <span class="keyword">not</span> grid[nx, ny]</span><br><span class="line"></span><br><span class="line">        initial_state = grid.copy()</span><br><span class="line">        target_state = np.ones((self.N, self.N), dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">        queue = deque([(initial_state, [])])</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        start_time = time.time()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">if</span> time.time() - start_time &gt; max_duration:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Solving the puzzle took too long.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            current_grid, path = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> np.array_equal(current_grid, target_state):</span><br><span class="line">                solution_grid = np.zeros((self.N, self.N), dtype=<span class="built_in">bool</span>)</span><br><span class="line">                <span class="keyword">for</span> x, y <span class="keyword">in</span> path:</span><br><span class="line">                    solution_grid[x, y] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span> solution_grid</span><br><span class="line">            state_tuple = <span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">tuple</span>, current_grid))</span><br><span class="line">            <span class="keyword">if</span> state_tuple <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visited.add(state_tuple)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.N):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.N):</span><br><span class="line">                    new_grid = current_grid.copy()</span><br><span class="line">                    flip(new_grid, i, j)</span><br><span class="line">                    new_path = path + [(i, j)]</span><br><span class="line">                    queue.append((new_grid, new_path))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display_solution</span>(<span class="params">self, solution</span>):</span><br><span class="line">        fig, ax = plt.subplots()</span><br><span class="line">        ax.set_xticks([])</span><br><span class="line">        ax.set_yticks([])</span><br><span class="line">        <span class="keyword">for</span> spine <span class="keyword">in</span> ax.spines.values():</span><br><span class="line">            spine.set_linewidth(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.N):</span><br><span class="line">                <span class="keyword">if</span> solution[i, j]:</span><br><span class="line">                    rect = plt.Rectangle([j, self.N - i - <span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>, facecolor=<span class="string">&#x27;red&#x27;</span>, edgecolor=<span class="string">&#x27;black&#x27;</span>, linewidth=<span class="number">1.5</span>)  <span class="comment"># 增加边框宽度</span></span><br><span class="line">                    ax.add_patch(rect)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    rect = plt.Rectangle([j, self.N - i - <span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>, facecolor=<span class="string">&#x27;white&#x27;</span>, edgecolor=<span class="string">&#x27;black&#x27;</span>, linewidth=<span class="number">1.5</span>)  <span class="comment"># 增加边框宽度</span></span><br><span class="line">                    ax.add_patch(rect)</span><br><span class="line">        ax.set_xlim(<span class="number">0</span>, self.N)</span><br><span class="line">        ax.set_ylim(<span class="number">0</span>, self.N)</span><br><span class="line">        ax.set_aspect(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_solvable_puzzle</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">flip</span>(<span class="params">board, i, j</span>):</span><br><span class="line">            n = <span class="built_in">len</span>(board)</span><br><span class="line">            board[i, j] ^= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                board[i - <span class="number">1</span>, j] ^= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; n - <span class="number">1</span>:</span><br><span class="line">                board[i + <span class="number">1</span>, j] ^= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                board[i, j - <span class="number">1</span>] ^= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; n - <span class="number">1</span>:</span><br><span class="line">                board[i, j + <span class="number">1</span>] ^= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        n = self.N</span><br><span class="line">        board = np.zeros((n, n), dtype=<span class="built_in">bool</span>)</span><br><span class="line"></span><br><span class="line">        num_flips = np.random.randint(<span class="number">1</span>, n * n + <span class="number">1</span>)</span><br><span class="line">        flips = np.random.choice(n * n, num_flips, replace=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> flip_index <span class="keyword">in</span> flips:</span><br><span class="line">            i, j = <span class="built_in">divmod</span>(flip_index, n)</span><br><span class="line">            flip(board, i, j)</span><br><span class="line">        <span class="keyword">return</span> board</span><br><span class="line"><span class="comment"># 创建和显示游戏界面</span></span><br><span class="line">flip_game = FlipGame()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>GPT</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期桌游个人推荐（假期结束板）</title>
    <url>/2024/08/20/240820boardgame-reccommend02/</url>
    <content><![CDATA[<p>介绍一下这几天新尝试的桌游</p>
<p>由于时间限制，主要只聊两个近期玩了也赢了五场以上的游戏。</p>
<p>两个游戏分别是：<br>超级巨大幸运盒子（supermegaluckybox） 与 夏洛特13（SHERLOCK13）<br>游戏类型分别是 骰写、运气 与 策略、逻辑、运气</p>
<h2 id="超级巨大幸运盒子（supermegaluckybox）"><a href="#超级巨大幸运盒子（supermegaluckybox）" class="headerlink" title="超级巨大幸运盒子（supermegaluckybox）"></a>超级巨大幸运盒子（supermegaluckybox）</h2><p>这个游戏也<strong>比较热门</strong>。个人认为<strong>上手门槛低，上限中等，有一定的深度</strong>。</p>
<p>和前面介绍的乐队游戏（也是我在BGA上竞技场世界排名截图时第2的游戏）一样，都是<strong>骰写游戏</strong>。<br><strong>骰写，就是指根据获得的卡牌（通常获得哪些卡牌具有一定随机性，像投骰子一样），划掉相应位置的格子。主要决策就是你要划哪个格子。骰写的游戏属性在这个游戏中尤为凸显。</strong></p>
<p>简单介绍一下<strong>游戏规则</strong>：开局选三个幸运盒子。每一轮结束补充一个盒子，共四轮。<br>每轮会随机抽数字卡牌，好像每个数字同一回合最多出现两次。（英语表述挺有问题，但人家听懂了:)，给大家看个笑话吧）</p>
<p><img src="/2024/08/20/240820boardgame-reccommend02/001the_chat.png" alt="001the_chat" title="001the_chat"></p>
<p><img src="/2024/08/20/240820boardgame-reccommend02/002_select_boxes.png" alt="002_select_boxes" title="002_select_boxes"></p>
<p><strong>完成一行一列可以获得幸运盒子上的奖励（如果有的话）</strong>，数字代表立刻划去指定数字的一个格子；？则可以任意选择；闪电则是获得对应数量的闪电（<strong>可以使用闪电，让数字+-1后再划格子，可以同时使用多个闪电，1、9之间只用一个闪电</strong>）；<strong>一轮内获得一个星星+1.两个+4，三个+9，再多无效果</strong>；游戏结束时，<strong>拥有最多月亮数玩家分数+6，最少月亮数-6</strong>，<strong>若并列则一起加（或减）</strong>。<strong>分数相同时看月亮数，月亮数多获胜</strong>。</p>
<p><img src="/2024/08/20/240820boardgame-reccommend02/003_action_example.png" alt="003_action_example" title="003_action_example"></p>
<p>在不同轮完成幸运盒子，<strong>有四档不同分数奖励</strong>，结束时场面上的<strong>未完成盒子每划掉两格加1分</strong>（安慰奖）。</p>
<p><img src="/2024/08/20/240820boardgame-reccommend02/004_scores_example.png" alt="004_scores_example" title="004_scores_example"></p>
<p>这算是一个<strong>比较轻松的决策游戏</strong>。<strong>只用有选盒子和划格子的思考</strong>。虽然<strong>很看运气</strong>。但<strong>决策水平高低差距在场次多的情况下还是比较明显</strong>的。<strong>行列的划额外数字的奖励也可以达成combo</strong>，在一回合完成多个幸运盒子。<strong>（玩法上，3星星收益比当轮完成盒子还高，不过要是月亮太少，待会就被拉回12分的分差；闪电太少，最后一轮可能会多次被迫无法行动）</strong></p>
<h2 id="SHERLOCK13-夏洛特13"><a href="#SHERLOCK13-夏洛特13" class="headerlink" title="SHERLOCK13 夏洛特13"></a>SHERLOCK13 夏洛特13</h2><p>十三张侦探小说相关的角色牌，其中的十二张平均分给所有玩家（1V1除外），抢先通过询问确定剩下的角色的玩家获胜。</p>
<p>回合的行动规则：<br>轮到你的时候，你<strong>必须</strong>选择调查<strong>或</strong>指控。</p>
<p>调查<br>调查分为2种方式：</p>
<ol>
<li>指定一个图标，询问所有其他玩家是否有该图标，拥有图标的玩家举手。发问的玩家无需举手，<strong>你无法知道举手的玩家有几个图标</strong>。</li>
<li><strong>选择一位玩家并指定一个图标，询问该玩家拥有几个该图标</strong>。</li>
</ol>
<p>指控<br>指控一个角色并检查是否犯人，若是，你立即获胜。否则，你出局，其余玩家继续游戏，你仍然可以被其他玩家调查。</p>
<p>在两人局，还有一个将手牌与安置牌交换的操作。由于我1V1只玩了一局，在这里就不提了。后面都是基于三人及以上的人数。</p>
<p><img src="/2024/08/20/240820boardgame-reccommend02/011_solo_interface.png" alt="011_solo_interface" title="011_solo_interface"></p>
<p>《夏洛特13》这个游戏是将13张卡牌中抽出一张作为凶手牌，凶手的身份牌均分给场上各位玩家。各位玩家通过询问操作，争取第一个猜出那张被拿出去的卡牌对应的角色是谁。</p>
<p>相比同类游戏，比如《逻辑对决》和《13道线索》，《夏洛特13》与《逻辑对决》有些相似之处。所有玩家需要猜的是同一张（一组）牌到底是什么。而《13道线索》则是每个玩家猜自己头上被暗示的那3张牌是什么，这些牌对其他玩家是可见的。因此<strong>相比《13道线索》，《夏洛特13》中各位玩家的信息差会小一些，难度也会小一些。</strong></p>
<p>我觉得这个游戏还是一个创造信息差的游戏。你需要通过已有的线索，争取在不过多帮助其他玩家判断的同时，给自己争取出判断正确凶手的独有优势。一个特别优秀的操作是在时机允许的时候，通过一个巧妙的提问，结合自己的已有视角，去直接检验一张或多张牌是否是凶手。即便不是，也不会给其他玩家过多信息；如果是，就可以利用信息差的优势，在下一轮中直接指控。</p>
<p>由于玩家在一个行动中不能同时调查与指控，如果调查行动帮助对手获取了排除范围的决定信息，对手就可以在你之前正确指控，直接获胜。因此要玩好这个游戏，需要考虑对手的视角。</p>
<p>对于我的个人体验来说，<strong>在游戏过程中可以考虑各位玩家选择提问类型的思路</strong>。比如，当你持有的标记数量较少时，你会去问关于标记特定数量的问题。而当你拥有大量标记时，你会选择问其他玩家是否有标记，因为其他玩家大概率处于有一个或没有的状态。这种样子的提问能够更快地缩减“凶手”的范围，还能创造与其它玩家的信息差，为自己创造优势。</p>
<p>通过这种逻辑，<strong>可以通过其他玩家给出的提问类型，猜测他们手中对应标记的数量</strong>。这也是<strong>在迫不得已时</strong>，其他玩家要猜出来时，<strong>抢先进行多选一阻断的重要线索</strong>。不过，对我而言，这类游戏很容易赢得有思路，但输得不明不白。这种输得不明不白的感觉会导致游戏体验非常差，特别是在每局游戏后，如果不进行复盘或复盘不明白的话，很容易陷入负面体验，觉得这游戏根本玩不好。这也是这类游戏的一个缺点。</p>
<p>当然，我之前有一种想法，稍微消除这种体验，就是在自己线下玩的时候立一个村规。村规要求，其他玩家可以知道自己要猜的那三张牌是什么，直接在线下宣告，然后由其他玩家给出答复。最终，当所有玩家都已经猜出自己的牌时，在游戏中让第一个猜对的人获胜。</p>
<p>下面是对一局游戏的分析。也算是复盘吧。这局三人游戏在第九个行动就结束了。虽然结束了，但是有猜的成分，并不能通过逻辑严谨证明犯人100%是那个角色。</p>
<p><img src="/2024/08/20/240820boardgame-reccommend02/012_game_example_interface.png" alt="012_game_example_interface" title="012_game_example_interface"></p>
<p>游戏开始时，紫色玩家为起始玩家，先询问了其它玩家有没有灯泡。<br>灯泡的询问结果是 0 (绿) _(紫) √(蓝)   （紫色玩家问的，所以紫色玩家处无信息）</p>
<p>接着蓝色玩家询问其它玩家有没有拳头。<br>拳头的的询问结果是 √ (绿) √_(紫) _(蓝)</p>
<p>我认为灯泡图标，我的”0”应该会让其它两位玩家对彼此的灯泡数量很感兴趣，所以我先问其它信息。按照“问其它玩家有没有，大概率是2+”的逻辑，问了蓝色拳头的数量，问出了1。这时局面就很尴尬了，有可能是对紫色玩家的优势局面（若紫色的拳头数是3，则拳头全部排除）。</p>
<p>之后紫色蓝色玩家互问灯泡的数量。得知灯泡的分布数量是0 3 2。凶手没有灯泡标识。</p>
<p>此时紫色玩家由于灯泡3，拳头2+，所以他一定有夏洛克·福尔摩斯这个人物。（只有这个人物同时有灯泡和拳头，如果没有手牌数至少为5，超出4的上限了，所以这个人物只能在他手里）。但这又匪夷所思：他有拳头+灯泡的组合，还去问灯泡，这对排除拳头没有帮助。<br>我一头雾水，胆战心惊地询问紫色玩家警徽的数量（如果紫色玩家拳头数量为2，那么他离胜利是最近的，是三选一）</p>
<p>紫色玩家询问了其它玩家骷髅的数量。现在灯泡已经确定不是凶手了，剩下一张没有灯泡的骷髅牌带力量图标。也就是说紫色玩家的行动在排除力量。紫色玩家如果有3个力量，在他的视角力量是3 1 1，已经排除嫌疑了，这个行动会是个无意义的行动。假设紫色玩家的行动有意义，那么他手上一定只有两个力量标记，视角是√ 2 1，力量仍未排除。同时，由于紫色玩家在排除 塞巴斯蒂安·莫兰 这个人物的嫌疑，因此这个人物要么在蓝色玩家手里，要么就是凶手。（不过我玩的时候只觉得凶手多半在力量里，紫色玩家至少一张骷髅牌）</p>
<p>蓝色玩家选择了询问我警徽的数量。他在排警徽。（当时混沌地觉得他不排骷髅估计就是有骷髅+力量了）</p>
<p>最后到我行动。我场上玩时认为对手已经能猜了，用尽剩下两三分钟的思考时间来决定指控哪位角色。我觉得骷髅+力量在蓝色手里，想在剩下两个警徽里二选一。又有为啥其它玩家都不问书的想法，赌带书标记的在其它玩家手里，二选一选到了正确答案。如果我不猜，得赌别人不猜或猜错才有机会了。</p>
<p><img src="/2024/08/20/240820boardgame-reccommend02/013_game_example_action_lists.png" alt="013_game_example_action_lists" title="013_game_example_action_lists"></p>
]]></content>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期桌游个人推荐（假期中期板）</title>
    <url>/2024/07/29/boardgame-reccommend01/</url>
    <content><![CDATA[<p>涉及游戏列表：</p>
<p>Mojo： 跟UNO像但不一样的打牌游戏<br>Cat In the Box 薛定谔的猫<br>Can’t stop 欲罢不能<br>Draft &amp; Write Records 组建乐队与创作唱片</p>
<p>假期已经快要过半了，大家都在干什么呢？<br>我最近经常在BGA上玩桌游 <a href="https://boardgamearena.com/?sp=1khg9j">https://boardgamearena.com/?sp=1khg9j</a> ，最近尝试了几个此前没有玩过的桌游。这篇动态&#x2F;博客主要分享一下新玩的比较感兴趣的四个桌游。</p>
<h2 id="Mojo：-休闲的类UNO游戏"><a href="#Mojo：-休闲的类UNO游戏" class="headerlink" title="Mojo： 休闲的类UNO游戏"></a>Mojo： 休闲的类UNO游戏</h2><p>单局时长一般是十几二十分钟。<br>与UNO类似，当有人“出完牌”时，计算手里剩余卡牌的点数总和，进行下一轮。当有人的点数累加到50时就立刻结束。<br>其中没有功能牌，只有出牌的选项。在你的回合里，出的牌比弃牌堆上的牌大得重抽一张牌并结束回合，相等则继续出牌，小则直接结束回合。在计分时，相同颜色（都是紧挨着的数字）的牌只记最大数字。另外若回合结束后手牌只有三张以下，则不能再出牌，等待轮次进行结算。触发结算的玩家如果数字点数之和不是最小的（之一），要额外加10分，是最小的则不加分。<br>Mojo算是比较休闲的牌类游戏，有一定策略性，但很好上手。两个弃牌堆的拓展增强了策略性，略微削弱运气成分。</p>
<p><img src="/2024/07/29/boardgame-reccommend01/001.png" alt="001" title="001"></p>
<h2 id="Cat-In-the-Box-盒中猫：薛定谔的猫，有趣新颖的策略游戏"><a href="#Cat-In-the-Box-盒中猫：薛定谔的猫，有趣新颖的策略游戏" class="headerlink" title="Cat In the Box 盒中猫：薛定谔的猫，有趣新颖的策略游戏"></a>Cat In the Box 盒中猫：薛定谔的猫，有趣新颖的策略游戏</h2><p>（只有会员可以创建房间，非会员只能搜索加入已有房间）</p>
<p><img src="/2024/07/29/boardgame-reccommend01/002.png" alt="002" title="002"></p>
<p>新颖点1：在一轮开始时，需要预测自己这轮能吃到的墩数，只有在回合结束时正好吃到对应墩数，才能获得额外奖励分（奖励分等于棋子连接的最大数量，斜向连接不算）<br>新颖点2：手中牌只有数字，牌的颜色由玩家宣告。但是，如果宣称自己没有某个颜色（从而在如蓝色为基本色的回合宣告出红色的猫），之后的便不能违反这个宣告（不能宣告自己出的猫是蓝色）。（吃墩优先级 红色&gt;基本色，优先级相同看数字大小，大的吃墩，下回合从吃墩者开始。）<br>新颖点3：每个数字的猫都有5只，除去当轮开始时弃的1张与最后剩的1张，剩下的数量正好把所有格子填满。如果某位玩家宣告出现了悖论（无法符合规则地出任何一张手牌），该轮立刻结束，该玩家倒扣该轮吃的墩数，并且得不到奖励分。 只要有意驱使，悖论是不可避免的。</p>
<p>个人游戏体验，如果想不垫底，往死里防自己悖论，与此同时尽量吃到奖励分，再不行多吃墩。一般蓝绿黄各自第一次做基本色时，没人会起红色的，第二次基本一定有人起红色，如果想吃墩要注意。<br>上面的图片直接展示了悖论是什么样的。该玩家先前已经宣告自己没有黄色、蓝色、红色，对于数字3和8，只有蓝色的3和红色的8没被宣告过，若宣告这两，则与先前的宣告违背，形成悖论。下一次轮到他时就宣告产生悖论，该轮结束了。</p>
<h2 id="Can’t-stop-欲罢不能"><a href="#Can’t-stop-欲罢不能" class="headerlink" title="Can’t stop 欲罢不能"></a>Can’t stop 欲罢不能</h2><p>这个是很经典的赌狗游戏。胜利是属于运气好和胆大的人的。<br>投四个骰子，骰子两两组合，数字相加则为可走的路线。一位玩家一回合中最多能同时走三条路线。掷出后必须选择路线前进。如果掷出的点数无法组成三条路线中的任意一条，你这回合内的进度全部丢失。你可以选择不断重投，一回合内投15次，也可以及时收手，保留已有的攀登进度。先占到三个山头的玩家获胜。</p>
<p><img src="/2024/07/29/boardgame-reccommend01/003.png" alt="003" title="003"></p>
<p>我的评价是：撑死胆大的，饿死胆小的。别人都听牌了，此时不博下回直接游戏结束，没得博了。但还是要服从概率。56789可以连投七八次，要是是4 10 12什么的，除非劣势大，还是收了吧。（上面这图，两轮结束了，只有绿色有进度，其它两人开局爆炸了）<br>不过我玩着玩着越来越感觉胜利永远是属于赌狗的。</p>
<p><img src="/2024/07/29/boardgame-reccommend01/004.png" alt="004" title="004"><br>👇<br><img src="/2024/07/29/boardgame-reccommend01/005.png" alt="005" title="005"><br>👇<br><img src="/2024/07/29/boardgame-reccommend01/006.png" alt="006" title="006"><br>👇<br><img src="/2024/07/29/boardgame-reccommend01/007.png" alt="007" title="007"><br>👇<br><img src="/2024/07/29/boardgame-reccommend01/008.png" alt="008" title="008"><br>绿色表示：我的前期优势呢？蓝色你*****</p>
<h2 id="Draft-Write-Records-组建乐队与创作唱片"><a href="#Draft-Write-Records-组建乐队与创作唱片" class="headerlink" title="Draft &amp; Write Records 组建乐队与创作唱片"></a>Draft &amp; Write Records 组建乐队与创作唱片</h2><p>规则吓人但玩得还好的骰写策略游戏，一局二十五到四十分钟<br>下面这张大图是截码战群里的一位群友写的教程。但要纠正一个关键的已知的错误：<br>游戏目标中，并不是“1个月”，至少在3人局中一共有7周。第7周会使用前面几周没被使用的牌。</p>
<p><img src="/2024/07/29/boardgame-reccommend01/009.jpg" alt="009" title="009"></p>
<h3 id="原文本：（翻译：现在认知更新了，可以看新的）"><a href="#原文本：（翻译：现在认知更新了，可以看新的）" class="headerlink" title="原文本：（翻译：现在认知更新了，可以看新的）"></a>原文本：（翻译：现在认知更新了，可以看新的）</h3><p>如果开局奔着日程的×3×4去，最好赶紧通过招募齐乐队成员，在第四五周或第六周前两个行动赶紧把乐队成员招满，提前结束游戏。如果日程和提升勾掉的多，后期一个行动触发一波combo直接加几十分的。不这样rush的话，小心其他人一个行动直接把你分数优势抹平+反超。另外要是第四周或五周前两个行动就rush（得有任务奖励支撑）的话，其他人大概率都会扣满20分（游戏结束时每缺一个乐队成员要打一个×，左上角，打满五个最后扣20分），优势更大。<br>在所有公共任务都不好完成时，可以考虑主提升副日程，有成员羁绊就放成员，利用乐谱（正下方）与提升的巡演标记，沿着右上的路线走，吃掉路线上的25分（主要路上有专辑，并且第二张专辑给的奖励是巡演标记，可以快速推进，在rush的同时快速拿巡演的高分）。<br>不过要是运气太差，可以选的成员构不成羁绊，可能计划就破产了。这种玩法要拿第一，乐谱那里也得拿分，估计得划至少一横一竖。</p>
<p>公共任务好完成的话，很有可能会是完成6个任务导致游戏结束。运气好抢任务在四周直接完成6个，其它分数支持一下排名就稳定靠前了。（算分时注意乐队成员不满的扣分）。要注意的是，如果已经完成了6个任务，即使当周你还有已完成的任务，都不再能宣告任务完成了。</p>
<p>对于任务奖励，越是打到五六周（后期），划掉任一一个提升的奖励就能引起越多combo。前期自己完成了提升奖励的个人任务，可以留着等后面宣告。</p>
<h3 id="240820："><a href="#240820：" class="headerlink" title="240820："></a>240820：</h3><p>成功在某一时刻拿到了这个游戏竞技场的世界第二。</p>
<p>策略主要是<strong>如何与对手争抢公共任务</strong>，在<strong>进行分析后做出抉择</strong>。</p>
<p><strong>公共任务是必须争</strong>的，甚至想着<strong>“独占”</strong>任务，获得奖励和分数优势。拉不开优势也别被落下。</p>
<p>个人任务的宣告服务于公共任务，如果其奖励于公共任务无关，你暂时也不需要，<strong>可以选择不宣告个人目标</strong>。<strong>但要注意当周游戏是否结束了</strong>，不要弄巧成拙。</p>
<p>卡牌的选取还是看自己的理解。特别是主唱这个数量应该较少的特殊乐队成员，早放下去很容易与后面的音乐家构成和声，对手可能会由于你的<strong>拦截</strong>迟迟拿不到主唱。</p>
<p>一般还是<strong>多板块联动</strong>，由于现金限制开局没法动巡演板块。但<strong>后期巡演板块能带来很高的分数上限</strong>。</p>
<p><strong>尽量把游戏结束的机会握在手里。如果没有结束游戏的机会，至少也要留有争上限的机会。</strong></p>
]]></content>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot中WebSocket的连接 笔记</title>
    <url>/2024/10/31/WebSocketNote/</url>
    <content><![CDATA[<h1 id="SpringBoot中WebSocket的连接-笔记"><a href="#SpringBoot中WebSocket的连接-笔记" class="headerlink" title="SpringBoot中WebSocket的连接 笔记"></a>SpringBoot中WebSocket的连接 笔记</h1><h2 id="1-WebSocket前端调用"><a href="#1-WebSocket前端调用" class="headerlink" title="1. WebSocket前端调用"></a>1. WebSocket前端调用</h2><p>在我的 Vue3 Vite 前端中，WebSocket 的调用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">socket.<span class="property">value</span> = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">`<span class="subst">$&#123;<span class="keyword">import</span>.meta.env.VITE_WEBSOCKET_URL&#125;</span>/<span class="subst">$&#123;questionRoomId.value&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<p>其中，涉及的环境变量的定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VITE_WEBSOCKET_URL=ws://localhost:8080/ws</span><br></pre></td></tr></table></figure>

<p>当前端执行 <code>new WebSocket(url)</code> 时，浏览器会尝试与指定的 WebSocket 服务器建立连接。</p>
<p>WebSocket 使用 HTTP 协议进行初始的握手过程。浏览器会发送一个 HTTP 请求，包含特定的头信息来请求建立 WebSocket 连接。服务器接收到这个请求后，会返回一个带有 HTTP 状态码 101（切换协议）的响应，表示同意建立 WebSocket 连接。一旦服务器确认了请求，连接就建立成功。此时，浏览器和服务器之间可以进行双向通信。</p>
<p>可以通过监听 WebSocket 的事件（如 <code>onopen</code>、<code>onmessage</code>、<code>onclose</code> 和 <code>onerror</code>）来处理连接的状态和数据。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">socket.<span class="property">value</span>.<span class="property">onopen</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket connection established&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.<span class="property">value</span>.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message from server:&#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-后端对WebSocket连接的处理"><a href="#2-后端对WebSocket连接的处理" class="headerlink" title="2. 后端对WebSocket连接的处理"></a>2. 后端对WebSocket连接的处理</h2><p>在 Spring Boot 的后端，<code>WebSocketConfig</code> 实现了 <code>WebSocketConfigurer</code> 接口，通过实现其方法 <code>registerWebSocketHandlers(WebSocketHandlerRegistry registry)</code> 来定义和注册 WebSocket 端点。此方法通过 <code>registry.addHandler()</code> 关联 WebSocket 端点 URL 和消息处理器，指定前端 WebSocket 请求的接入路径。Spring 会在应用启动时自动调用此方法，完成 WebSocket 端点的配置，使后端能够在前端请求时自动接收并处理 WebSocket 连接。</p>
<h3 id="2-1-WebSocket端点的配置"><a href="#2-1-WebSocket端点的配置" class="headerlink" title="2.1 WebSocket端点的配置"></a>2.1 WebSocket端点的配置</h3><p>对该方法中 <code>registry.addHandler(new WebSocketHandler(), &quot;/ws/&#123;roomId&#125;&quot;).setAllowedOrigins(&quot;*&quot;);</code> 的实现逻辑进行分析：</p>
<ul>
<li><p><code>registry.addHandler</code> 中的第一个参数 <code>new WebSocketHandler()</code> 表示自定义的 WebSocketHandler 实现类，包含处理 WebSocket 消息的逻辑，该类需要实现 <code>WebSocketHandler</code> 接口。</p>
</li>
<li><p>第二个参数 <code>&quot;/ws/&#123;roomId&#125;&quot;</code> 指定 WebSocket 端点的 URL 模式。前端可以通过这个 URL 与后端建立 WebSocket 连接。其中 <code>&#123;roomId&#125;</code> 是路径变量，允许在 URL 中动态指定。例如，<code>/ws/123</code> 会为房间 ID 为 123 的房间创建连接。</p>
</li>
<li><p><code>setAllowedOrigins(&quot;*&quot;)</code> 用于设置跨域请求的来源，允许哪些源可以访问该 WebSocket 端点。<code>&quot;*&quot;</code> 表示允许所有来源进行跨域连接。<code>setAllowedOrigins</code> 可指定多个具体的域名（如 <code>http://example.com</code>），以控制 WebSocket 的跨域访问权限。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addHandler(<span class="keyword">new</span> <span class="title class_">WebSocketHandler</span>(), <span class="string">&quot;/ws/&#123;roomId&#125;&quot;</span>).setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-WebSocket连接建立"><a href="#3-WebSocket连接建立" class="headerlink" title="3. WebSocket连接建立"></a>3. WebSocket连接建立</h2><p>在 WebSocket 连接建立时，Spring 框架会自动创建并传递 <code>session</code> 参数（Spring 框架创建了一个新的代表与特定客户端连接的 <code>WebSocketSession</code> 实例，并回调 <code>WebSocketHandler</code> 中的 <code>afterConnectionEstablished</code> 方法，将新创建的 <code>WebSocketSession</code> 作为参数传入）。接下来分析 <code>WebSocketHandler</code> 中的 <code>afterConnectionEstablished</code> 方法，我在项目中的实现如下。在我定义的方法中，我将 <code>roomId</code> 存储到了 <code>session</code> 的属性中。</p>
<h3 id="3-1-WebSocketSession对象信息"><a href="#3-1-WebSocketSession对象信息" class="headerlink" title="3.1 WebSocketSession对象信息"></a>3.1 WebSocketSession对象信息</h3><p><code>session</code> 是 <code>WebSocketSession</code> 对象，它本身包含的重要信息如下：</p>
<ul>
<li><strong>会话 ID</strong>：通过 <code>getId()</code> 获取唯一标识每个连接的 ID。</li>
<li><strong>URI 和路径</strong>：<ul>
<li><code>getUri()</code>: 获取连接的 URI，用于解析请求来源和路径参数。</li>
<li><code>getUri().getPath()</code>: 可提取动态路径变量（如 <code>&#123;roomId&#125;</code>）。</li>
</ul>
</li>
<li><strong>属性</strong>：<code>getAttributes()</code> 返回一个 <code>Map&lt;String, Object&gt;</code>，用于存储与会话相关的任意数据（如我存储的房间 ID）。</li>
<li><strong>连接状态</strong>：<code>isOpen()</code> 检查连接是否有效。</li>
<li><strong>消息处理</strong>：使用 <code>sendMessage(TextMessage message)</code> 向客户端发送消息。</li>
<li><strong>用户信息</strong>：<code>getPrincipal()</code>（如有安全性设置）可获取代表连接用户的 Principal 对象。</li>
<li><strong>连接时间</strong>：可用于获取连接时间或最后活动时间（具体取决于实现）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">roomId</span> <span class="operator">=</span> session.getUri().getPath().split(<span class="string">&quot;/&quot;</span>)[<span class="number">2</span>];</span><br><span class="line">    session.getAttributes().put(<span class="string">&quot;roomId&quot;</span>, roomId);  <span class="comment">// 存储 roomId</span></span><br><span class="line">    System.out.println(<span class="string">&quot;连接建立：房间 ID = &quot;</span> + roomId + <span class="string">&quot;, 会话 ID = &quot;</span> + session.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-消息处理与广播"><a href="#4-消息处理与广播" class="headerlink" title="4. 消息处理与广播"></a>4. 消息处理与广播</h2><p>在重写的 <code>handleTextMessage</code> 方法中，通过 <code>session</code> 获取了 <code>roomId</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String) session.getAttributes().get(<span class="string">&quot;roomId&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>另外，在 <code>ConnectionManager</code> 的 <code>broadcastToConnections(String roomId, Map&lt;String, Object&gt; message)</code> 方法（用于广播信息）中，利用 <code>session</code> 广播的信息。下面这个循环，对 <code>Room</code> 对象 <code>room</code> 中的 <code>private List&lt;WebSocketSession&gt; connections</code> 进行遍历，遍历房间中的所有 WebSocket 连接，若连接开放则发送文本格式消息到连接的客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (WebSocketSession connection : room.getConnections()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (connection.isOpen()) &#123;</span><br><span class="line">            connection.sendMessage(<span class="keyword">new</span> <span class="title class_">TextMessage</span>(messageJson));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace(); <span class="comment">// 处理异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接建立之后，当客户端通过 WebSocket 发送消息时，<code>handleTextMessage(WebSocketSession session, TextMessage message)</code> 方法被调用。默认情况下，<code>handleTextMessage</code> 方法会直接接收并处理 <code>TextMessage</code> 对象。这个对象包含了客户端发送的文本内容。但是默认实现不会执行任何操作，处理过程的异常也不会被传递给客户端，只会在控制台中捕获记录。</p>
<p>在我的 Vue3 前端中，创建的 WebSocket 对象存储在 <code>socket.value</code> 中，发送信息的形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getLatestAnswers</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> requestData = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;get_latest_answers&#x27;</span>,</span><br><span class="line">        <span class="attr">questionerId</span>: playerId.<span class="property">value</span></span><br><span class="line">    &#125;;</span><br><span class="line">    socket.<span class="property">value</span>.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(requestData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我重写的 <code>handleTextMessage</code> 方法中，接收到的消息被解析并根据消息类型调用相应的逻辑。具体的类型定义与解析方法根据自己定义的信息结构实现。对于上面这个信息，依据逻辑会进入分支：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;get_latest_answers&quot;</span>:</span><br><span class="line">    manager.getLatestAnswers(roomId);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>并在我实现的 <code>manager</code> 对象中实现相关逻辑。（<code>manager</code> 是我自定义的 <code>ConnectionManager</code> 对象实例，不涉及 WebSocket 相关接口的继承，用于处理信息）</p>
<h2 id="5-WebSocket连接关闭"><a href="#5-WebSocket连接关闭" class="headerlink" title="5. WebSocket连接关闭"></a>5. WebSocket连接关闭</h2><p>在 WebSocket 应用中，<code>afterConnectionClosed(WebSocketSession session, CloseStatus status)</code> 方法会在 WebSocket 连接被关闭时自动执行。具体来说，它会在以下几种情况下被调用：</p>
<ul>
<li><p><strong>正常关闭</strong>：</p>
<ul>
<li>客户端或服务器通过调用 <code>session.close()</code> 显式关闭连接。</li>
</ul>
</li>
<li><p><strong>意外关闭</strong>：</p>
<ul>
<li>连接由于网络问题、浏览器关闭、页面刷新等原因而意外关闭。</li>
</ul>
</li>
<li><p><strong>超时</strong>：</p>
<ul>
<li>服务器端检测到某种超时条件（如未发送消息）后关闭连接。</li>
</ul>
</li>
</ul>
<p>对于项目来说，需要在连接关闭后妥善处理连接信息。在我的项目代码中，涉及到房间中存储 WebSocket 连接的 List 对象的相关删除操作，以及玩家信息的处理操作。</p>
]]></content>
      <categories>
        <category>major</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>A*解决八数码问题</title>
    <url>/2024/11/12/241112A-%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Astars算法的基本思想是：<br>定义合适的代价函数gx和启发式函数hx，当gx和hx都满足条件时，Astars算法就可以保证得到最优解。<br>我对状态的定义如下：<br>状态由名为Node的结构体表示，其中包含一个三行三列的二维数组A，A中0的坐标x0、y0，Astars算法相关的fx、gx、hx参数组成。<br>gx意味到达该状态移动的次数，hx为启发式函数，这里设定为不在位的数字的数量，这个条件从不高估从节点x到目标节点的实际代价。八数字中的0表示空位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> A[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> x0;</span><br><span class="line">    <span class="type">int</span> y0;</span><br><span class="line">    <span class="type">int</span> gx;</span><br><span class="line">    <span class="type">int</span> hx; <span class="comment">// 其实不用存</span></span><br><span class="line">    <span class="type">int</span> fx;</span><br><span class="line">    <span class="type">bool</span> visited;<span class="comment">// 最后版本无用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(Node* existNode) &#123;</span><br><span class="line">        <span class="comment">// 复制已有对象</span></span><br><span class="line">        <span class="keyword">if</span> (existNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;A[i][j] = existNode-&gt;A[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;x0 = existNode-&gt;x0;</span><br><span class="line">            <span class="keyword">this</span>-&gt;y0 = existNode-&gt;y0;</span><br><span class="line">            <span class="keyword">this</span>-&gt;gx = existNode-&gt;gx;</span><br><span class="line">            <span class="keyword">this</span>-&gt;hx = existNode-&gt;hx;</span><br><span class="line">            <span class="keyword">this</span>-&gt;fx = existNode-&gt;fx;</span><br><span class="line">            <span class="keyword">this</span>-&gt;visited = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Node</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;A[i][j] = i + j * <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;gx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;hx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;fx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;visited = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行过程中，现对初始状态进行判断，若不是目标状态，进行Astars算法（调用search函数）。先通过x0,y0定位0的位置，进行状态拓展（expand函数，根据当前状态复制一个node，然后调整相关参数，包括移动的两个数字，0的坐标，fx gx hx)。之后通过排序算法选取fx最小的状态，进行判断。<br>这个过程中涉及到两个关键问题：一是如何避免产生重复的状态，二是排序的效率问题（代码通过洛谷的相应题目进行检验，排序效率过低会Time Limit Exceed）。</p>
<p>对于“如何避免产生重复状态”的问题，8数码问题可以用字符串区分不同状态的字符串。采用同一种方式给各个状态编码。我在Node类内定义了一个序列化函数serialize()，将当前状态的数组转换为一个字符串。额外使用unordered_set对转换后的序列进行哈希存储。当要拓展新状态时，查找unordered_set对象中，是否有与新状态序列化的结果相同的序列。查找到则不拓展这个状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;string&gt; visitedStates;</span><br><span class="line">Node* newNode = <span class="built_in">expand</span>(x + <span class="number">1</span>, y, current, B);</span><br><span class="line"><span class="keyword">if</span> (visitedStates.<span class="built_in">find</span>(newNode-&gt;<span class="built_in">serialize</span>()) == visitedStates.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    nodeQueue.<span class="built_in">push</span>(newNode);</span><br><span class="line">    visitedStates.<span class="built_in">insert</span>(newNode-&gt;<span class="built_in">serialize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对于“排序的效率问题”，我先在忽略效率问题的前提下，采用了O(n)的遍历策略。之后（现版本）采用了std标准库中的priority_queue，自定义了CompareNode进行元素优先级的比较。具体定义为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;Node*, vector&lt;Node*&gt;, CompareNode&gt; nodeQueue;</span><br></pre></td></tr></table></figure>

<p>Node<em>表示容器中包含的元素类型为Node</em>；vector&lt;Node*&gt;为优先队列的容器模板；CompareNode为自定义的比较逻辑，不实现时默认使用std::less创造最大堆。我们这里要使fx最小的排最前面，优先取出，因此用Node1-&gt;fx &gt; Node2-&gt;fx。具体定义为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareNode</span> &#123;</span><br><span class="line">    <span class="comment">// priority_queue默认会调用std::less，最终构成最大堆</span></span><br><span class="line">    <span class="comment">// 当定义比较器为 CompareNode 且 CompareNode::operator() 返回 true 时，</span></span><br><span class="line">    <span class="comment">// priority_queue 会认为第一个参数比第二个参数优先级低，因此不会把它放在堆顶</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node* a, Node* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;fx &gt; b-&gt;fx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>各个元素在被取出后从优先队列中删除。<br>另外，虽然行列的设置只要统一，行列反了也不影响，如果反了，就是在对矩阵转置，目标状态和当前状态对应的两个矩阵都会转置，在解题逻辑中没有影响。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后要获取0的位置</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> A[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> x0;</span><br><span class="line">    <span class="type">int</span> y0;</span><br><span class="line">    <span class="type">int</span> gx;</span><br><span class="line">    <span class="type">int</span> hx; <span class="comment">// 其实不用存</span></span><br><span class="line">    <span class="type">int</span> fx;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(Node* existNode) &#123;</span><br><span class="line">        <span class="comment">// 复制已有对象</span></span><br><span class="line">        <span class="keyword">if</span> (existNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;A[i][j] = existNode-&gt;A[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>-&gt;x0 = existNode-&gt;x0;</span><br><span class="line">            <span class="keyword">this</span>-&gt;y0 = existNode-&gt;y0;</span><br><span class="line">            <span class="keyword">this</span>-&gt;gx = existNode-&gt;gx;</span><br><span class="line">            <span class="keyword">this</span>-&gt;hx = existNode-&gt;hx;</span><br><span class="line">            <span class="keyword">this</span>-&gt;fx = existNode-&gt;fx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Node</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;A[i][j] = i + j * <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;gx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;hx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;fx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化状态为一个字符串，用于哈希集合存储</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                s += <span class="built_in">to_string</span>(A[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareNode</span> &#123;</span><br><span class="line">    <span class="comment">// priority_queue默认会调用&lt;，最终构成最大堆</span></span><br><span class="line">    <span class="comment">// 当定义比较器为 CompareNode 且 CompareNode::operator() 返回 true 时，</span></span><br><span class="line">    <span class="comment">// priority_queue 会认为第一个参数比第二个参数优先级低，因此不会把它放在堆顶</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node* a, Node* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;fx &gt; b-&gt;fx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compareMap</span><span class="params">(Node* node, <span class="type">int</span> target[<span class="number">3</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 比较</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 由于数组插入的差异，二者横纵相反</span></span><br><span class="line">            <span class="keyword">if</span> (target[i][j] != <span class="number">0</span> &amp;&amp; node-&gt;A[i][j] != target[i][j]) &#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">expand</span><span class="params">(<span class="type">int</span> tx, <span class="type">int</span> ty, Node* node, <span class="type">int</span> target[<span class="number">3</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(node);</span><br><span class="line">    newNode-&gt;A[node-&gt;x0][node-&gt;y0] = newNode-&gt;A[tx][ty];</span><br><span class="line">    newNode-&gt;A[tx][ty] = <span class="number">0</span>;</span><br><span class="line">    newNode-&gt;x0 = tx;</span><br><span class="line">    newNode-&gt;y0 = ty;</span><br><span class="line">    newNode-&gt;gx = node-&gt;gx + <span class="number">1</span>; <span class="comment">// 步数加一</span></span><br><span class="line">    newNode-&gt;hx = <span class="built_in">compareMap</span>(newNode, target);</span><br><span class="line">    newNode-&gt;fx = newNode-&gt;gx + newNode-&gt;hx;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(Node* node, <span class="type">int</span> target[<span class="number">3</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始状态非目标状态，开始搜索</span></span><br><span class="line">    priority_queue&lt;Node*, vector&lt;Node*&gt;, CompareNode&gt; nodeQueue;</span><br><span class="line">    unordered_set&lt;string&gt; visitedStates;</span><br><span class="line"></span><br><span class="line">    nodeQueue.<span class="built_in">push</span>(node);</span><br><span class="line">    visitedStates.<span class="built_in">insert</span>(node-&gt;<span class="built_in">serialize</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!nodeQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* current = nodeQueue.<span class="built_in">top</span>();</span><br><span class="line">        nodeQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">compareMap</span>(current, target) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> current-&gt;gx;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = current-&gt;x0;</span><br><span class="line">        <span class="type">int</span> y = current-&gt;y0;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Node* newNode = <span class="built_in">expand</span>(x + <span class="number">1</span>, y, current, target);</span><br><span class="line">            <span class="keyword">if</span> (visitedStates.<span class="built_in">find</span>(newNode-&gt;<span class="built_in">serialize</span>()) == visitedStates.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                nodeQueue.<span class="built_in">push</span>(newNode);</span><br><span class="line">                visitedStates.<span class="built_in">insert</span>(newNode-&gt;<span class="built_in">serialize</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">delete</span> newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Node* newNode = <span class="built_in">expand</span>(x - <span class="number">1</span>, y, current, target);</span><br><span class="line">            <span class="keyword">if</span> (visitedStates.<span class="built_in">find</span>(newNode-&gt;<span class="built_in">serialize</span>()) == visitedStates.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                nodeQueue.<span class="built_in">push</span>(newNode);</span><br><span class="line">                visitedStates.<span class="built_in">insert</span>(newNode-&gt;<span class="built_in">serialize</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">delete</span> newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Node* newNode = <span class="built_in">expand</span>(x, y + <span class="number">1</span>, current, target);</span><br><span class="line">            <span class="keyword">if</span> (visitedStates.<span class="built_in">find</span>(newNode-&gt;<span class="built_in">serialize</span>()) == visitedStates.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                nodeQueue.<span class="built_in">push</span>(newNode);</span><br><span class="line">                visitedStates.<span class="built_in">insert</span>(newNode-&gt;<span class="built_in">serialize</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">delete</span> newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Node* newNode = <span class="built_in">expand</span>(x, y - <span class="number">1</span>, current, target);</span><br><span class="line">            <span class="keyword">if</span> (visitedStates.<span class="built_in">find</span>(newNode-&gt;<span class="built_in">serialize</span>()) == visitedStates.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                nodeQueue.<span class="built_in">push</span>(newNode);</span><br><span class="line">                visitedStates.<span class="built_in">insert</span>(newNode-&gt;<span class="built_in">serialize</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">delete</span> newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除当前结点</span></span><br><span class="line">        <span class="keyword">delete</span> current;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 理论上不会到这，未找到解决方案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node* initS = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="type">char</span> temp = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;<span class="comment">//行循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;<span class="comment">//列循环</span></span><br><span class="line">            <span class="comment">//cin &gt;&gt; initS-&gt;A[i][j];</span></span><br><span class="line">            cin &gt;&gt; temp;</span><br><span class="line">            initS-&gt;A[i][j] = (<span class="type">int</span>)temp - (<span class="type">int</span>)<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (initS-&gt;A[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                initS-&gt;x0 = i;</span><br><span class="line">                initS-&gt;y0 = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洛谷题中定义的状态</span></span><br><span class="line">    <span class="type">int</span> C[<span class="number">9</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">// 其实用数组预定义后，由于用i+3*j访问数组，遍历先后顺序都是一样的赋值情况。</span></span><br><span class="line">    <span class="type">int</span> B2[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// i是行，j是列</span></span><br><span class="line">            B2[i][j] = C[<span class="number">3</span> * i + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initS-&gt;gx = <span class="number">0</span>;</span><br><span class="line">    initS-&gt;hx = <span class="built_in">compareMap</span>(initS, B2);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">search</span>(initS, B2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>major</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>241122论文阅读</title>
    <url>/2024/11/22/241122%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>论文代码阅读——手打版</p>
<p>论文链接：</p>
<p>github仓库链接：<br><a href="https://github.com/qingzhenduyu/TAMER">https://github.com/qingzhenduyu/TAMER</a></p>
<p>这里会更多地关注该项目用到的模型架构和训练流程。</p>
<p>从 <code>tamer</code> 文件夹中的 <code>lit_tamer.py</code> 开始阅读。</p>
<p>在 <code>class LitTAMER(pl.LightningModule)</code> 中，定义了模型为 <code>self.tamer_model = TAMER(...)</code>，并定义了 <code>self.exprate_recorder = ExpRateRecorder()</code>。</p>
<p>TAMER 模型（<code>tamer.py</code>）由 <code>Encoder(encoder.py)</code> 和 <code>Decoder(decoder.py)</code> 组成。在定义的 <code>beam_search</code> 函数中，除了 <code>self.encoder</code>，还调用了 <code>self.decoder.beam_search</code>。</p>
<p>关于 <code>beam_search</code>，下面是 GPT 对它的介绍：</p>
<details>
<summary>点击查看 Beam Search 的详细介绍</summary>

<h3 id="Beam-Search-的原理与方法"><a href="#Beam-Search-的原理与方法" class="headerlink" title="Beam Search 的原理与方法"></a><strong>Beam Search 的原理与方法</strong></h3><h4 id="1-Beam-Search-是什么？"><a href="#1-Beam-Search-是什么？" class="headerlink" title="1. Beam Search 是什么？"></a>1. <strong>Beam Search 是什么？</strong></h4><p>Beam Search 是一种序列解码算法，通常用于自然语言生成任务（如机器翻译、文本摘要、图像字幕生成等）。它在逐步生成序列时，不是只选择一个最优候选，而是维护一个固定大小的候选集合，从中寻找全局最优的生成结果。</p>
<hr>
<h4 id="2-核心思想"><a href="#2-核心思想" class="headerlink" title="2. 核心思想"></a>2. <strong>核心思想</strong></h4><ul>
<li><p><strong>扩展搜索树</strong>：<br>将序列生成问题看作树的扩展，每次扩展节点时，基于模型预测的概率，选择前几个（如 beam size &#x3D; 3）概率最高的候选。</p>
</li>
<li><p><strong>权衡搜索空间和效率</strong>：<br>相比贪婪搜索（一次只保留最优路径），Beam Search 能探索更多路径，避免局部最优；相比暴力穷举（尝试所有可能路径），它限制了搜索宽度，提升效率。</p>
</li>
</ul>
<hr>
<h4 id="3-工作流程"><a href="#3-工作流程" class="headerlink" title="3. 工作流程"></a>3. <strong>工作流程</strong></h4><p>以下是逐步生成序列的过程：</p>
<ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>起始标记（如 <code>&lt;SOS&gt;</code>）作为初始序列，分数为 0。</li>
<li>初始化候选集合（称为 Beam），大小为 <code>beam_size</code>。</li>
</ul>
</li>
<li><p><strong>扩展 Beam</strong>：</p>
<ul>
<li>对当前 Beam 中的每个序列，用模型预测下一个词的概率分布。</li>
<li>将每个候选序列与其可能的扩展（即词）组合，计算总得分。</li>
<li>保留总得分最高的 <code>beam_size</code> 个候选序列。</li>
</ul>
</li>
<li><p><strong>终止条件</strong>：</p>
<ul>
<li>所有候选序列都生成了终止标记 <code>&lt;EOS&gt;</code>。</li>
<li>或生成的序列长度达到预设最大值 <code>max_len</code>。</li>
</ul>
</li>
<li><p><strong>输出结果</strong>：</p>
<ul>
<li>从最终的候选集合中，选择分数最高的序列作为输出。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-关键公式"><a href="#4-关键公式" class="headerlink" title="4. 关键公式"></a>4. <strong>关键公式</strong></h4><p><strong>总得分计算</strong>：<br>[<br>\text{Score} &#x3D; \frac{\sum_{t&#x3D;1}^L \log P(y_t | y_{1:t-1})}{L^\alpha}<br>]</p>
<ul>
<li>( L )：序列长度。</li>
<li>( \alpha )：长度惩罚系数（( \alpha &gt; 0 ) 时，惩罚短序列）。</li>
</ul>
<p><strong>长度惩罚的作用</strong>：</p>
<ul>
<li>防止模型过于偏向短序列（短序列的得分累积更高）。</li>
<li>调整模型对不同长度的偏好。</li>
</ul>
<h4 id="5-优势与不足"><a href="#5-优势与不足" class="headerlink" title="5. 优势与不足"></a>5. <strong>优势与不足</strong></h4><ul>
<li><p><strong>优势</strong>：</p>
<ul>
<li>在可接受的计算开销下，生成质量较高的序列。</li>
<li>能发现更优解，避免陷入局部最优。</li>
</ul>
</li>
<li><p><strong>不足</strong>：</p>
<ul>
<li>生成的序列仍可能不是全局最优（近似搜索）。</li>
<li>Beam Size 过大会显著增加计算量。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-与-TAMER-的关系"><a href="#6-与-TAMER-的关系" class="headerlink" title="6. 与 TAMER 的关系"></a>6. <strong>与 TAMER 的关系</strong></h4><p>在 TAMER 中：</p>
<ul>
<li><p><strong>Encoder</strong>：<br>提取图像特征，作为解码器的上下文信息。</p>
</li>
<li><p><strong>Decoder 的 Beam Search</strong>：</p>
<ul>
<li>使用解码器 <code>beam_search</code>，根据编码器输出的特征，逐步生成序列。</li>
<li>每个时间步中扩展候选序列，保留 <code>beam_size</code> 个得分最高的序列，直到生成完成。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-Beam-Search-的改进方向"><a href="#7-Beam-Search-的改进方向" class="headerlink" title="7. Beam Search 的改进方向"></a>7. <strong>Beam Search 的改进方向</strong></h4><ul>
<li><strong>加速优化</strong>：采用动态 Beam Size 或并行化实现，减少计算负担。</li>
<li><strong>多样性增强</strong>：引入随机性（如 Top-K 或采样）来生成更具多样性的候选序列。</li>
<li><strong>混合方法</strong>：结合贪婪搜索和 Beam Search，平衡速度与质量。</li>
</ul>
<hr>
</details><br>

<p>Encoder中，主要使用了<code>DenseNet-B</code>的架构。给出的can项目代码的encoder也使用到了 <code>DenseNet-B</code>。</p>
<p>笔记图片<img src="/2024/11/22/241122%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/DenseNet-B.jpg" alt="DenseNet-B"></p>
<p>Decoder中，使用到了<code>Transformer 解码器</code>以及结构相似性计算模块（<code>StructSim</code>）等组件。其中对Transformer相关部分的定义调用了<code>Transformer</code>文件夹中封装的encoder 、decoder等。</p>
<details>
<summary>点击查看 GPT对 Decoder.py 的详细介绍</summary>


<h3 id="decoder-py-的模块和主要原理"><a href="#decoder-py-的模块和主要原理" class="headerlink" title="decoder.py 的模块和主要原理"></a><code>decoder.py</code> 的模块和主要原理</h3><p><code>decoder.py</code> 定义了 <strong>Decoder</strong> 模块，该模块实现了目标序列生成的核心功能，使用了 <strong>Transformer 解码器</strong>、结构相似性计算模块（<code>StructSim</code>）等组件。以下是各模块及其原理的详细解释：</p>
<hr>
<h4 id="1-主要组件和功能"><a href="#1-主要组件和功能" class="headerlink" title="1. 主要组件和功能"></a>1. <strong>主要组件和功能</strong></h4><h5 id="1-LBR-Linear-BatchNorm-ReLU"><a href="#1-LBR-Linear-BatchNorm-ReLU" class="headerlink" title="(1) LBR (Linear + BatchNorm + ReLU)"></a>(1) <strong>LBR (Linear + BatchNorm + ReLU)</strong></h5><ul>
<li>模块定义：<ul>
<li>线性变换 + 层归一化（LayerNorm）+ 激活函数（ReLU）。</li>
</ul>
</li>
<li>功能：作为一种轻量的预处理单元，对输入进行简单变换，增强非线性表达能力。</li>
</ul>
<h5 id="2-StructSim-和-StructSimOneDir"><a href="#2-StructSim-和-StructSimOneDir" class="headerlink" title="(2) StructSim 和 StructSimOneDir"></a>(2) <strong>StructSim 和 StructSimOneDir</strong></h5><ul>
<li>模块定义：<ul>
<li><code>StructSim</code> 包含两个方向的相似性计算模块：<strong>从左到右（l2r）</strong>和<strong>从右到左（r2l）</strong>。</li>
<li>每个方向使用 <code>TransformerEncoder</code> 提取表示，并通过 <code>q + k</code> 的方式计算结构相似性。</li>
</ul>
</li>
<li>功能：<ul>
<li><strong>结构相似性计算</strong>：用来评估序列在目标方向上的一致性，确保生成序列结构合理。</li>
<li>输出一个矩阵，表示目标序列内部的相似性分布。</li>
</ul>
</li>
</ul>
<h5 id="3-build-transformer-decoder"><a href="#3-build-transformer-decoder" class="headerlink" title="(3) _build_transformer_decoder"></a>(3) <strong>_build_transformer_decoder</strong></h5><ul>
<li>模块定义：<ul>
<li>基于 <code>nn.TransformerDecoder</code>，结合 <code>AttentionRefinementModule</code>（ARM）进一步增强解码器性能。</li>
</ul>
</li>
<li>功能：<ul>
<li><strong>ARM 模块</strong>：通过自监督（self-coverage）或交叉覆盖（cross-coverage）的方式，改善注意力权重的分布，从而生成更加准确的序列。</li>
<li><strong>Transformer 解码器层</strong>：实现目标序列的生成逻辑。</li>
</ul>
</li>
</ul>
<h5 id="4-Decoder-类"><a href="#4-Decoder-类" class="headerlink" title="(4) Decoder 类"></a>(4) <strong>Decoder 类</strong></h5><ul>
<li>主要模块：<ul>
<li>**词嵌入 (word_embed)**：将目标序列的单词 ID 映射为向量表示。</li>
<li>**位置编码 (pos_enc)**：通过 <code>WordPosEnc</code> 为嵌入添加位置信息。</li>
<li>**Transformer 解码器 (model)**：通过多层 Transformer 解码序列。</li>
<li>**输出投影 (proj)**：将解码结果映射回词汇表空间，输出每个单词的概率分布。</li>
<li>**结构相似性模块 (struct_sim)**：通过 <code>StructSim</code> 评估解码器的输出序列。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-主要原理"><a href="#2-主要原理" class="headerlink" title="2. 主要原理"></a>2. <strong>主要原理</strong></h4><p>Decoder 模块采用 <strong>Transformer 解码器</strong> 的架构，结合目标任务需求，增加了结构相似性和注意力优化模块。以下是核心原理：</p>
<h5 id="1-Transformer-解码器"><a href="#1-Transformer-解码器" class="headerlink" title="(1) Transformer 解码器"></a>(1) <strong>Transformer 解码器</strong></h5><ul>
<li>解码器由多层堆叠的解码器层组成，每一层包括：<ul>
<li>**自注意力机制 (Self-Attention)**：关注目标序列已生成部分的内部关系。</li>
<li>**交叉注意力机制 (Cross-Attention)**：关注输入特征（图片编码）与目标序列之间的关系。</li>
<li>**前馈网络 (Feedforward Neural Network)**：对注意力结果进一步提取非线性特征。</li>
</ul>
</li>
<li>解码器通过 mask 限制模型只能看到当前时间步之前的输出。</li>
</ul>
<h5 id="2-ARM-Attention-Refinement-Module"><a href="#2-ARM-Attention-Refinement-Module" class="headerlink" title="(2) ARM (Attention Refinement Module)"></a>(2) <strong>ARM (Attention Refinement Module)</strong></h5><ul>
<li>通过调整注意力权重的分布，解决：<ul>
<li><strong>自监督问题</strong>（自注意力的权重集中问题）。</li>
<li><strong>交叉覆盖问题</strong>（输入特征未充分利用问题）。</li>
</ul>
</li>
</ul>
<h5 id="3-结构相似性"><a href="#3-结构相似性" class="headerlink" title="(3) 结构相似性"></a>(3) <strong>结构相似性</strong></h5><ul>
<li><code>StructSim</code> 模块引入两种相似性度量：<ul>
<li>从左到右生成的结构是否合理。</li>
<li>从右到左生成的结构是否一致。</li>
</ul>
</li>
<li>通过 Transformer Encoder 学习表示，并通过加和查询 (<code>q</code>) 和键 (<code>k</code>) 的方式计算相似性。</li>
</ul>
<h5 id="4-目标序列生成过程"><a href="#4-目标序列生成过程" class="headerlink" title="(4) 目标序列生成过程"></a>(4) <strong>目标序列生成过程</strong></h5><ol>
<li><strong>词嵌入和位置编码</strong>：目标序列转换为向量，并加入位置信息。</li>
<li><strong>Transformer 解码</strong>：<ul>
<li>自注意力机制理解序列上下文。</li>
<li>交叉注意力与图片特征交互。</li>
</ul>
</li>
<li><strong>输出预测</strong>：通过全连接层输出词汇表上的概率分布。</li>
<li><strong>相似性评估</strong>：计算生成序列的结构一致性，提供额外的监督信号。</li>
</ol>
<hr>
<h4 id="3-函数解析"><a href="#3-函数解析" class="headerlink" title="3. 函数解析"></a>3. <strong>函数解析</strong></h4><p>以下是模块主要函数及其功能：</p>
<h5 id="Decoder-forward"><a href="#Decoder-forward" class="headerlink" title="Decoder.forward"></a><strong><code>Decoder.forward</code></strong></h5><ul>
<li>输入：图片特征（<code>src</code>）、目标序列（<code>tgt</code>）。</li>
<li>输出：词汇表概率分布（<code>out</code>）和结构相似性（<code>sim</code>）。</li>
<li>过程：<ol>
<li>对目标序列 <code>tgt</code> 进行词嵌入和位置编码。</li>
<li>构造目标序列的掩码（<code>tgt_mask</code> 和 <code>tgt_pad_mask</code>）。</li>
<li>使用 Transformer 解码器处理 <code>tgt</code> 和 <code>src</code>。</li>
<li>计算目标序列的结构相似性。</li>
<li>投影到词汇表空间输出概率分布。</li>
</ol>
</li>
</ul>
<h5 id="Decoder-build-attention-mask"><a href="#Decoder-build-attention-mask" class="headerlink" title="Decoder._build_attention_mask"></a><strong><code>Decoder._build_attention_mask</code></strong></h5><ul>
<li>构造一个<strong>因果掩码</strong>，确保生成序列时只能看到当前时间步之前的内容。</li>
</ul>
<h5 id="Decoder-transform"><a href="#Decoder-transform" class="headerlink" title="Decoder.transform"></a><strong><code>Decoder.transform</code></strong></h5><ul>
<li>封装 <code>forward</code>，专用于生成任务的调用，接收图片特征和输入 ID。</li>
</ul>
<hr>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. <strong>总结</strong></h4><p><code>decoder.py</code> 实现了一个面向图文序列生成任务的解码器，核心特点包括：</p>
<ol>
<li><strong>Transformer 架构</strong>：高效处理序列生成任务。</li>
<li><strong>ARM 和结构相似性模块</strong>：解决注意力分布不均和生成结构不一致问题。</li>
<li><strong>多功能设计</strong>：支持训练和推理过程（如 <code>beam search</code>）。</li>
</ol>
</details><br>


<details>
<summary>某人偷懒没修改的pos_enc.py功能简介</summary>
这段代码定义了几种**位置编码（Positional Encoding）**方法，主要用于为输入特征添加位置信息，从而在模型中保留顺序或空间信息。这些编码方式被应用在不同类型的数据上，如序列数据（单词）或二维图像数据。

<h3 id="功能分类"><a href="#功能分类" class="headerlink" title="功能分类"></a>功能分类</h3><ol>
<li><p><strong>基于正弦和余弦的绝对位置编码</strong>：</p>
<ul>
<li>**<code>WordPosEnc</code>**：<ul>
<li>实现了用于序列输入（如文本）的标准正弦和余弦位置编码。</li>
<li>被用于给序列特征（形状 <code>[b, l, d]</code>）添加位置感知信息。</li>
</ul>
</li>
<li>**<code>ImgPosEnc</code>**：<ul>
<li>将绝对位置编码扩展到二维图像特征，处理形状 <code>[b, h, w, d]</code> 的输入。</li>
<li>通过累积mask反转计算生成二维位置坐标，并添加正弦和余弦的编码值。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基于旋转变换的相对位置编码（Rotary Positional Embedding）</strong>：</p>
<ul>
<li>**<code>WordRotaryEmbed</code>**：<ul>
<li>应用于序列输入，结合正弦和余弦，通过旋转操作实现相对位置编码。</li>
<li>提供更灵活的位置感知能力，适合更复杂的上下文关联建模。</li>
</ul>
</li>
<li>**<code>ImageRotaryEmbed</code>**：<ul>
<li>处理二维图像特征，支持旋转的二维位置编码。</li>
<li>类似于<code>WordRotaryEmbed</code>，但扩展到二维输入（形状 <code>[b, h, w, d]</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>工具函数</strong>：</p>
<ul>
<li>**<code>rotate_every_two</code>**：实现二维旋转，用于旋转嵌入的偶数和奇数维度的值。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="在前述代码中的调用"><a href="#在前述代码中的调用" class="headerlink" title="在前述代码中的调用"></a>在前述代码中的调用</h3><p>这些位置编码模块被用在以下地方：</p>
<ul>
<li>**<code>Decoder</code> 类中的 <code>self.pos_enc</code>**：<ul>
<li><code>WordPosEnc</code> 用于对目标序列（<code>tgt</code>）添加位置编码，以增强 Transformer 解码器对序列顺序的感知。</li>
</ul>
</li>
<li><strong>可能的其他调用场景</strong>（未直接展示）：  <ul>
<li>对图像或序列数据进行位置编码（如<code>ImgPosEnc</code>或<code>ImageRotaryEmbed</code>）可在编码器或解码器的预处理阶段使用，尤其是在 CAN 项目中对图像-文本跨模态任务可能需要的场景。</li>
</ul>
</li>
</ul>
<p>总结：这段代码提供了多种灵活的位置编码方案，可根据输入数据的维度和模型需求灵活选择合适的方法，以增强输入的位置信息表达能力。</p>
</details><br>


<p>对于transformer文件夹，里面包含了支持AttentionRefinementModule（注意力精细化模块）的transformer解码器，也包含MaskBatchNorm2d（自定义掩码批标准化）、AttentionRefinementModule（注意力精细化模块）、MultiheadAttention（多头注意力模块）的具体实现。</p>
<p><code>utils</code> 文件夹是 “utilities”（工具）的缩写，通常在其中存放封装好的各个辅助功能或工具函数。</p>
<details>
<summary>某人偷懒没修改的pos_enc.py功能简介</summary>
</details><br>]]></content>
  </entry>
  <entry>
    <title>250105QuizArena</title>
    <url>/2025/01/05/250105QuizArena/</url>
    <content><![CDATA[<p>期末了，到了对所做项目进行归档的时间。<br>此项目为”在线答题游戏“，github仓库链接：<a href="https://github.com/MYS109hqj/QuizArena">https://github.com/MYS109hqj/QuizArena</a><br>java后端的websocket笔记，可见名为<code>WebSocketNote</code>的博客。<br>该项目开发的安排比较分散，截止25&#x2F;1&#x2F;5 16:56，暂没有汇总开发目标、以及过程（设计、debug等方面）笔记。</p>
<p>本篇博客只展示项目在version1.5版本的效果，并基于个人部署实践，给出了在服务器上部署该答题游戏项目的部署流程。</p>
<h2 id="项目效果展示"><a href="#项目效果展示" class="headerlink" title="项目效果展示"></a>项目效果展示</h2><p><img src="/2025/01/05/250105QuizArena/001.png"><br><img src="/2025/01/05/250105QuizArena/002.png"><br><img src="/2025/01/05/250105QuizArena/003.png"><br><img src="/2025/01/05/250105QuizArena/004.png"><br><img src="/2025/01/05/250105QuizArena/005.png"><br><img src="/2025/01/05/250105QuizArena/006.png"><br><img src="/2025/01/05/250105QuizArena/007.png"></p>
<h2 id="java后端版本的服务器部署流程"><a href="#java后端版本的服务器部署流程" class="headerlink" title="java后端版本的服务器部署流程"></a>java后端版本的服务器部署流程</h2><p>服务器环境：CentOS7 （linux系统）</p>
<h3 id="以使用windows的主机辅助为例"><a href="#以使用windows的主机辅助为例" class="headerlink" title="以使用windows的主机辅助为例"></a>以使用windows的主机辅助为例</h3><p>（提醒：本项目的前端是基于Vite的Vue3，而非基于cli，二者有一定差别）</p>
<p>在本机配置好node.js环境，在<code>/java_backend/frontend</code>目录中，创建<code>.env.production</code>文件，用于配置生产环境下的环境变量（本项目中用于设置服务器IP地址）。<br>在<code>.env.production</code>文件中输入以下内容。（将server_ip_address替换为服务器的ip地址）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VITE_WEBSOCKET_URL=ws://server_ip_address:8080/ws</span><br></pre></td></tr></table></figure>

<p>之后，仍然在<code>/java_backend/frontend</code>目录，进入控制台（cmd），输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<p>完成对前端项目的构建。生成我们需要的前端静态文件，所需的文件位于<code>dist</code>文件夹中。</p>
<p>对于后端，服务器只需要生成的jar文件。如果我有直接发送jar文件的话，可以直接使用。<br>在<code>/java_backend/frontend</code>目录，进入控制台，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>
<p>若构建成功，JAR文件会生成在项目目录中的target文件夹中。文件名由<code>pox.xml</code>中的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>backend<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>参数决定。（如上述示例下，生成jar文件的文件名是<code>backend-0.0.1-SNAPSHOT</code>）</p>
<p>如果直接使用git clone克隆仓库，或者在linux系统操作，具体的运行命令可能会有差别，目标仍是在添加<code>.env.production</code>后生成dist中的前端静态文件以及后端的JAR文件。</p>
<p>在生成后，将dist文件夹以及JAR文件上传到服务器。记录好dist文件夹所在的文件路径。</p>
<p>在本示例中，使用到nginx作为反向代理。这里假设已经配置好了nginx。</p>
<p>在CentOS中，Nginx配置文件的默认路径为<code>/etc/nginx/nginx.conf</code>，站点配置文件路径在<code>/etc/nginx/conf.d/</code>下，在此文件中直接存储站点配置文件，如创建<code>quiz_Arena.conf</code>。<br>由于后端使用到了websocket，在配置文件中需要做相应配置。示例配置文件如下：（请注意修改server_name与location&#x2F;{}中的root）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 监听端口 80（HTTP 默认端口）</span><br><span class="line">    listen 80; </span><br><span class="line">    # 将 &#x27;your_server_ip_or_domain&#x27; 替换为你的服务器 IP 或域名</span><br><span class="line">    server_name your_server_ip_or_domain;</span><br><span class="line"></span><br><span class="line">    # 静态文件服务</span><br><span class="line">    location / &#123;</span><br><span class="line">        # 将 &#x27;your_dist_path&#x27; 替换为dist文件夹的的实际部署路径</span><br><span class="line">        root your_dist_path;</span><br><span class="line">        index index.html;</span><br><span class="line">        try_files $uri $uri/ /index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # WebSocket 代理</span><br><span class="line">    location /ws &#123;</span><br><span class="line">        proxy_pass http://localhost:8080;  # WebSocket 服务监听的后端地址</span><br><span class="line">        proxy_http_version 1.1;           # 确保使用 HTTP/1.1 以支持 Upgrade 机制</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line"></span><br><span class="line">        # 防止 WebSocket 超时</span><br><span class="line">        proxy_read_timeout 3600s;</span><br><span class="line">        proxy_send_timeout 3600s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 防止静态文件和 WebSocket 路径冲突</span><br><span class="line">    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|otf|eot|ttc|map)$ &#123;</span><br><span class="line">        root /var/www/quiz_Arena/vue/dist;</span><br><span class="line">        expires 1M;         # 设置浏览器缓存时间</span><br><span class="line">        access_log off;     # 关闭日志记录（减少性能开销）</span><br><span class="line">        try_files $uri =404;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后更新nginx的配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nginx -t  # 检查配置文件语法</span><br><span class="line">sudo systemctl reload nginx  # 重新加载配置</span><br></pre></td></tr></table></figure>
<p>在确认nginx拥有对dist文件夹的访问权限后，前端大概率可以正常运行。</p>
<p>对于后端，假设JAR文件的文件名为<code>backend-0.0.1-SNAPSHOT</code>。进入JAR文件所在目录，你可以输入以下指令，让后端在后台运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -jar backend-0.0.1-SNAPSHOT.jar &gt; output.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>后端的输出将会写入到同目录中的output.log文件。<br>查看output.log，确认后端正常启动。</p>
<p>nginx配置完毕，后端正常运行，项目在服务器上的部署也就完成了。祝你有良好的游戏体验！</p>
<p>如果你要关闭后端进程，可以使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux | grep java</span><br><span class="line">kill &lt;PID&gt; # 将&lt;PID&gt;替换为你想要关闭的Java进程的进程ID</span><br></pre></td></tr></table></figure>
<p><code>ps aux | grep java</code>会列出所有包含”java”关键字的进程。输出中会包含进程ID（PID），将输出的PID替换掉上述命令中的<code>&lt;PID&gt;</code>即可正常关闭进程。</p>
<p>如果在配置nginx的过程中遇到了错误，在CentOS7的环境下，可以输入以下指令查看日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -n 50 /var/log/nginx/error.log</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>major</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>250303前端复健记录-附录</title>
    <url>/2025/03/03/250303%E5%89%8D%E7%AB%AF%E5%A4%8D%E5%81%A5%E8%AE%B0%E5%BD%95-%E9%99%84%E5%BD%95/</url>
    <content><![CDATA[<h2 id="提问01：-html的css中可以添加注释吗？javascript部分呢？（单独两问）"><a href="#提问01：-html的css中可以添加注释吗？javascript部分呢？（单独两问）" class="headerlink" title="提问01： html的css中可以添加注释吗？javascript部分呢？（单独两问）"></a>提问01： html的css中可以添加注释吗？javascript部分呢？（单独两问）</h2><p>是的，在HTML和CSS中都可以添加注释。</p>
<h4 id="在HTML中添加注释"><a href="#在HTML中添加注释" class="headerlink" title="在HTML中添加注释"></a>在HTML中添加注释</h4><p>HTML注释使用 <code>&lt;!--</code> 和 <code>--&gt;</code> 包裹，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是一个HTML注释 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="在CSS中添加注释"><a href="#在CSS中添加注释" class="headerlink" title="在CSS中添加注释"></a>在CSS中添加注释</h4><p>CSS注释使用 <code>/*</code> 和 <code>*/</code> 包裹，例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这是一个CSS注释 */</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>在 JavaScript (JS) 中也可以添加注释。JavaScript 支持两种注释方式：<strong>单行注释</strong>和<strong>多行注释</strong>。</p>
<hr>
<h4 id="1-单行注释"><a href="#1-单行注释" class="headerlink" title="1. 单行注释"></a>1. <strong>单行注释</strong></h4><p>单行注释以 <code>//</code> 开头，注释内容从 <code>//</code> 开始到行尾结束。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个单行注释</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>; <span class="comment">// 这是另一个单行注释</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-多行注释"><a href="#2-多行注释" class="headerlink" title="2. 多行注释"></a>2. <strong>多行注释</strong></h4><p>多行注释以 <code>/*</code> 开头，以 <code>*/</code> 结尾，注释内容可以跨越多行。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是一个多行注释</span></span><br><span class="line"><span class="comment">可以跨越多行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>HTML注释不会显示在浏览器中，但用户可以通过查看源代码看到。</li>
<li>CSS注释同样不会影响样式渲染，且不会出现在最终页面中。</li>
</ul>
<p>合理使用注释有助于代码的可读性和维护性。</p>
<h2 id="提问02：-margin-0-auto会导致水平居中吗？"><a href="#提问02：-margin-0-auto会导致水平居中吗？" class="headerlink" title="提问02： margin: 0 auto会导致水平居中吗？"></a>提问02： margin: 0 auto会导致水平居中吗？</h2><p>是的，<code>margin: 0 auto;</code> <strong>会导致水平居中</strong>，但需要满足一定的条件。以下是详细解析：</p>
<hr>
<h4 id="1-margin-0-auto-的作用"><a href="#1-margin-0-auto-的作用" class="headerlink" title="1. margin: 0 auto; 的作用"></a>1. <strong><code>margin: 0 auto;</code> 的作用</strong></h4><ul>
<li><code>margin: 0 auto;</code> 是以下属性的简写：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin-left</span>: auto;</span><br><span class="line"><span class="attribute">margin-right</span>: auto;</span><br></pre></td></tr></table></figure></li>
<li><code>auto</code> 值会让浏览器自动计算左右外边距，使元素在其父容器中水平居中。</li>
</ul>
<hr>
<h4 id="2-实现水平居中的条件"><a href="#2-实现水平居中的条件" class="headerlink" title="2. 实现水平居中的条件"></a>2. <strong>实现水平居中的条件</strong></h4><p>要使 <code>margin: 0 auto;</code> 生效，元素必须满足以下条件：</p>
<h5 id="条件-1：元素必须是块级元素"><a href="#条件-1：元素必须是块级元素" class="headerlink" title="条件 1：元素必须是块级元素"></a>条件 1：元素必须是<strong>块级元素</strong></h5><ul>
<li>块级元素（如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code> 等）默认宽度为父容器的 100%。</li>
<li>如果是行内元素（如 <code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>），需要将其设置为块级元素：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: block;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="条件-2：元素必须有明确的宽度"><a href="#条件-2：元素必须有明确的宽度" class="headerlink" title="条件 2：元素必须有明确的宽度"></a>条件 2：元素必须有<strong>明确的宽度</strong></h5><ul>
<li>如果元素的宽度是 <code>auto</code>（默认值），它会占据父容器的整个宽度，此时 <code>margin: 0 auto;</code> 不会有效果。</li>
<li>需要为元素设置一个明确的宽度（如 <code>width: 50%;</code> 或 <code>width: 600px;</code>）。</li>
</ul>
<h5 id="条件-3：父容器必须有足够的空间"><a href="#条件-3：父容器必须有足够的空间" class="headerlink" title="条件 3：父容器必须有足够的空间"></a>条件 3：父容器必须有<strong>足够的空间</strong></h5><ul>
<li>父容器的宽度必须大于元素的宽度，否则元素无法居中。</li>
</ul>
<hr>
<h4 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. <strong>示例代码</strong></h4><p>以下是一个使用 <code>margin: 0 auto;</code> 实现水平居中的示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">        这个内容会水平居中</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>; <span class="comment">/* 父容器宽度 */</span></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black; <span class="comment">/* 为了可视化 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>; <span class="comment">/* 明确的宽度 */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto; <span class="comment">/* 水平居中 */</span></span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">    <span class="attribute">text-align</span>: center; <span class="comment">/* 内容水平居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. <strong>注意事项</strong></h4><ul>
<li><code>margin: 0 auto;</code> 只能实现<strong>水平居中</strong>，无法实现垂直居中。</li>
<li>如果需要垂直居中，可以使用 Flexbox 或 Grid 布局：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center; <span class="comment">/* 水平居中 */</span></span><br><span class="line">    <span class="attribute">align-items</span>: center; <span class="comment">/* 垂直居中 */</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>; <span class="comment">/* 父容器高度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><code>margin: 0 auto;</code> 可以实现水平居中，但需要元素是块级元素，并且有明确的宽度。</li>
<li>如果内容没有居中，请检查是否满足上述条件。</li>
</ul>
<h2 id="提问03-本身是行内元素，对吗？"><a href="#提问03-本身是行内元素，对吗？" class="headerlink" title="提问03 &lt;label&gt;本身是行内元素，对吗？"></a>提问03 <code>&lt;label&gt;</code>本身是行内元素，对吗？</h2><p>是的，<code>&lt;label&gt;</code> 元素<strong>默认是行内元素</strong>（inline element）。以下是详细解析：</p>
<hr>
<h4 id="1-的默认显示属性"><a href="#1-的默认显示属性" class="headerlink" title="1. &lt;label&gt; 的默认显示属性"></a>1. <strong><code>&lt;label&gt;</code> 的默认显示属性</strong></h4><ul>
<li>默认情况下，<code>&lt;label&gt;</code> 是一个<strong>行内元素</strong>，其 <code>display</code> 属性值为 <code>inline</code>。</li>
<li>行内元素的特点：<ul>
<li>不会独占一行，会与其他行内元素共享同一行。</li>
<li>无法设置宽度（<code>width</code>）和高度（<code>height</code>），其大小由内容决定。</li>
<li>上下外边距（<code>margin-top</code> 和 <code>margin-bottom</code>）无效。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-为什么设置-display-block-？"><a href="#2-为什么设置-display-block-？" class="headerlink" title="2. 为什么设置 display: block;？"></a>2. <strong>为什么设置 <code>display: block;</code>？</strong></h4><p>在你的代码中，将 <code>&lt;label&gt;</code> 设置为 <code>display: block;</code>，使其变为<strong>块级元素</strong>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">label</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="块级元素的特点："><a href="#块级元素的特点：" class="headerlink" title="块级元素的特点："></a>块级元素的特点：</h5><ul>
<li>独占一行，前后会自动换行。</li>
<li>可以设置宽度（<code>width</code>）和高度（<code>height</code>）。</li>
<li>上下外边距（<code>margin-top</code> 和 <code>margin-bottom</code>）有效。</li>
</ul>
<h5 id="这样做的目的："><a href="#这样做的目的：" class="headerlink" title="这样做的目的："></a>这样做的目的：</h5><ul>
<li>使每个 <code>&lt;label&gt;</code> 独占一行，避免与其他行内元素（如 <code>&lt;input&gt;</code>）在同一行显示。</li>
<li>可以通过 <code>margin-bottom</code> 设置标签与输入框之间的间距，提升表单的可读性。</li>
</ul>
<hr>
<h4 id="3-示例对比"><a href="#3-示例对比" class="headerlink" title="3. 示例对比"></a>3. <strong>示例对比</strong></h4><h5 id="默认情况（display-inline）"><a href="#默认情况（display-inline）" class="headerlink" title="默认情况（display: inline）"></a>默认情况（<code>display: inline</code>）</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>Email:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>效果：<code>&lt;label&gt;</code> 和 <code>&lt;input&gt;</code> 会显示在同一行。</li>
</ul>
<h5 id="设置为-display-block"><a href="#设置为-display-block" class="headerlink" title="设置为 display: block;"></a>设置为 <code>display: block;</code></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>Email:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">label</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>效果：每个 <code>&lt;label&gt;</code> 独占一行，输入框会换行显示，并且标签与输入框之间有 5px 的间距。</li>
</ul>
<hr>
<h4 id="4-其他常见的-display-值"><a href="#4-其他常见的-display-值" class="headerlink" title="4. 其他常见的 display 值"></a>4. <strong>其他常见的 <code>display</code> 值</strong></h4><p>除了 <code>block</code>，<code>&lt;label&gt;</code> 还可以设置为其他 <code>display</code> 值：</p>
<ul>
<li><code>inline-block</code>：行内块级元素，可以设置宽度和高度，但不会独占一行。</li>
<li><code>flex</code>：使 <code>&lt;label&gt;</code> 成为 Flex 容器，可以更方便地控制内部内容的布局。</li>
<li><code>inline-flex</code>：行内 Flex 容器。</li>
</ul>
<hr>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h4><ul>
<li><code>&lt;label&gt;</code> 默认是行内元素（<code>display: inline</code>）。</li>
<li>设置为 <code>display: block;</code> 是为了让每个 <code>&lt;label&gt;</code> 独占一行，并能够设置上下外边距。</li>
<li>这种设计常用于表单布局，以提升可读性和用户体验。</li>
</ul>
<h2 id="提问04-父元素指定max-width后，子元素width-100-会出现显示问题"><a href="#提问04-父元素指定max-width后，子元素width-100-会出现显示问题" class="headerlink" title="提问04 父元素指定max-width后，子元素width:100%会出现显示问题"></a>提问04 父元素指定max-width后，子元素width:100%会出现显示问题</h2><p>当窗口宽度小于 <code>.container</code> 的 <code>max-width: 600px</code> 时，子元素的 <code>width: 100%</code> 可能会导致显示问题（例如内容溢出或布局错乱）。以下是解决思路和具体方法：</p>
<hr>
<h4 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1. 问题分析"></a>1. <strong>问题分析</strong></h4><ul>
<li><code>.container</code> 设置了 <code>max-width: 600px;</code>，这意味着它的最大宽度为 600px，但当窗口宽度小于 600px 时，<code>.container</code> 的宽度会缩小到窗口宽度。</li>
<li>如果子元素设置了 <code>width: 100%</code>，它的宽度会等于 <code>.container</code> 的宽度，这在小屏幕上可能导致内容溢出或布局问题。</li>
</ul>
<hr>
<h4 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2. 解决思路"></a>2. <strong>解决思路</strong></h4><p>以下是几种常见的解决方案：</p>
<h5 id="方法-1：使用-box-sizing-border-box"><a href="#方法-1：使用-box-sizing-border-box" class="headerlink" title="方法 1：使用 box-sizing: border-box;"></a>方法 1：使用 <code>box-sizing: border-box;</code></h5><ul>
<li>将 <code>.container</code> 和子元素的 <code>box-sizing</code> 设置为 <code>border-box</code>，确保内边距和边框不会增加元素的总宽度。</li>
<li>这样可以避免内容溢出。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>, <span class="selector-class">.container</span> * &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法-2：限制子元素的最小宽度"><a href="#方法-2：限制子元素的最小宽度" class="headerlink" title="方法 2：限制子元素的最小宽度"></a>方法 2：限制子元素的最小宽度</h5><ul>
<li>为子元素设置 <code>min-width</code>，防止其在小屏幕上变得过小。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child-element</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">200px</span>; <span class="comment">/* 根据实际情况调整 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法-3：使用-CSS-媒体查询"><a href="#方法-3：使用-CSS-媒体查询" class="headerlink" title="方法 3：使用 CSS 媒体查询"></a>方法 3：使用 CSS 媒体查询</h5><ul>
<li>使用媒体查询针对小屏幕调整布局。</li>
<li>例如，在小屏幕上减少内边距或调整子元素的宽度。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.container</span> &#123;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="comment">/* 调整内边距 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.child-element</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>; <span class="comment">/* 或其他适合的值 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法-4：使用-Flexbox-或-Grid-布局"><a href="#方法-4：使用-Flexbox-或-Grid-布局" class="headerlink" title="方法 4：使用 Flexbox 或 Grid 布局"></a>方法 4：使用 Flexbox 或 Grid 布局</h5><ul>
<li>使用 Flexbox 或 Grid 布局可以更灵活地控制子元素的排列和大小。</li>
<li>例如，在小屏幕上将子元素堆叠显示。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column; <span class="comment">/* 小屏幕上子元素堆叠 */</span></span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.container</span> &#123;</span><br><span class="line">        <span class="attribute">flex-direction</span>: row; <span class="comment">/* 大屏幕上子元素并排 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法-5：限制-container-的最小宽度"><a href="#方法-5：限制-container-的最小宽度" class="headerlink" title="方法 5：限制 .container 的最小宽度"></a>方法 5：限制 <code>.container</code> 的最小宽度</h5><ul>
<li>为 <code>.container</code> 设置 <code>min-width</code>，防止其在小屏幕上变得过小。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">300px</span>; <span class="comment">/* 根据实际情况调整 */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-推荐解决方案"><a href="#3-推荐解决方案" class="headerlink" title="3. 推荐解决方案"></a>3. <strong>推荐解决方案</strong></h4><p>结合 <code>box-sizing</code> 和媒体查询是一个比较全面的解决方案：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>, <span class="selector-class">.container</span> * &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>; <span class="comment">/* 根据需要调整 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.container</span> &#123;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="comment">/* 小屏幕上减少内边距 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.child-element</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>; <span class="comment">/* 确保子元素占满宽度 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a>4. <strong>示例代码</strong></h4><p>以下是一个完整的示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-element&quot;</span>&gt;</span></span><br><span class="line">        这是一个子元素，宽度为 100%。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>, <span class="selector-class">.container</span> * &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f9f9f9</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child-element</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e0e0e0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.container</span> &#123;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.child-element</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h4><ul>
<li>使用 <code>box-sizing: border-box;</code> 可以避免内容溢出。</li>
<li>使用媒体查询针对小屏幕调整布局。</li>
<li>结合 Flexbox 或 Grid 布局可以更灵活地控制子元素的排列和大小。</li>
<li>根据实际需求选择合适的解决方案，确保在不同屏幕尺寸下都能正常显示。</li>
</ul>
<h2 id="提问05-box-sizing-border-box-跟-CSS盒子模型、弹性盒模型-这两个知识点的关联性"><a href="#提问05-box-sizing-border-box-跟-CSS盒子模型、弹性盒模型-这两个知识点的关联性" class="headerlink" title="提问05 box-sizing: border-box; 跟 CSS盒子模型、弹性盒模型  这两个知识点的关联性"></a>提问05 <code>box-sizing: border-box;</code> 跟 CSS盒子模型、弹性盒模型  这两个知识点的关联性</h2><p><code>box-sizing: border-box;</code> 和 <strong>CSS 盒子模型</strong>、<strong>弹性盒模型（Flexbox）</strong> 是 CSS 中非常重要的概念，它们之间有一定的关联性，但解决的问题和应用的场景不同。以下是它们的详细解析和关联性说明：</p>
<hr>
<h4 id="1-CSS-盒子模型"><a href="#1-CSS-盒子模型" class="headerlink" title="1. CSS 盒子模型"></a>1. <strong>CSS 盒子模型</strong></h4><p>CSS 盒子模型是 CSS 布局的基础，它定义了元素的尺寸计算方式。每个元素都被视为一个矩形盒子，由以下部分组成：</p>
<ul>
<li><strong>内容区域（content）</strong>：显示实际内容的区域。</li>
<li><strong>内边距（padding）</strong>：内容区域与边框之间的空间。</li>
<li><strong>边框（border）</strong>：围绕内容和内边距的边框。</li>
<li><strong>外边距（margin）</strong>：盒子与其他元素之间的空间。</li>
</ul>
<h5 id="默认盒子模型（content-box）"><a href="#默认盒子模型（content-box）" class="headerlink" title="默认盒子模型（content-box）"></a>默认盒子模型（<code>content-box</code>）</h5><ul>
<li>默认情况下，CSS 使用 <code>content-box</code> 盒子模型。</li>
<li>在这种模型下，<strong>元素的宽度和高度仅包括内容区域，内边距和边框会增加元素的总尺寸</strong>。</li>
<li>例如：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实际宽度 &#x3D; 内容宽度（200px） + 内边距（20px * 2） + 边框（10px * 2） &#x3D; <strong>260px</strong>。</li>
</ul>
</li>
</ul>
<h5 id="box-sizing-border-box"><a href="#box-sizing-border-box" class="headerlink" title="box-sizing: border-box;"></a><code>box-sizing: border-box;</code></h5><ul>
<li>使用 <code>border-box</code> 盒子模型时，<strong>元素的宽度和高度包括内容、内边距和边框</strong>。</li>
<li>例如：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实际宽度 &#x3D; 内容宽度（200px，包括内边距和边框）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-弹性盒模型（Flexbox）"><a href="#2-弹性盒模型（Flexbox）" class="headerlink" title="2. 弹性盒模型（Flexbox）"></a>2. <strong>弹性盒模型（Flexbox）</strong></h4><p>弹性盒模型（Flexbox）是一种用于一维布局的 CSS 模块，旨在更高效地分配空间和对齐元素。它的核心概念包括：</p>
<ul>
<li><strong>容器（flex container）</strong>：通过 <code>display: flex;</code> 或 <code>display: inline-flex;</code> 创建。</li>
<li><strong>项目（flex items）</strong>：容器内的子元素。</li>
<li><strong>主轴（main axis）</strong> 和 <strong>交叉轴（cross axis）</strong>：定义了布局的方向。</li>
</ul>
<h5 id="Flexbox-的特点"><a href="#Flexbox-的特点" class="headerlink" title="Flexbox 的特点"></a>Flexbox 的特点</h5><ul>
<li>可以轻松实现水平或垂直居中。</li>
<li>可以动态分配剩余空间。</li>
<li>支持项目的对齐、排序和伸缩。</li>
</ul>
<hr>
<h4 id="3-box-sizing-border-box-和-Flexbox-的关联性"><a href="#3-box-sizing-border-box-和-Flexbox-的关联性" class="headerlink" title="3. box-sizing: border-box; 和 Flexbox 的关联性"></a>3. <strong><code>box-sizing: border-box;</code> 和 Flexbox 的关联性</strong></h4><p>虽然 <code>box-sizing</code> 和 Flexbox 是两个独立的概念，但它们在实际布局中可以结合使用，解决一些常见问题：</p>
<h5 id="关联性-1：尺寸计算的一致性"><a href="#关联性-1：尺寸计算的一致性" class="headerlink" title="关联性 1：尺寸计算的一致性"></a>关联性 1：尺寸计算的一致性</h5><ul>
<li>在 Flexbox 布局中，项目的尺寸（<code>flex-basis</code>、<code>width</code> 等）会受到盒子模型的影响。</li>
<li>如果使用默认的 <code>content-box</code>，内边距和边框会增加项目的实际尺寸，可能导致布局错乱。</li>
<li>使用 <code>box-sizing: border-box;</code> 可以确保项目的尺寸计算更加一致和可控。</li>
</ul>
<h5 id="关联性-2：避免布局溢出"><a href="#关联性-2：避免布局溢出" class="headerlink" title="关联性 2：避免布局溢出"></a>关联性 2：避免布局溢出</h5><ul>
<li>在 Flexbox 容器中，项目的总宽度或高度可能会超出容器的范围，尤其是在设置了内边距和边框的情况下。</li>
<li>通过 <code>box-sizing: border-box;</code>，可以确保项目的尺寸包括内边距和边框，避免溢出问题。</li>
</ul>
<h5 id="关联性-3：简化布局计算"><a href="#关联性-3：简化布局计算" class="headerlink" title="关联性 3：简化布局计算"></a>关联性 3：简化布局计算</h5><ul>
<li>使用 <code>box-sizing: border-box;</code> 可以简化 Flexbox 布局中的尺寸计算，尤其是在需要精确控制项目大小的情况下。</li>
</ul>
<hr>
<h4 id="4-示例代码-1"><a href="#4-示例代码-1" class="headerlink" title="4. 示例代码"></a>4. <strong>示例代码</strong></h4><p>以下是一个结合 <code>box-sizing: border-box;</code> 和 Flexbox 的示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-item&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-item&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex-item&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 全局设置 box-sizing */</span></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between; <span class="comment">/* 项目之间均匀分布 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30%</span>; <span class="comment">/* 宽度包括内边距和边框 */</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#e0e0e0</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-总结-2"><a href="#5-总结-2" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h4><ul>
<li>**<code>box-sizing: border-box;</code>**：用于控制元素的尺寸计算方式，确保宽度和高度包括内边距和边框。</li>
<li><strong>CSS 盒子模型</strong>：定义了元素尺寸的组成部分（内容、内边距、边框、外边距）。</li>
<li><strong>Flexbox</strong>：用于实现灵活的布局，支持项目的对齐、排序和空间分配。</li>
<li><strong>关联性</strong>：<code>box-sizing: border-box;</code> 可以简化 Flexbox 布局中的尺寸计算，避免布局溢出问题，确保布局的一致性。</li>
</ul>
<p>在实际开发中，建议全局设置 <code>box-sizing: border-box;</code>，并结合 Flexbox 实现更灵活和可控的布局。</p>
<h2 id="提问06-js中，函数可以通过var声明吗？请先指出我的误解，再具体说明。"><a href="#提问06-js中，函数可以通过var声明吗？请先指出我的误解，再具体说明。" class="headerlink" title="提问06 js中，函数可以通过var声明吗？请先指出我的误解，再具体说明。"></a>提问06 js中，函数可以通过var声明吗？请先指出我的误解，再具体说明。</h2><p>在 JavaScript 中，函数可以通过 <code>var</code> 声明，但你的问题中可能存在一些误解。以下是详细解析：</p>
<hr>
<h4 id="1-你的误解"><a href="#1-你的误解" class="headerlink" title="1. 你的误解"></a>1. <strong>你的误解</strong></h4><p>你可能认为：</p>
<ul>
<li><strong>函数只能通过 <code>function</code> 关键字声明</strong>，例如：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong><code>var</code> 只能用于声明变量</strong>，例如：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>实际上，JavaScript 中的函数可以通过多种方式声明，包括使用 <code>var</code>、<code>let</code>、<code>const</code> 等关键字。</p>
<hr>
<h4 id="2-JavaScript-中函数的声明方式"><a href="#2-JavaScript-中函数的声明方式" class="headerlink" title="2. JavaScript 中函数的声明方式"></a>2. <strong>JavaScript 中函数的声明方式</strong></h4><p>在 JavaScript 中，函数可以通过以下几种方式声明：</p>
<h5 id="方式-1：函数声明（Function-Declaration）"><a href="#方式-1：函数声明（Function-Declaration）" class="headerlink" title="方式 1：函数声明（Function Declaration）"></a>方式 1：函数声明（Function Declaration）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这种方式会<strong>提升（hoist）</strong>函数，即在代码执行前，函数已经被定义，可以在声明前调用。</li>
</ul>
<h5 id="方式-2：函数表达式（Function-Expression）"><a href="#方式-2：函数表达式（Function-Expression）" class="headerlink" title="方式 2：函数表达式（Function Expression）"></a>方式 2：函数表达式（Function Expression）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunction = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这种方式将函数赋值给一个变量（如 <code>myFunction</code>）。</li>
<li>函数表达式不会被提升，只有在赋值后才能调用。</li>
</ul>
<h5 id="方式-3：箭头函数（Arrow-Function）"><a href="#方式-3：箭头函数（Arrow-Function）" class="headerlink" title="方式 3：箭头函数（Arrow Function）"></a>方式 3：箭头函数（Arrow Function）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myFunction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>箭头函数是 ES6 引入的语法，通常用于匿名函数或简化函数写法。</li>
</ul>
<h5 id="方式-4：通过-var、let、const-声明函数"><a href="#方式-4：通过-var、let、const-声明函数" class="headerlink" title="方式 4：通过 var、let、const 声明函数"></a>方式 4：通过 <code>var</code>、<code>let</code>、<code>const</code> 声明函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunction = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myFunction = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myFunction = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>var</code>、<code>let</code> 或 <code>const</code> 声明函数时，实际上是将函数表达式赋值给一个变量。</li>
</ul>
<hr>
<h4 id="3-var-声明函数的特点"><a href="#3-var-声明函数的特点" class="headerlink" title="3. var 声明函数的特点"></a>3. <strong><code>var</code> 声明函数的特点</strong></h4><ul>
<li><p><strong>提升（Hoisting）</strong>：</p>
<ul>
<li>使用 <code>var</code> 声明的变量会被提升，但赋值不会被提升。</li>
<li>例如：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myFunction); <span class="comment">// 输出：undefined</span></span><br><span class="line"><span class="keyword">var</span> myFunction = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myFunction); <span class="comment">// 输出：function() &#123; console.log(&quot;Hello&quot;); &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在赋值之前，<code>myFunction</code> 的值为 <code>undefined</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>作用域</strong>：</p>
<ul>
<li>使用 <code>var</code> 声明的函数具有函数作用域（function scope），而不是块级作用域（block scope）。</li>
</ul>
</li>
<li><p><strong>重复声明</strong>：</p>
<ul>
<li>使用 <code>var</code> 可以重复声明同一个变量，后面的声明会覆盖前面的声明。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-let-和-const-声明函数的特点"><a href="#4-let-和-const-声明函数的特点" class="headerlink" title="4. let 和 const 声明函数的特点"></a>4. <strong><code>let</code> 和 <code>const</code> 声明函数的特点</strong></h4><ul>
<li><p><strong>块级作用域</strong>：</p>
<ul>
<li>使用 <code>let</code> 和 <code>const</code> 声明的函数具有块级作用域。</li>
<li>例如：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> myFunction = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myFunction); <span class="comment">// 报错：myFunction is not defined</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>不可重复声明</strong>：</p>
<ul>
<li>使用 <code>let</code> 和 <code>const</code> 不能重复声明同一个变量。</li>
</ul>
</li>
<li><p><strong><code>const</code> 的特殊性</strong>：</p>
<ul>
<li>使用 <code>const</code> 声明的函数不能被重新赋值，但函数内部的属性或方法可以被修改。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-示例代码"><a href="#5-示例代码" class="headerlink" title="5. 示例代码"></a>5. <strong>示例代码</strong></h4><p>以下是使用 <code>var</code>、<code>let</code>、<code>const</code> 声明函数的示例：</p>
<h5 id="使用-var"><a href="#使用-var" class="headerlink" title="使用 var"></a>使用 <code>var</code></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunction = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from var&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">myFunction</span>(); <span class="comment">// 输出：Hello from var</span></span><br></pre></td></tr></table></figure>

<h5 id="使用-let"><a href="#使用-let" class="headerlink" title="使用 let"></a>使用 <code>let</code></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFunction = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from let&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">myFunction</span>(); <span class="comment">// 输出：Hello from let</span></span><br></pre></td></tr></table></figure>

<h5 id="使用-const"><a href="#使用-const" class="headerlink" title="使用 const"></a>使用 <code>const</code></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from const&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">myFunction</span>(); <span class="comment">// 输出：Hello from const</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h4><ul>
<li><strong>函数可以通过 <code>var</code> 声明</strong>，但实际上是使用函数表达式将函数赋值给一个变量。</li>
<li><strong><code>var</code> 声明的函数会被提升，但赋值不会被提升</strong>。</li>
<li><strong><code>let</code> 和 <code>const</code> 也可以用于声明函数</strong>，且具有块级作用域。</li>
<li>推荐使用 <code>const</code> 声明函数，以避免意外的重新赋值。</li>
</ul>
<p>希望这能帮助你更好地理解 JavaScript 中函数的声明方式！</p>
<h2 id="提问07-提升（Hoisting）是什么概念？是JS里的专有名词吗？"><a href="#提问07-提升（Hoisting）是什么概念？是JS里的专有名词吗？" class="headerlink" title="提问07 提升（Hoisting）是什么概念？是JS里的专有名词吗？"></a>提问07 提升（Hoisting）是什么概念？是JS里的专有名词吗？</h2><p><strong>提升（Hoisting）</strong> 是 JavaScript 中的一个专有名词，用于描述变量和函数声明在代码执行前的行为。以下是详细解析：</p>
<hr>
<h4 id="1-提升的概念"><a href="#1-提升的概念" class="headerlink" title="1. 提升的概念"></a>1. <strong>提升的概念</strong></h4><p>提升（Hoisting）是指 JavaScript 引擎在代码执行之前，会将变量和函数的声明<strong>提升到其作用域的顶部</strong>。这意味着你可以在声明之前使用这些变量或函数，而不会报错。</p>
<p>需要注意的是：</p>
<ul>
<li><strong>只有声明会被提升，赋值不会被提升</strong>。</li>
<li>提升是 JavaScript 引擎在编译阶段的行为，而不是代码的实际移动。</li>
</ul>
<hr>
<h4 id="2-变量提升"><a href="#2-变量提升" class="headerlink" title="2. 变量提升"></a>2. <strong>变量提升</strong></h4><h5 id="使用-var-声明的变量"><a href="#使用-var-声明的变量" class="headerlink" title="使用 var 声明的变量"></a>使用 <code>var</code> 声明的变量</h5><ul>
<li><code>var</code> 声明的变量会被提升到其作用域的顶部，但赋值不会被提升。</li>
<li>在赋值之前访问变量，会得到 <code>undefined</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出：undefined</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>实际执行顺序相当于：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x; <span class="comment">// 声明被提升</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出：undefined</span></span><br><span class="line">x = <span class="number">10</span>; <span class="comment">// 赋值不会被提升</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="使用-let-和-const-声明的变量"><a href="#使用-let-和-const-声明的变量" class="headerlink" title="使用 let 和 const 声明的变量"></a>使用 <code>let</code> 和 <code>const</code> 声明的变量</h5><ul>
<li><code>let</code> 和 <code>const</code> 声明的变量也会被提升，但不会被初始化为 <code>undefined</code>。</li>
<li>在声明之前访问变量会触发 <strong>暂时性死区（Temporal Dead Zone, TDZ）</strong>，导致报错。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 报错：Cannot access &#x27;y&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-函数提升"><a href="#3-函数提升" class="headerlink" title="3. 函数提升"></a>3. <strong>函数提升</strong></h4><h5 id="函数声明（Function-Declaration）"><a href="#函数声明（Function-Declaration）" class="headerlink" title="函数声明（Function Declaration）"></a>函数声明（Function Declaration）</h5><ul>
<li>函数声明会被整体提升，包括函数体。</li>
<li>你可以在声明之前调用函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">myFunction</span>(); <span class="comment">// 输出：Hello</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="函数表达式（Function-Expression）"><a href="#函数表达式（Function-Expression）" class="headerlink" title="函数表达式（Function Expression）"></a>函数表达式（Function Expression）</h5><ul>
<li>函数表达式不会被提升，只有变量声明会被提升。</li>
<li>在赋值之前访问变量会得到 <code>undefined</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">myFunction</span>(); <span class="comment">// 报错：myFunction is not a function</span></span><br><span class="line"><span class="keyword">var</span> myFunction = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-提升的作用域"><a href="#4-提升的作用域" class="headerlink" title="4. 提升的作用域"></a>4. <strong>提升的作用域</strong></h4><ul>
<li>提升的作用域取决于变量或函数的声明位置。</li>
<li>在全局作用域中声明的变量或函数会被提升到全局作用域的顶部。</li>
<li>在函数作用域中声明的变量或函数会被提升到函数作用域的顶部。</li>
</ul>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出：undefined</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出：10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-提升的注意事项"><a href="#5-提升的注意事项" class="headerlink" title="5. 提升的注意事项"></a>5. <strong>提升的注意事项</strong></h4><ul>
<li><strong>避免在声明之前使用变量</strong>：虽然提升允许你在声明之前使用变量，但这会导致代码可读性差，容易引发错误。</li>
<li>**优先使用 <code>let</code> 和 <code>const</code>**：<code>let</code> 和 <code>const</code> 的暂时性死区机制可以帮助你避免在声明之前使用变量。</li>
<li><strong>函数声明优于函数表达式</strong>：如果需要提升函数，优先使用函数声明。</li>
</ul>
<hr>
<h4 id="6-提升是-JavaScript-的专有名词吗？"><a href="#6-提升是-JavaScript-的专有名词吗？" class="headerlink" title="6. 提升是 JavaScript 的专有名词吗？"></a>6. <strong>提升是 JavaScript 的专有名词吗？</strong></h4><ul>
<li><strong>提升（Hoisting）</strong> 是 JavaScript 中的一个专有名词，用于描述变量和函数声明在代码执行前的行为。</li>
<li>其他编程语言（如 Python、Java）没有类似的概念，因为它们的变量和函数声明不会被提升。</li>
</ul>
<hr>
<h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. <strong>总结</strong></h4><ul>
<li><strong>提升</strong> 是 JavaScript 引擎在代码执行前将变量和函数声明移动到作用域顶部的行为。</li>
<li><strong><code>var</code> 声明的变量</strong>会被提升并初始化为 <code>undefined</code>。</li>
<li><strong><code>let</code> 和 <code>const</code> 声明的变量</strong>也会被提升，但在声明之前访问会触发暂时性死区。</li>
<li><strong>函数声明</strong>会被整体提升，而 <strong>函数表达式</strong> 只有变量声明会被提升。</li>
<li>提升是 JavaScript 的独特特性，理解它有助于避免常见的代码错误。</li>
</ul>
<h2 id="提问08-replace-s-g-去除所有空格-这是什么意思？-‘-‘有什么特殊含义吗？（两问）"><a href="#提问08-replace-s-g-去除所有空格-这是什么意思？-‘-‘有什么特殊含义吗？（两问）" class="headerlink" title="提问08 .replace(/\s+/g, &#39;&#39;) // 去除所有空格  这是什么意思？ ‘&#x2F;‘有什么特殊含义吗？（两问）"></a>提问08 <code>.replace(/\s+/g, &#39;&#39;) // 去除所有空格</code>  这是什么意思？ ‘&#x2F;‘有什么特殊含义吗？（两问）</h2><p><code>replace(/\s+/g, &#39;&#39;)</code> 是 JavaScript 中用于<strong>去除字符串中所有空格</strong>的代码。以下是详细解析：</p>
<hr>
<h4 id="1-replace-方法"><a href="#1-replace-方法" class="headerlink" title="1. replace 方法"></a>1. <strong><code>replace</code> 方法</strong></h4><ul>
<li><code>replace</code> 是 JavaScript 字符串的一个方法，用于替换字符串中的某些内容。</li>
<li>语法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str.<span class="title function_">replace</span>(searchValue, replaceValue);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>searchValue</code>：要查找的内容（可以是字符串或正则表达式）。</li>
<li><code>replaceValue</code>：替换的内容（可以是字符串或函数）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-正则表达式-s-g"><a href="#2-正则表达式-s-g" class="headerlink" title="2. 正则表达式 /\s+/g"></a>2. <strong>正则表达式 <code>/\s+/g</code></strong></h4><ul>
<li>正则表达式（Regular Expression）是一种用于匹配字符串的模式。</li>
<li><code>/\s+/g</code> 是一个正则表达式，具体含义如下：<ul>
<li><code>\s</code>：匹配任意空白字符，包括：<ul>
<li>空格（<code> </code>）</li>
<li>制表符（<code>\t</code>）</li>
<li>换行符（<code>\n</code>）</li>
<li>回车符（<code>\r</code>）</li>
</ul>
</li>
<li><code>+</code>：匹配前面的字符（<code>\s</code>）<strong>一次或多次</strong>。</li>
<li><code>g</code>：全局匹配（global），表示匹配字符串中所有符合条件的内容，而不仅仅是第一个。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-replace-s-g-的作用"><a href="#3-replace-s-g-的作用" class="headerlink" title="3. replace(/\s+/g, &#39;&#39;) 的作用"></a>3. <strong><code>replace(/\s+/g, &#39;&#39;)</code> 的作用</strong></h4><ul>
<li><code>/\s+/g</code>：匹配字符串中<strong>所有连续的空白字符</strong>。</li>
<li><code>&#39;&#39;</code>：将匹配到的空白字符替换为空字符串（即删除）。</li>
<li>因此，<code>replace(/\s+/g, &#39;&#39;)</code> 的作用是<strong>去除字符串中所有空白字符</strong>。</li>
</ul>
<hr>
<h4 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. <strong>示例</strong></h4><p>假设有一个字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello,  World! \n This is a test. &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>使用 <code>replace(/\s+/g, &#39;&#39;)</code> 处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = str.<span class="title function_">replace</span>(<span class="regexp">/\s+/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出：Hello,World!Thisisatest.</span></span><br></pre></td></tr></table></figure>

<h5 id="处理过程："><a href="#处理过程：" class="headerlink" title="处理过程："></a>处理过程：</h5><ol>
<li>匹配所有空白字符：<ul>
<li><code> </code>（空格）</li>
<li><code>\n</code>（换行符）</li>
</ul>
</li>
<li>将这些空白字符替换为空字符串。</li>
</ol>
<hr>
<h4 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. <strong>注意事项</strong></h4><ul>
<li>如果只想去除空格（不包括制表符、换行符等），可以使用 <code>replace(/ /g, &#39;&#39;)</code>。</li>
<li>如果只想去除字符串开头和结尾的空白字符，可以使用 <code>trim()</code> 方法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;  Hello, World!  &quot;</span>;</span><br><span class="line"><span class="keyword">const</span> result = str.<span class="title function_">trim</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出：Hello, World!</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="6-总结-1"><a href="#6-总结-1" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h4><ul>
<li><code>replace(/\s+/g, &#39;&#39;)</code> 用于去除字符串中<strong>所有空白字符</strong>，包括空格、制表符、换行符等。</li>
<li>这是处理用户输入时常用的方法，可以确保字符串中没有多余的空白字符。</li>
</ul>
<p>希望这能帮助你更好地理解这段代码的作用！</p>
<hr>
<p>在 JavaScript 中，<code>/</code> 是<strong>正则表达式（Regular Expression）的界定符</strong>，用于表示正则表达式的开始和结束。它本身没有特殊含义，但在正则表达式中，<code>/</code> 用于包裹模式（pattern），告诉 JavaScript 这是一个正则表达式。</p>
<hr>
<h4 id="1-正则表达式的基本语法"><a href="#1-正则表达式的基本语法" class="headerlink" title="1. 正则表达式的基本语法"></a>1. <strong>正则表达式的基本语法</strong></h4><p>正则表达式通常以 <code>/</code> 开头和结尾，中间是模式（pattern）。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/\s+/g</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个 <code>/</code>：表示正则表达式的开始。</li>
<li><code>\s+</code>：正则表达式的模式。</li>
<li>第二个 <code>/</code>：表示正则表达式的结束。</li>
<li><code>g</code>：正则表达式的标志（flag），表示全局匹配。</li>
</ul>
<hr>
<h4 id="2-的作用"><a href="#2-的作用" class="headerlink" title="2. / 的作用"></a>2. <strong><code>/</code> 的作用</strong></h4><ul>
<li><strong>界定符</strong>：<code>/</code> 用于包裹正则表达式的模式，告诉 JavaScript 这是一个正则表达式。</li>
<li><strong>分隔符</strong>：在正则表达式中，<code>/</code> 将模式与标志（如 <code>g</code>、<code>i</code>、<code>m</code> 等）分开。</li>
</ul>
<hr>
<h4 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. <strong>示例</strong></h4><h5 id="示例-1：匹配空白字符"><a href="#示例-1：匹配空白字符" class="headerlink" title="示例 1：匹配空白字符"></a>示例 1：匹配空白字符</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;Hello,  World!&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> result = str.<span class="title function_">replace</span>(<span class="regexp">/\s+/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出：Hello,World!</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>/\s+/g</code> 是一个正则表达式：<ul>
<li><code>/</code>：开始和结束正则表达式。</li>
<li><code>\s+</code>：匹配一个或多个空白字符。</li>
<li><code>g</code>：全局匹配。</li>
</ul>
</li>
</ul>
<h5 id="示例-2：匹配数字"><a href="#示例-2：匹配数字" class="headerlink" title="示例 2：匹配数字"></a>示例 2：匹配数字</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;abc123def456&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> result = str.<span class="title function_">replace</span>(<span class="regexp">/\d+/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出：abcdef</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>/\d+/g</code> 是一个正则表达式：<ul>
<li><code>/</code>：开始和结束正则表达式。</li>
<li><code>\d+</code>：匹配一个或多个数字。</li>
<li><code>g</code>：全局匹配。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-的其他用途"><a href="#4-的其他用途" class="headerlink" title="4. / 的其他用途"></a>4. <strong><code>/</code> 的其他用途</strong></h4><p>在 JavaScript 中，<code>/</code> 除了用于正则表达式外，还可以用于：</p>
<ul>
<li><strong>除法运算符</strong>：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出：5</span></span><br></pre></td></tr></table></figure></li>
<li><strong>注释</strong>（在正则表达式中无效）：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是单行注释</span></span><br><span class="line"><span class="comment">/* 这是多行注释 */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="5-总结-3"><a href="#5-总结-3" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h4><ul>
<li>在正则表达式中，<code>/</code> 是界定符，用于包裹模式。</li>
<li>它本身没有特殊含义，但在正则表达式中是必不可少的语法符号。</li>
<li>在其他上下文中，<code>/</code> 可以用作除法运算符或注释符号。</li>
</ul>
<p>希望这能帮助你更好地理解 <code>/</code> 的作用！</p>
<h2 id="提问09-js的正则表达式需要import之类的操作吗？"><a href="#提问09-js的正则表达式需要import之类的操作吗？" class="headerlink" title="提问09 js的正则表达式需要import之类的操作吗？"></a>提问09 js的正则表达式需要import之类的操作吗？</h2><p>在 JavaScript 中，<strong>正则表达式是语言内置的功能</strong>，不需要通过 <code>import</code> 或其他方式引入。你可以直接在代码中使用正则表达式，无需任何额外的操作。</p>
<hr>
<h4 id="1-正则表达式的使用方式"><a href="#1-正则表达式的使用方式" class="headerlink" title="1. 正则表达式的使用方式"></a>1. <strong>正则表达式的使用方式</strong></h4><p>JavaScript 提供了两种创建正则表达式的方式：</p>
<h5 id="方式-1：字面量语法"><a href="#方式-1：字面量语法" class="headerlink" title="方式 1：字面量语法"></a>方式 1：字面量语法</h5><p>使用 <code>/</code> 包裹正则表达式模式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/\d+/g</span>;</span><br></pre></td></tr></table></figure>

<h5 id="方式-2：构造函数语法"><a href="#方式-2：构造函数语法" class="headerlink" title="方式 2：构造函数语法"></a>方式 2：构造函数语法</h5><p>使用 <code>RegExp</code> 构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;\\d+&#x27;</span>, <span class="string">&#x27;g&#x27;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-正则表达式的应用场景"><a href="#2-正则表达式的应用场景" class="headerlink" title="2. 正则表达式的应用场景"></a>2. <strong>正则表达式的应用场景</strong></h4><p>正则表达式可以用于以下场景：</p>
<ul>
<li><strong>字符串匹配</strong>：检查字符串是否符合某种模式。</li>
<li><strong>字符串替换</strong>：替换字符串中符合模式的部分。</li>
<li><strong>字符串提取</strong>：从字符串中提取符合模式的部分。</li>
</ul>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查字符串是否包含数字</span></span><br><span class="line"><span class="keyword">const</span> hasNumber = <span class="regexp">/\d/</span>.<span class="title function_">test</span>(<span class="string">&quot;Hello123&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hasNumber); <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换字符串中的数字</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="string">&quot;Hello123&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/\d+/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出：Hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取字符串中的数字</span></span><br><span class="line"><span class="keyword">const</span> numbers = <span class="string">&quot;Hello123World456&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/\d+/g</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers); <span class="comment">// 输出：[&quot;123&quot;, &quot;456&quot;]</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-不需要-import-的原因"><a href="#3-不需要-import-的原因" class="headerlink" title="3. 不需要 import 的原因"></a>3. <strong>不需要 <code>import</code> 的原因</strong></h4><ul>
<li>正则表达式是 JavaScript 的<strong>核心功能</strong>，属于语言标准的一部分。</li>
<li>无论是浏览器环境还是 Node.js 环境，都可以直接使用正则表达式，无需引入额外的库或模块。</li>
</ul>
<hr>
<h4 id="4-与其他语言的对比"><a href="#4-与其他语言的对比" class="headerlink" title="4. 与其他语言的对比"></a>4. <strong>与其他语言的对比</strong></h4><ul>
<li>在一些编程语言（如 Python）中，正则表达式功能需要通过 <code>import re</code> 引入。</li>
<li>在 JavaScript 中，正则表达式是内置的，开箱即用。</li>
</ul>
<hr>
<h4 id="5-总结-4"><a href="#5-总结-4" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h4><ul>
<li>JavaScript 的正则表达式是语言内置功能，**不需要 <code>import</code>**。</li>
<li>你可以直接使用字面量语法（<code>/pattern/</code>）或构造函数语法（<code>new RegExp()</code>）创建正则表达式。</li>
<li>正则表达式在字符串处理中非常强大，是 JavaScript 开发中的常用工具。</li>
</ul>
<p>希望这能解答你的疑问！如果还有其他问题，欢迎继续提问！</p>
<h2 id="提问10-JS中的DOM操作let-ele1-document-getElementById-id-ele1-value的访问操作，与Vue3的cosnt-ele2-ref-ele2-value的访问操作有什么内在联系吗？"><a href="#提问10-JS中的DOM操作let-ele1-document-getElementById-id-ele1-value的访问操作，与Vue3的cosnt-ele2-ref-ele2-value的访问操作有什么内在联系吗？" class="headerlink" title="提问10 JS中的DOM操作let ele1 = document.getElementById(&#39;id&#39;);  ele1.value的访问操作，与Vue3的cosnt ele2 = ref(&#39;&#39;) ; ele2.value的访问操作有什么内在联系吗？"></a>提问10 JS中的DOM操作<code>let ele1 = document.getElementById(&#39;id&#39;);  ele1.value</code>的访问操作，与Vue3的<code>cosnt ele2 = ref(&#39;&#39;) ; ele2.value</code>的访问操作有什么内在联系吗？</h2><p>（注：此提问开始，使用到的是ChatGpt，输出的第一级标题就是h2）</p>
<p>JavaScript 原生 DOM 操作和 Vue3 的 <code>ref</code> 都涉及到对数据的访问和操作，但它们的内部机制和用途有很大不同。我们可以从<strong>响应式系统</strong>和<strong>访问机制</strong>两个方面来分析它们的内在联系和区别。</p>
<hr>
<h3 id="1-访问机制对比"><a href="#1-访问机制对比" class="headerlink" title="1. 访问机制对比"></a><strong>1. 访问机制对比</strong></h3><h4 id="（1）原生-DOM-操作"><a href="#（1）原生-DOM-操作" class="headerlink" title="（1）原生 DOM 操作"></a><strong>（1）原生 DOM 操作</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ele1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ele1.<span class="property">value</span>); <span class="comment">// 获取输入框的值</span></span><br><span class="line">ele1.<span class="property">value</span> = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 修改输入框的值</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>document.getElementById(&#39;id&#39;)</code> 获取的是 <strong>DOM 元素对象</strong>，可以直接访问或修改其 <code>value</code> 属性。</li>
<li><code>ele1.value</code> 直接操作的是 <strong>HTML 元素的属性值</strong>，不会有额外的逻辑处理。</li>
</ul>
<hr>
<h4 id="（2）Vue3-的-ref"><a href="#（2）Vue3-的-ref" class="headerlink" title="（2）Vue3 的 ref"></a><strong>（2）Vue3 的 <code>ref</code></strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ele2 = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ele2.<span class="property">value</span>); <span class="comment">// 读取 ref 的值</span></span><br><span class="line">ele2.<span class="property">value</span> = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 修改 ref 的值</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>ref(&#39;&#39;)</code> 创建的是一个<strong>响应式对象</strong>，它本质上是一个<strong>对象</strong>，其中的 <code>.value</code> 作为代理访问数据。</li>
<li>访问 <code>ele2.value</code> 时，Vue <strong>拦截</strong>了 <code>.value</code> 的读取和修改，以实现<strong>响应式更新</strong>。</li>
</ul>
<hr>
<h3 id="2-内部机制对比"><a href="#2-内部机制对比" class="headerlink" title="2. 内部机制对比"></a><strong>2. 内部机制对比</strong></h3><table>
<thead>
<tr>
<th></th>
<th><strong>原生 DOM 操作</strong></th>
<th><strong>Vue3 <code>ref</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据存储</strong></td>
<td>直接存储在 HTML 元素的 <code>value</code> 属性中</td>
<td>存储在 Vue 内部的响应式对象中</td>
</tr>
<tr>
<td><strong>数据访问方式</strong></td>
<td>直接访问 <code>ele1.value</code></td>
<td>通过 <code>ele2.value</code> 访问响应式数据</td>
</tr>
<tr>
<td><strong>数据变更后果</strong></td>
<td>仅仅修改了 DOM，不会触发额外的逻辑</td>
<td>触发 Vue 响应式系统，更新 UI</td>
</tr>
<tr>
<td><strong>作用范围</strong></td>
<td>仅限于 DOM</td>
<td>可用于 Vue 组件中的数据管理</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-它们的内在联系"><a href="#3-它们的内在联系" class="headerlink" title="3. 它们的内在联系"></a><strong>3. 它们的内在联系</strong></h3><p>从本质上看，Vue3 的 <code>ref</code> 其实是对原生 DOM 数据访问模式的一种<strong>封装和扩展</strong>：</p>
<ul>
<li><strong>相同点</strong>：两者的 <code>.value</code> 都用于获取和修改数据。</li>
<li><strong>不同点</strong>：<ul>
<li><strong>Vue3 <code>ref</code> 是响应式的</strong>，可以触发 UI 更新，而 DOM <code>value</code> 仅仅是数据存储，不会自动更新 UI。</li>
<li><strong>Vue3 <code>ref</code> 适用于组件的状态管理</strong>，而原生 DOM <code>value</code> 主要用于操作具体的 HTML 元素。</li>
</ul>
</li>
</ul>
<p>可以理解为：</p>
<blockquote>
<p><code>ref.value</code> 让 Vue <strong>模拟了</strong> DOM 操作，但它其实是一个 <strong>可追踪的响应式变量</strong>，并不直接作用于 DOM，而是用于数据管理。</p>
</blockquote>
<hr>
<h3 id="4-结合示例分析"><a href="#4-结合示例分析" class="headerlink" title="4. 结合示例分析"></a><strong>4. 结合示例分析</strong></h3><p>假设我们有一个输入框：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="原生-JavaScript-操作"><a href="#原生-JavaScript-操作" class="headerlink" title="原生 JavaScript 操作"></a><strong>原生 JavaScript 操作</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> inputEle = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input1&#x27;</span>);</span><br><span class="line">inputEle.<span class="property">value</span> = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 直接修改 DOM</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(inputEle.<span class="property">value</span>); <span class="comment">// 读取 DOM 的值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这里是直接操作 DOM，没有额外的逻辑。</li>
</ul>
<h5 id="Vue3-ref-方式"><a href="#Vue3-ref-方式" class="headerlink" title="Vue3 ref 方式"></a><strong>Vue3 <code>ref</code> 方式</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const inputValue = ref(&#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">const updateValue = () =&gt; &#123;</span><br><span class="line">  inputValue.value = &quot;Hello&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input v-model=&quot;inputValue&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;updateValue&quot;&gt;修改值&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>Vue 通过 <code>v-model</code> 绑定 <code>inputValue</code>，当 <code>updateValue</code> 修改 <code>inputValue.value</code> 时，Vue <strong>自动更新 UI</strong>，而不需要手动操作 DOM。</li>
</ul>
<hr>
<h3 id="5-总结-5"><a href="#5-总结-5" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><h4 id="联系"><a href="#联系" class="headerlink" title="联系"></a><strong>联系</strong></h4><ul>
<li>Vue3 的 <code>ref.value</code> 和 DOM 的 <code>element.value</code> 在访问方式上类似，都是 <code>.value</code> 取值。</li>
<li><code>ref</code> 让数据访问方式看起来像 DOM 操作，但它实际上是 Vue 响应式系统的一部分。</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a><strong>区别</strong></h4><ul>
<li><code>element.value</code> 直接作用于 HTML 元素，而 <code>ref.value</code> 是一个响应式对象，能触发 UI 更新。</li>
<li><code>ref.value</code> 不是 DOM 属性，而是 Vue 代理的数据存储。</li>
</ul>
<p>所以，Vue3 的 <code>ref</code> 机制可以看作是<strong>对原生 DOM 操作的一种抽象和增强</strong>，让数据驱动 UI，而不是直接操作 DOM。</p>
<h2 id="提问11-nums1-nums1-split-按英文逗号切割-nums1-nums1-map-Number-转换为数字-涉及到的主要方法是什么？请也介绍其相关方法"><a href="#提问11-nums1-nums1-split-按英文逗号切割-nums1-nums1-map-Number-转换为数字-涉及到的主要方法是什么？请也介绍其相关方法" class="headerlink" title="提问11 nums1 = nums1.split(&#39;,&#39;); // 按英文逗号切割 nums1 = nums1.map(Number); // 转换为数字 涉及到的主要方法是什么？请也介绍其相关方法"></a>提问11 <code>nums1 = nums1.split(&#39;,&#39;); // 按英文逗号切割 nums1 = nums1.map(Number); // 转换为数字</code> 涉及到的主要方法是什么？请也介绍其相关方法</h2><p>这段代码涉及到 JavaScript 中 <code>split()</code> 和 <code>map()</code> 这两个常用方法。下面详细介绍它们及相关的方法。</p>
<hr>
<h3 id="1-split-方法"><a href="#1-split-方法" class="headerlink" title="1. split() 方法"></a><strong>1. <code>split()</code> 方法</strong></h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h4><p><code>split()</code> 方法用于将字符串按照指定的分隔符拆分成一个数组。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">string.<span class="title function_">split</span>(separator, limit)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>separator</code>（可选）：用于分割字符串的字符或正则表达式。如果省略，则整个字符串作为一个数组的单个元素返回。</li>
<li><code>limit</code>（可选）：控制返回的数组最多包含多少个元素。</li>
</ul>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;apple,banana,orange&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>); <span class="comment">// [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;orange&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a><strong>相关方法</strong></h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>join(separator)</code></td>
<td>将数组转换为字符串，以 <code>separator</code> 作为连接符</td>
</tr>
<tr>
<td><code>slice(start, end)</code></td>
<td>截取数组的一部分，返回新数组</td>
</tr>
<tr>
<td><code>substring(start, end)</code></td>
<td>截取字符串的一部分，返回新字符串</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-map-方法"><a href="#2-map-方法" class="headerlink" title="2. map() 方法"></a><strong>2. <code>map()</code> 方法</strong></h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a><strong>作用</strong></h4><p><code>map()</code> 方法用于对数组中的每个元素执行提供的回调函数，并返回一个新的数组。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a><strong>语法</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">map</span>(<span class="title function_">callback</span>(currentValue, index, array))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>callback</code> 是一个执行数组中每个元素的函数，该函数接收：<ul>
<li><code>currentValue</code>：当前处理的元素</li>
<li><code>index</code>（可选）：当前元素的索引</li>
<li><code>array</code>（可选）：正在处理的数组本身</li>
</ul>
</li>
</ul>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> numArray = numbers.<span class="title function_">map</span>(<span class="title class_">Number</span>); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：<code>map(Number)</code> 是一种简写方式，等价于 <code>map(x =&gt; Number(x))</code>。</p>
</blockquote>
<h4 id="相关方法-1"><a href="#相关方法-1" class="headerlink" title="相关方法"></a><strong>相关方法</strong></h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>forEach(callback)</code></td>
<td>遍历数组但不返回新数组</td>
</tr>
<tr>
<td><code>filter(callback)</code></td>
<td>过滤数组中的元素，返回符合条件的元素组成的新数组</td>
</tr>
<tr>
<td><code>reduce(callback, initialValue)</code></td>
<td>归纳数组，计算出一个最终值</td>
</tr>
<tr>
<td><code>map()</code> vs <code>forEach()</code></td>
<td><code>map()</code> 返回新数组，<code>forEach()</code> 只是遍历，<strong>不返回新数组</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-代码解析"><a href="#3-代码解析" class="headerlink" title="3. 代码解析"></a><strong>3. 代码解析</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nums1 = nums1.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);  <span class="comment">// 按英文逗号切割成数组</span></span><br><span class="line">nums1 = nums1.<span class="title function_">map</span>(<span class="title class_">Number</span>); <span class="comment">// 将字符串数组转换为数字数组</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>split(&#39;,&#39;)</code> 将 <code>&quot;1,2,3&quot;</code> 转换为 <code>[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</code></li>
<li><code>map(Number)</code> 将 <code>[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</code> 转换为 <code>[1, 2, 3]</code></li>
</ul>
<h4 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a><strong>完整示例</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums1 = <span class="string">&quot;10,20,30,40&quot;</span>;</span><br><span class="line">nums1 = nums1.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nums1); <span class="comment">// [&quot;10&quot;, &quot;20&quot;, &quot;30&quot;, &quot;40&quot;]</span></span><br><span class="line"></span><br><span class="line">nums1 = nums1.<span class="title function_">map</span>(<span class="title class_">Number</span>);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nums1); <span class="comment">// [10, 20, 30, 40]</span></span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h4><ul>
<li><code>split()</code> 用于<strong>字符串拆分</strong></li>
<li><code>map(Number)</code> 用于<strong>字符串数组转换为数字数组</strong></li>
<li>这两者结合，常用于处理用户输入的字符串数据</li>
</ul>
<p>这样，我们就可以从 <code>input</code> 输入框中获取逗号分隔的数字，并将其转换成一个数字数组，方便后续计算！ 🚀</p>
<h2 id="提问12-请解析nums1-nums1-filter-num-isNaN-num-过滤掉无效值-中filter与num-isNaN-num-的具体语法"><a href="#提问12-请解析nums1-nums1-filter-num-isNaN-num-过滤掉无效值-中filter与num-isNaN-num-的具体语法" class="headerlink" title="提问12 请解析nums1 = nums1.filter(num =&gt; !isNaN(num)); //过滤掉无效值   中filter与num =&gt; !isNaN(num)的具体语法"></a>提问12 请解析<code>nums1 = nums1.filter(num =&gt; !isNaN(num)); //过滤掉无效值</code>   中filter与<code>num =&gt; !isNaN(num)</code>的具体语法</h2><p>这行代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nums1 = nums1.<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> !<span class="built_in">isNaN</span>(num)); <span class="comment">// 过滤掉无效值</span></span><br></pre></td></tr></table></figure>
<p>主要涉及到 <strong><code>filter()</code> 方法</strong> 和 **箭头函数 (<code>num =&gt; !isNaN(num)</code>)**，我们分别解析它们的语法和原理。</p>
<hr>
<h3 id="1-filter-方法"><a href="#1-filter-方法" class="headerlink" title="1. filter() 方法"></a><strong>1. <code>filter()</code> 方法</strong></h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a><strong>作用</strong></h4><p><code>filter()</code> 方法用于<strong>筛选数组中的元素</strong>，返回满足条件的新数组，不修改原数组。</p>
<h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a><strong>语法</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.<span class="title function_">filter</span>(<span class="title function_">callback</span>(element, index, array))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>callback</code>：返回 <code>true</code> 的元素会被保留，返回 <code>false</code> 的元素会被过滤掉。<ul>
<li><code>element</code>：当前正在处理的元素</li>
<li><code>index</code>（可选）：当前元素的索引</li>
<li><code>array</code>（可选）：当前操作的数组</li>
</ul>
</li>
</ul>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">10</span>, -<span class="number">5</span>, <span class="number">0</span>, <span class="number">8</span>, -<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> positiveNumbers = numbers.<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> num &gt; <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(positiveNumbers); <span class="comment">// [10, 8]</span></span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><code>filter()</code> 遍历数组中的每个元素</li>
<li>只有 <code>num &gt; 0</code> 为 <code>true</code> 的元素才会保留</li>
<li>最终返回 <code>[10, 8]</code></li>
</ul>
<hr>
<h3 id="2-num-isNaN-num-解析"><a href="#2-num-isNaN-num-解析" class="headerlink" title="2. num =&gt; !isNaN(num) 解析"></a><strong>2. <code>num =&gt; !isNaN(num)</code> 解析</strong></h3><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a><strong>作用</strong></h4><p>这部分是 <strong>箭头函数</strong>，用于 <code>filter()</code> 的回调，目的是<strong>剔除 NaN（非数字）元素</strong>。</p>
<h4 id="拆解分析"><a href="#拆解分析" class="headerlink" title="拆解分析"></a><strong>拆解分析</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">num =&gt; !<span class="built_in">isNaN</span>(num)</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isNaN</span>(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a><strong>语法解析</strong></h4><table>
<thead>
<tr>
<th>语法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>num =&gt; &#123;&#125;</code></td>
<td>箭头函数 (<code>num</code> 是参数)</td>
</tr>
<tr>
<td><code>isNaN(num)</code></td>
<td>判断 <code>num</code> 是否是 <code>NaN</code></td>
</tr>
<tr>
<td><code>!isNaN(num)</code></td>
<td>取反，只有 <strong>不是 <code>NaN</code> 的值</strong> 才返回 <code>true</code>，保留在数组中</td>
</tr>
</tbody></table>
<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a><strong>相关概念</strong></h4><h5 id="（1）箭头函数"><a href="#（1）箭头函数" class="headerlink" title="（1）箭头函数"></a><strong>（1）箭头函数</strong></h5><p>箭头函数 <code>num =&gt; !isNaN(num)</code> 是 <code>function(num) &#123; return !isNaN(num); &#125;</code> 的简写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isValidNumber</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isNaN</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数等价于</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isValidNumber</span> = num =&gt; !<span class="built_in">isNaN</span>(num);</span><br></pre></td></tr></table></figure>

<p><strong>箭头函数的特性：</strong></p>
<ul>
<li>省略 <code>function</code> 关键字</li>
<li>只有一个参数时，括号 <code>()</code> 可以省略</li>
<li>只有一条 <code>return</code> 语句时，大括号 <code>&#123;&#125;</code> 和 <code>return</code> 也可以省略</li>
</ul>
<h5 id="（2）isNaN-方法"><a href="#（2）isNaN-方法" class="headerlink" title="（2）isNaN() 方法"></a><strong>（2）<code>isNaN()</code> 方法</strong></h5><p><code>isNaN(num)</code> 判断某个值是否为 <code>NaN</code>（即“不是一个数字”）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&quot;123&quot;</span>));  <span class="comment">// false （&quot;123&quot; 可以转换为数字）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&quot;abc&quot;</span>));  <span class="comment">// true  （&quot;abc&quot; 不是数字）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="number">42</span>));     <span class="comment">// false （42 是有效数字）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>));    <span class="comment">// true  （NaN 本身是无效数字）</span></span><br></pre></td></tr></table></figure>
<p>所以 <code>!isNaN(num)</code> 只保留 <strong>可以转换为数字的值</strong>。</p>
<hr>
<h3 id="3-代码执行过程"><a href="#3-代码执行过程" class="headerlink" title="3. 代码执行过程"></a><strong>3. 代码执行过程</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums1 = [<span class="string">&quot;10&quot;</span>, <span class="string">&quot;20&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;30&quot;</span>, <span class="string">&quot;xyz&quot;</span>, <span class="string">&quot;40&quot;</span>];</span><br><span class="line">nums1 = nums1.<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> !<span class="built_in">isNaN</span>(num));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nums1); <span class="comment">// [&quot;10&quot;, &quot;20&quot;, &quot;30&quot;, &quot;40&quot;]</span></span><br></pre></td></tr></table></figure>

<h4 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a><strong>执行步骤</strong></h4><ol>
<li><code>filter()</code> 遍历 <code>nums1</code> 的每个元素：<ul>
<li><code>isNaN(&quot;10&quot;)</code> → <code>false</code> → <code>!false</code> → <code>true</code> → <strong>保留</strong></li>
<li><code>isNaN(&quot;20&quot;)</code> → <code>false</code> → <code>true</code> → <strong>保留</strong></li>
<li><code>isNaN(&quot;abc&quot;)</code> → <code>true</code> → <code>false</code> → <strong>过滤掉</strong></li>
<li><code>isNaN(&quot;30&quot;)</code> → <code>false</code> → <code>true</code> → <strong>保留</strong></li>
<li><code>isNaN(&quot;xyz&quot;)</code> → <code>true</code> → <code>false</code> → <strong>过滤掉</strong></li>
<li><code>isNaN(&quot;40&quot;)</code> → <code>false</code> → <code>true</code> → <strong>保留</strong></li>
</ul>
</li>
<li>只保留了 <code>[&quot;10&quot;, &quot;20&quot;, &quot;30&quot;, &quot;40&quot;]</code>，无效字符 <code>&quot;abc&quot;</code> 和 <code>&quot;xyz&quot;</code> 被移除。</li>
</ol>
<hr>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h3><ul>
<li><strong><code>filter()</code></strong> 遍历数组，保留返回 <code>true</code> 的元素。</li>
<li><strong>箭头函数 <code>num =&gt; !isNaN(num)</code></strong> 是 <code>function(num) &#123; return !isNaN(num); &#125;</code> 的简写。</li>
<li><strong><code>isNaN(num)</code></strong> 用于判断某个值是否为 <code>NaN</code>，<code>!isNaN(num)</code> 只保留有效数字。</li>
<li><strong>最终效果</strong>：过滤掉无效的非数字值，确保数组只包含数值或可转换成数值的字符串。</li>
</ul>
<hr>
<h3 id="5-进一步优化"><a href="#5-进一步优化" class="headerlink" title="5. 进一步优化"></a><strong>5. 进一步优化</strong></h3><h4 id="使用-Number-isNaN"><a href="#使用-Number-isNaN" class="headerlink" title="使用 Number.isNaN()"></a><strong>使用 <code>Number.isNaN()</code></strong></h4><p><code>isNaN()</code> 在某些情况下会有不准确的问题，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&quot;&quot;</span>));      <span class="comment">// false，空字符串会被转换成 `0`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&quot; &quot;</span>));     <span class="comment">// false，空格也会被转换成 `0`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>([]));      <span class="comment">// false，空数组 `[]` 也会被转换成 `0`</span></span><br></pre></td></tr></table></figure>
<p>改用 <strong><code>Number.isNaN()</code></strong> 以避免这些问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nums1 = nums1.<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> !<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">Number</span>(num)));</span><br></pre></td></tr></table></figure>
<p>这样可以更严格地筛选有效数字。</p>
<hr>
<p>希望这份解析能帮助你理解 <code>filter()</code> 和箭头函数的底层原理！🚀</p>
<h2 id="提问13-html块的运行逻辑"><a href="#提问13-html块的运行逻辑" class="headerlink" title="提问13 html&lt;script&gt;块的运行逻辑"></a>提问13 html<code>&lt;script&gt;</code>块的运行逻辑</h2><p>在 HTML 中，<code>&lt;script&gt;</code> 标签用于在网页中嵌入 JavaScript 代码。它的运行逻辑受 <strong>HTML 解析流程</strong>、<strong>浏览器执行顺序</strong> 和 <strong>不同属性（如 <code>defer</code> 和 <code>async</code>）</strong> 的影响。以下是详细解析：</p>
<hr>
<h3 id="1-块的运行逻辑"><a href="#1-块的运行逻辑" class="headerlink" title="1. &lt;script&gt; 块的运行逻辑"></a><strong>1. <code>&lt;script&gt;</code> 块的运行逻辑</strong></h3><h4 id="（1）普通-块（默认行为）"><a href="#（1）普通-块（默认行为）" class="headerlink" title="（1）普通 &lt;script&gt; 块（默认行为）"></a><strong>（1）普通 <code>&lt;script&gt;</code> 块（默认行为）</strong></h4><p>如果 <code>&lt;script&gt;</code> 标签<strong>不带 <code>defer</code> 或 <code>async</code> 属性</strong>，它的执行逻辑如下：</p>
<ol>
<li><strong>HTML 解析器（浏览器）按顺序解析 HTML 代码</strong>。</li>
<li><strong>遇到 <code>&lt;script&gt;</code> 标签时，HTML 解析会暂停</strong>：<ul>
<li><strong>下载并执行 JavaScript 代码</strong>。</li>
<li><strong>执行完毕后，HTML 解析才会继续</strong>。</li>
</ul>
</li>
<li>如果有多个 <code>&lt;script&gt;</code> 标签，它们会<strong>按顺序同步执行</strong>。</li>
</ol>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Script in head&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Script in body&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a><strong>执行顺序</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Script in head</span><br><span class="line">Script in body</span><br></pre></td></tr></table></figure>
<ul>
<li>当浏览器解析 <code>&lt;head&gt;</code> 内的 <code>&lt;script&gt;</code> 时，它会暂停解析，执行 JavaScript，然后继续解析 HTML。</li>
<li>解析到 <code>&lt;body&gt;</code> 的 <code>&lt;script&gt;</code>，同样会暂停 HTML 解析，执行 JavaScript，然后继续。</li>
</ul>
<hr>
<h3 id="2-defer-属性（推荐用于外部-JS-文件）"><a href="#2-defer-属性（推荐用于外部-JS-文件）" class="headerlink" title="2. defer 属性（推荐用于外部 JS 文件）"></a><strong>2. <code>defer</code> 属性（推荐用于外部 JS 文件）</strong></h3><h4 id="运行逻辑"><a href="#运行逻辑" class="headerlink" title="运行逻辑"></a><strong>运行逻辑</strong></h4><ol>
<li><strong><code>defer</code> 允许浏览器继续解析 HTML</strong>，不会阻塞页面加载。</li>
<li><strong>所有 <code>defer</code> 脚本会按照它们在 HTML 中的顺序执行</strong>，但<strong>等到 HTML 解析完成后</strong>再执行。</li>
</ol>
<h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;script1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;script2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="执行顺序-1"><a href="#执行顺序-1" class="headerlink" title="执行顺序"></a><strong>执行顺序</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTML 解析完成后，按顺序执行：</span><br><span class="line">script1.js</span><br><span class="line">script2.js</span><br></pre></td></tr></table></figure>
<ul>
<li><code>defer</code> <strong>不会阻塞 HTML 解析</strong>。</li>
<li><strong>脚本按顺序执行</strong>，即使 <code>script2.js</code> 先加载完成，也必须等 <code>script1.js</code> 执行完。</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul>
<li><strong>推荐用于外部 JS 文件</strong>，尤其是<strong>需要操作 DOM 的脚本</strong>，确保 HTML 结构先加载完成。</li>
</ul>
<hr>
<h3 id="3-async-属性（异步加载并立即执行）"><a href="#3-async-属性（异步加载并立即执行）" class="headerlink" title="3. async 属性（异步加载并立即执行）"></a><strong>3. <code>async</code> 属性（异步加载并立即执行）</strong></h3><h4 id="运行逻辑-1"><a href="#运行逻辑-1" class="headerlink" title="运行逻辑"></a><strong>运行逻辑</strong></h4><ol>
<li><strong><code>async</code> 让脚本在后台异步下载，不阻塞 HTML 解析</strong>。</li>
<li><strong>下载完成后，立即执行脚本（可能会打断 HTML 解析）</strong>。</li>
<li><strong>多个 <code>async</code> 脚本的执行顺序与它们的下载完成顺序有关</strong>，而<strong>不是它们在 HTML 中的顺序</strong>。</li>
</ol>
<h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;script1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;script2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="可能的执行顺序"><a href="#可能的执行顺序" class="headerlink" title="可能的执行顺序"></a><strong>可能的执行顺序</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（取决于哪个脚本先下载完成）</span><br><span class="line">script2.js</span><br><span class="line">script1.js</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>脚本不会按 HTML 书写顺序执行</strong>，而是哪个<strong>先下载完成，哪个先执行</strong>。</li>
<li>可能会打断 HTML 解析，导致不稳定的 DOM 操作。</li>
</ul>
<h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul>
<li><strong>适用于不依赖 DOM、不会影响其他脚本的独立功能</strong>（如统计代码、广告加载、第三方 SDK）。</li>
</ul>
<hr>
<h3 id="4-document-write-的特殊情况"><a href="#4-document-write-的特殊情况" class="headerlink" title="4. document.write() 的特殊情况"></a><strong>4. <code>document.write()</code> 的特殊情况</strong></h3><p>如果 <code>&lt;script&gt;</code> 内使用 <code>document.write()</code>，会<strong>直接往 HTML 流中插入内容</strong>，影响 HTML 解析。</p>
<h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;p&gt;This is inserted by JavaScript.&lt;/p&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="运行逻辑-2"><a href="#运行逻辑-2" class="headerlink" title="运行逻辑"></a><strong>运行逻辑</strong></h5><ol>
<li><strong>HTML 解析到 <code>&lt;script&gt;</code> 时，暂停解析</strong>。</li>
<li>**执行 <code>document.write()</code>**，立即向页面插入 HTML 内容。</li>
<li><strong>插入的内容被解析并渲染</strong>，然后继续解析 HTML。</li>
</ol>
<p><strong>⚠️ 注意：</strong></p>
<ul>
<li>在 <strong>页面加载完成后（比如在 <code>setTimeout</code> 里）使用 <code>document.write()</code></strong> 会清空整个页面：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;This will erase everything!&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></li>
<li>**现代开发不推荐 <code>document.write()</code>**，更好的方式是 <code>innerHTML</code> 或 <code>appendChild()</code>。</li>
</ul>
<hr>
<h3 id="5-放在-还是-？"><a href="#5-放在-还是-？" class="headerlink" title="5. &lt;script&gt; 放在 &lt;head&gt; 还是 &lt;body&gt;？"></a><strong>5. <code>&lt;script&gt;</code> 放在 <code>&lt;head&gt;</code> 还是 <code>&lt;body&gt;</code>？</strong></h3><table>
<thead>
<tr>
<th>位置</th>
<th>影响</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>&lt;head&gt;</code> 内部</strong></td>
<td>脚本可能会阻塞 HTML 解析，影响页面加载速度。</td>
</tr>
<tr>
<td><strong><code>&lt;/body&gt;</code> 之前</strong></td>
<td>推荐方式，先解析 HTML，最后加载 JS，提高性能。</td>
</tr>
<tr>
<td><strong><code>defer</code> + <code>&lt;head&gt;</code></strong></td>
<td>推荐用于外部 JS，HTML 解析完成后再执行，不会影响渲染。</td>
</tr>
<tr>
<td><strong><code>async</code> + <code>&lt;head&gt;</code></strong></td>
<td>适用于独立脚本，可能会影响执行顺序。</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-总结-2"><a href="#6-总结-2" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h3><table>
<thead>
<tr>
<th>方式</th>
<th>HTML 解析</th>
<th>执行顺序</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>普通 <code>&lt;script&gt;</code></strong></td>
<td><strong>阻塞</strong></td>
<td>按 HTML 书写顺序执行</td>
<td>适用于少量简单 JS</td>
</tr>
<tr>
<td><strong><code>defer</code></strong></td>
<td><strong>不阻塞</strong></td>
<td>按 HTML 书写顺序，等 HTML 解析完成后执行</td>
<td><strong>推荐方式</strong>，适用于外部 JS</td>
</tr>
<tr>
<td><strong><code>async</code></strong></td>
<td><strong>不阻塞</strong></td>
<td><strong>下载完成后立即执行，顺序不固定</strong></td>
<td>适用于独立脚本（如广告、统计代码）</td>
</tr>
<tr>
<td><strong><code>document.write()</code></strong></td>
<td><strong>阻塞</strong></td>
<td>直接插入 HTML</td>
<td><strong>不推荐</strong>，可能影响性能</td>
</tr>
</tbody></table>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h4><p>✅ <strong>推荐方式</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>🚫 <strong>避免直接在 <code>&lt;head&gt;</code> 里写 <code>&lt;script&gt;</code>（没有 <code>defer</code> 或 <code>async</code>）</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> <span class="comment">&lt;!-- 可能会阻塞 HTML 解析 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="总结一句话"><a href="#总结一句话" class="headerlink" title="总结一句话"></a><strong>总结一句话</strong></h4><p>如果你的脚本<strong>依赖 HTML 结构</strong>（如 DOM 操作），推荐 <strong><code>defer</code><strong>；如果你的脚本</strong>独立运行</strong>，可以使用 **<code>async</code>**。🚀</p>
<h2 id="提问-14-请解析const-resultDiv-document-getElementById-result-resultDiv-textContent-nums1-nums1-join-‘-‘-m-m-涉及的div相关操作与-。"><a href="#提问-14-请解析const-resultDiv-document-getElementById-result-resultDiv-textContent-nums1-nums1-join-‘-‘-m-m-涉及的div相关操作与-。" class="headerlink" title="提问 14 请解析const resultDiv = document.getElementById(&#39;result&#39;);  resultDiv.textContent = nums1: ${nums1.join(‘, ‘)}, m:${m};涉及的div相关操作与${}。"></a>提问 14 请解析<code>const resultDiv = document.getElementById(&#39;result&#39;);  resultDiv.textContent = </code>nums1: ${nums1.join(‘, ‘)}, m:${m}<code>;</code>涉及的div相关操作与${}。</h2><p>这段代码涉及 <strong>DOM 操作</strong> 和 <strong>模板字符串（<code>template literals</code>）</strong>，我们分别解析它们的工作原理。</p>
<hr>
<h3 id="1-DOM-操作解析"><a href="#1-DOM-操作解析" class="headerlink" title="1. DOM 操作解析"></a><strong>1. DOM 操作解析</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resultDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="document-getElementById-id"><a href="#document-getElementById-id" class="headerlink" title="document.getElementById(id)"></a><strong><code>document.getElementById(id)</code></strong></h4><ul>
<li><strong>作用</strong>：获取 <strong><code>id</code> 为 <code>&#39;result&#39;</code> 的 DOM 元素</strong>，返回一个 <code>HTMLElement</code> 对象。</li>
<li><strong>参数</strong>：<code>id</code>（字符串）—— 要查找的元素的 <code>id</code>。</li>
<li><strong>返回值</strong>：匹配的 <strong>HTML 元素对象</strong>，如果找不到返回 <code>null</code>。</li>
</ul>
<h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a><strong>示例</strong></h4><p>假设 HTML 结构如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resultDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(resultDiv); <span class="comment">// &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里 <code>resultDiv</code> <strong>存储了对 <code>&lt;div id=&quot;result&quot;&gt;</code> 元素的引用</strong>，我们可以通过它修改内容。</p>
<hr>
<h3 id="2-textContent-修改元素内容"><a href="#2-textContent-修改元素内容" class="headerlink" title="2. textContent 修改元素内容"></a><strong>2. <code>textContent</code> 修改元素内容</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resultDiv.<span class="property">textContent</span> = <span class="string">`nums1: <span class="subst">$&#123;nums1.join(<span class="string">&#x27;, &#x27;</span>)&#125;</span>, m:<span class="subst">$&#123;m&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<h4 id="element-textContent"><a href="#element-textContent" class="headerlink" title="element.textContent"></a><strong><code>element.textContent</code></strong></h4><ul>
<li><strong>作用</strong>：用于设置或获取 HTML 元素的<strong>文本内容</strong>，不会解析 HTML 标签。</li>
<li><strong>特点</strong>：<ul>
<li><code>textContent</code> <strong>只处理纯文本，不解析 HTML</strong>。</li>
<li>如果元素内有 <strong>子元素</strong>，使用 <code>textContent</code> 会 <strong>移除所有子元素</strong>，替换成纯文本。</li>
</ul>
</li>
</ul>
<h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span>Old Text<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>).<span class="property">textContent</span> = <span class="string">&quot;&lt;b&gt;New Text&lt;/b&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>最终：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="symbol">&amp;lt;</span>b<span class="symbol">&amp;gt;</span>New Text<span class="symbol">&amp;lt;</span>/b<span class="symbol">&amp;gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="comment">&lt;!-- 纯文本，不解析HTML --&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="与-innerHTML-的区别"><a href="#与-innerHTML-的区别" class="headerlink" title="与 innerHTML 的区别"></a><strong>与 <code>innerHTML</code> 的区别</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resultDiv.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;b&gt;New Text&lt;/b&gt;&quot;</span>;  <span class="comment">// 解析HTML</span></span><br></pre></td></tr></table></figure>
<p>最终：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>New Text<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="comment">&lt;!-- 解析HTML并显示加粗 --&gt;</span></span><br></pre></td></tr></table></figure>
<p>✅ <strong><code>textContent</code> 推荐用于纯文本，<code>innerHTML</code> 适用于动态 HTML 插入</strong>。</p>
<hr>
<h3 id="3-模板字符串（Template-Literals）"><a href="#3-模板字符串（Template-Literals）" class="headerlink" title="3. 模板字符串（Template Literals）"></a><strong>3. 模板字符串（Template Literals）</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`nums1: <span class="subst">$&#123;nums1.join(<span class="string">&#x27;, &#x27;</span>)&#125;</span>, m:<span class="subst">$&#123;m&#125;</span>`</span></span><br></pre></td></tr></table></figure>
<h4 id="模板字符串（反引号-）"><a href="#模板字符串（反引号-）" class="headerlink" title="模板字符串（反引号 ``）"></a><strong>模板字符串（反引号 <code>``</code>）</strong></h4><ul>
<li><strong>作用</strong>：允许在字符串中嵌入变量和表达式，增强可读性。</li>
<li><strong>语法</strong>：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`文本 <span class="subst">$&#123;变量&#125;</span> 其他文本`</span></span><br></pre></td></tr></table></figure></li>
<li><strong><code>$&#123;&#125;</code> 语法</strong>：<ul>
<li><strong>插入变量</strong>：<code>$&#123;变量名&#125;</code></li>
<li><strong>插入表达式</strong>：<code>$&#123;表达式&#125;</code>，如 <code>nums1.join(&#39;, &#39;)</code></li>
<li><strong>支持多行字符串</strong></li>
</ul>
</li>
</ul>
<h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>);  <span class="comment">// &quot;Hello, Alice!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Sum: <span class="subst">$&#123;a + b&#125;</span>`</span>);    <span class="comment">// &quot;Sum: 30&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="nums1-join-解析"><a href="#nums1-join-解析" class="headerlink" title="nums1.join(&#39;, &#39;) 解析"></a><strong><code>nums1.join(&#39;, &#39;)</code> 解析</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nums1.<span class="title function_">join</span>(<span class="string">&#x27;, &#x27;</span>)); <span class="comment">// &quot;1, 2, 3&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>join(&#39;, &#39;)</code></strong> 把 <code>nums1</code> 数组转换成 <strong>以 <code>, </code> 分隔的字符串</strong>，方便显示。</li>
</ul>
<h4 id="完整示例-1"><a href="#完整示例-1" class="headerlink" title="完整示例"></a><strong>完整示例</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">let</span> m = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>).<span class="property">textContent</span> = <span class="string">`nums1: <span class="subst">$&#123;nums1.join(<span class="string">&#x27;, &#x27;</span>)&#125;</span>, m:<span class="subst">$&#123;m&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<p>HTML：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最终渲染：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span>nums1: 10, 20, 30, m:3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-代码整体解析"><a href="#4-代码整体解析" class="headerlink" title="4. 代码整体解析"></a><strong>4. 代码整体解析</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resultDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>); </span><br><span class="line">resultDiv.<span class="property">textContent</span> = <span class="string">`nums1: <span class="subst">$&#123;nums1.join(<span class="string">&#x27;, &#x27;</span>)&#125;</span>, m:<span class="subst">$&#123;m&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<p><strong>执行流程</strong></p>
<ol>
<li><code>document.getElementById(&#39;result&#39;)</code> 获取 <code>id=&quot;result&quot;</code> 的 <code>&lt;div&gt;</code> 元素。</li>
<li><code>resultDiv.textContent = ...</code> 修改 <code>&lt;div&gt;</code> 的文本内容：<ul>
<li><code>nums1.join(&#39;, &#39;)</code> 转换数组为字符串。</li>
<li><code>m</code> 直接插入。</li>
<li><strong>模板字符串</strong> 拼接并赋值。</li>
</ul>
</li>
</ol>
<p><strong>最终效果</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span>nums1: 10, 20, 30, m:3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-进一步优化-1"><a href="#5-进一步优化-1" class="headerlink" title="5. 进一步优化"></a><strong>5. 进一步优化</strong></h3><h4 id="如果-resultDiv-可能不存在"><a href="#如果-resultDiv-可能不存在" class="headerlink" title="如果 resultDiv 可能不存在"></a><strong>如果 <code>resultDiv</code> 可能不存在</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resultDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (resultDiv) &#123;</span><br><span class="line">    resultDiv.<span class="property">textContent</span> = <span class="string">`nums1: <span class="subst">$&#123;nums1.join(<span class="string">&#x27;, &#x27;</span>)&#125;</span>, m:<span class="subst">$&#123;m&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样<strong>避免 <code>getElementById</code> 返回 <code>null</code> 时报错</strong>。</p>
<hr>
<h3 id="6-总结-3"><a href="#6-总结-3" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h3><table>
<thead>
<tr>
<th>语法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>document.getElementById(id)</code></td>
<td>获取 <code>id</code> 对应的 HTML 元素</td>
</tr>
<tr>
<td><code>element.textContent</code></td>
<td>设置&#x2F;获取元素的纯文本内容（不会解析 HTML）</td>
</tr>
<tr>
<td><code>element.innerHTML</code></td>
<td>设置&#x2F;获取元素的 HTML 内容（会解析 HTML）</td>
</tr>
<tr>
<td><code>`Text $&#123;变量&#125;`</code></td>
<td><strong>模板字符串</strong>，支持变量插值和表达式</td>
</tr>
<tr>
<td><code>join(&#39;, &#39;)</code></td>
<td>把数组转换成以 <code>, </code> 分隔的字符串</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong></p>
<ul>
<li><strong>使用 <code>textContent</code> 代替 <code>innerHTML</code>，防止 XSS 攻击</strong>。</li>
<li><strong>使用模板字符串 (&#96;&#96;&#96;&#96;) 让字符串拼接更清晰</strong>。</li>
<li><strong>先 <code>getElementById()</code>，再检查 <code>null</code> 以避免报错</strong>。</li>
</ul>
<p>💡 <strong>这样，代码更安全、更高效、更易读！🚀</strong></p>
<h2 id="提问15-XSS-攻击是什么？-如果-resultDiv-可能不存在，document-getElementById-‘result’-的返回值会是什么？"><a href="#提问15-XSS-攻击是什么？-如果-resultDiv-可能不存在，document-getElementById-‘result’-的返回值会是什么？" class="headerlink" title="提问15 XSS 攻击是什么？ 如果 resultDiv 可能不存在，document.getElementById(‘result’)的返回值会是什么？"></a>提问15 XSS 攻击是什么？ 如果 resultDiv 可能不存在，document.getElementById(‘result’)的返回值会是什么？</h2><h3 id="1-什么是-XSS-攻击？（跨站脚本攻击-Cross-Site-Scripting）"><a href="#1-什么是-XSS-攻击？（跨站脚本攻击-Cross-Site-Scripting）" class="headerlink" title="1. 什么是 XSS 攻击？（跨站脚本攻击 - Cross-Site Scripting）"></a><strong>1. 什么是 XSS 攻击？（跨站脚本攻击 - Cross-Site Scripting）</strong></h3><p><strong>XSS（Cross-Site Scripting）攻击</strong>是一种<strong>注入恶意脚本</strong>的安全漏洞，攻击者利用 XSS <strong>在网页中执行恶意 JavaScript 代码</strong>，从而窃取用户数据、篡改页面内容或执行其他恶意操作。</p>
<h4 id="XSS-攻击的分类"><a href="#XSS-攻击的分类" class="headerlink" title="XSS 攻击的分类"></a><strong>XSS 攻击的分类</strong></h4><ol>
<li><p><strong>存储型（Stored XSS）</strong>  </p>
<ul>
<li>恶意代码被存入数据库，每次用户访问页面时都会执行。</li>
<li>例如，在评论系统中提交一条包含 <code>&lt;script&gt;alert(&#39;XSS!&#39;)&lt;/script&gt;</code> 的评论，所有查看该评论的用户都会弹出提示框。</li>
</ul>
</li>
<li><p><strong>反射型（Reflected XSS）</strong>  </p>
<ul>
<li>恶意代码作为<strong>请求参数</strong>传输，并在网页中原样返回。</li>
<li>例如，攻击者诱导用户访问 <code>https://example.com?q=&lt;script&gt;alert(&#39;Hacked&#39;)&lt;/script&gt;</code>，如果服务器直接在 HTML 里插入 <code>q</code> 的值，就会执行恶意脚本。</li>
</ul>
</li>
<li><p><strong>DOM 型（DOM-based XSS）</strong>  </p>
<ul>
<li>发生在浏览器端，攻击者利用 JavaScript 修改 DOM，使页面执行恶意代码。</li>
<li>例如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = params.<span class="title function_">get</span>(<span class="string">&#x27;msg&#x27;</span>); <span class="comment">// 如果 msg= &lt;script&gt;alert(1)&lt;/script&gt;，会执行恶意代码</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="如何防御-XSS？"><a href="#如何防御-XSS？" class="headerlink" title="如何防御 XSS？"></a><strong>如何防御 XSS？</strong></h4><p>✅ <strong>安全做法</strong></p>
<ul>
<li>**使用 <code>textContent</code> 代替 <code>innerHTML</code>**，防止注入 HTML 代码：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resultDiv.<span class="property">textContent</span> = <span class="string">`&lt;b&gt;Safe&lt;/b&gt;`</span>;  <span class="comment">// 显示 &quot;&lt;b&gt;Safe&lt;/b&gt;&quot; 纯文本，而不会加粗</span></span><br></pre></td></tr></table></figure></li>
<li><strong>转义用户输入（服务器端防护）</strong><ul>
<li><strong>存储前</strong>：<code>&lt;script&gt;</code> 转义成 <code>&amp;lt;script&amp;gt;</code>，让浏览器不会执行。</li>
<li><strong>输出时</strong>：使用 <code>escape()</code> 或 <code>sanitize-html</code> 处理用户输入。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-document-getElementById-result-如果找不到元素会返回什么？"><a href="#2-document-getElementById-result-如果找不到元素会返回什么？" class="headerlink" title="2. document.getElementById(&#39;result&#39;) 如果找不到元素会返回什么？"></a><strong>2. <code>document.getElementById(&#39;result&#39;)</code> 如果找不到元素会返回什么？</strong></h3><p>如果 <code>id=&quot;result&quot;</code> 的元素不存在，<code>document.getElementById(&#39;result&#39;)</code> **会返回 <code>null</code>**，而不会报错。</p>
<h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a><strong>示例</strong></h4><p>假设 HTML 里<strong>没有</strong> <code>&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resultDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(resultDiv); <span class="comment">// 输出 null</span></span><br></pre></td></tr></table></figure>

<h4 id="如何避免报错？"><a href="#如何避免报错？" class="headerlink" title="如何避免报错？"></a><strong>如何避免报错？</strong></h4><p>如果 <code>resultDiv</code> 为 <code>null</code>，直接访问 <code>resultDiv.textContent</code> 会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 直接操作可能报错：Cannot set properties of null</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>).<span class="property">textContent</span> = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>✅ <strong>正确方式（先检查 <code>null</code>）</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resultDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (resultDiv) &#123;</span><br><span class="line">    resultDiv.<span class="property">textContent</span> = <span class="string">&quot;Hello, safe update!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以<strong>避免操作 <code>null</code> 导致的 JavaScript 运行错误</strong>。</p>
<hr>
<h3 id="3-关键点总结"><a href="#3-关键点总结" class="headerlink" title="3. 关键点总结"></a><strong>3. 关键点总结</strong></h3><table>
<thead>
<tr>
<th>主题</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td><strong>XSS 攻击</strong></td>
<td>恶意 JavaScript 代码被插入页面，窃取数据或破坏网站</td>
</tr>
<tr>
<td><strong>XSS 防御</strong></td>
<td><strong>使用 <code>textContent</code>，避免 <code>innerHTML</code> 直接插入不受信任的内容</strong></td>
</tr>
<tr>
<td><strong><code>document.getElementById()</code></strong></td>
<td><strong>如果找不到元素，会返回 <code>null</code>，不会报错</strong></td>
</tr>
<tr>
<td><strong>防止 <code>null</code> 错误</strong></td>
<td><strong>在操作前检查 <code>if (resultDiv) &#123;&#125;</code></strong></td>
</tr>
</tbody></table>
<p>✨ <strong>记住：<code>textContent</code> 让你安全，<code>null</code> 先检查避免崩溃！🚀</strong></p>
<h2 id="提问16-标签一般在什么情况下使用？标签有哪些type？"><a href="#提问16-标签一般在什么情况下使用？标签有哪些type？" class="headerlink" title="提问16 &lt;label&gt;标签一般在什么情况下使用？&lt;input&gt;标签有哪些type？"></a>提问16 <code>&lt;label&gt;</code>标签一般在什么情况下使用？<code>&lt;input&gt;</code>标签有哪些type？</h2><h3 id="1-标签的使用场景"><a href="#1-标签的使用场景" class="headerlink" title="1. &lt;label&gt; 标签的使用场景"></a><strong>1. <code>&lt;label&gt;</code> 标签的使用场景</strong></h3><p><code>&lt;label&gt;</code> 标签用于<strong>为表单控件（如 <code>&lt;input&gt;</code>）提供可点击的文本</strong>，增强用户体验和可访问性（Accessibility）。</p>
<h4 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a><strong>主要作用</strong></h4><p>✅ <strong>点击 <code>&lt;label&gt;</code> 让相关 <code>&lt;input&gt;</code> 获得焦点</strong><br>✅ <strong>提升无障碍访问（屏幕阅读器支持）</strong><br>✅ <strong>增强表单可用性</strong></p>
<h4 id="两种正确的用法"><a href="#两种正确的用法" class="headerlink" title="两种正确的用法"></a><strong>两种正确的用法</strong></h4><h5 id="（1）使用-for-关联-id"><a href="#（1）使用-for-关联-id" class="headerlink" title="（1）使用 for 关联 id"></a><strong>（1）使用 <code>for</code> 关联 <code>id</code></strong></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>for=&quot;username&quot;</code> 关联 <code>id=&quot;username&quot;</code> 的输入框，点击“用户名”时，光标会进入输入框。</li>
</ul>
<h5 id="（2）直接包裹-input"><a href="#（2）直接包裹-input" class="headerlink" title="（2）直接包裹 input"></a><strong>（2）直接包裹 <code>input</code></strong></h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;agree&quot;</span>&gt;</span> 我同意条款</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>点击整个文本和复选框都能触发选择</strong>，更方便用户操作。</li>
</ul>
<h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul>
<li><strong>文本输入框</strong>：用户名、密码、邮箱等。</li>
<li><strong>单选按钮（radio）和复选框（checkbox）</strong>：增强点击区域，提高可用性。</li>
<li><strong>提升可访问性</strong>：屏幕阅读器更容易识别表单控件。</li>
</ul>
<hr>
<h3 id="2-标签的-type-属性"><a href="#2-标签的-type-属性" class="headerlink" title="2. &lt;input&gt; 标签的 type 属性"></a><strong>2. <code>&lt;input&gt;</code> 标签的 <code>type</code> 属性</strong></h3><p><code>&lt;input&gt;</code> 标签是 HTML 表单的核心元素，<code>type</code> 属性决定了输入控件的行为和样式。</p>
<h4 id="常见-type-类型"><a href="#常见-type-类型" class="headerlink" title="常见 type 类型"></a><strong>常见 <code>type</code> 类型</strong></h4><table>
<thead>
<tr>
<th><code>type</code> 值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>text</code></strong></td>
<td>单行文本输入框</td>
</tr>
<tr>
<td><strong><code>password</code></strong></td>
<td>隐藏输入内容（如密码）</td>
</tr>
<tr>
<td><strong><code>email</code></strong></td>
<td>电子邮件地址（验证格式）</td>
</tr>
<tr>
<td><strong><code>number</code></strong></td>
<td>只能输入数字（带增减按钮）</td>
</tr>
<tr>
<td><strong><code>tel</code></strong></td>
<td>电话号码输入</td>
</tr>
<tr>
<td><strong><code>url</code></strong></td>
<td>网址输入（需符合 URL 格式）</td>
</tr>
<tr>
<td><strong><code>search</code></strong></td>
<td>搜索框（可能带清除按钮）</td>
</tr>
</tbody></table>
<h4 id="选择类"><a href="#选择类" class="headerlink" title="选择类"></a><strong>选择类</strong></h4><table>
<thead>
<tr>
<th><code>type</code> 值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>radio</code></strong></td>
<td>单选按钮（多个选项中选一个）</td>
</tr>
<tr>
<td><strong><code>checkbox</code></strong></td>
<td>复选框（可多选）</td>
</tr>
<tr>
<td><strong><code>select</code>（下拉框）</strong></td>
<td>不是 <code>input</code> 但也用于选择</td>
</tr>
</tbody></table>
<h4 id="日期-时间"><a href="#日期-时间" class="headerlink" title="日期 &amp; 时间"></a><strong>日期 &amp; 时间</strong></h4><table>
<thead>
<tr>
<th><code>type</code> 值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>date</code></strong></td>
<td>选择日期（YYYY-MM-DD）</td>
</tr>
<tr>
<td><strong><code>time</code></strong></td>
<td>选择时间（HH:MM）</td>
</tr>
<tr>
<td><strong><code>datetime-local</code></strong></td>
<td>日期 + 时间（无时区）</td>
</tr>
<tr>
<td><strong><code>month</code></strong></td>
<td>选择月份</td>
</tr>
<tr>
<td><strong><code>week</code></strong></td>
<td>选择周</td>
</tr>
</tbody></table>
<h4 id="按钮-文件上传"><a href="#按钮-文件上传" class="headerlink" title="按钮 &amp; 文件上传"></a><strong>按钮 &amp; 文件上传</strong></h4><table>
<thead>
<tr>
<th><code>type</code> 值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>submit</code></strong></td>
<td>提交表单</td>
</tr>
<tr>
<td><strong><code>reset</code></strong></td>
<td>重置表单</td>
</tr>
<tr>
<td><strong><code>button</code></strong></td>
<td>普通按钮（无默认行为）</td>
</tr>
<tr>
<td><strong><code>file</code></strong></td>
<td>选择文件上传</td>
</tr>
<tr>
<td><strong><code>image</code></strong></td>
<td>作为提交按钮的图片</td>
</tr>
</tbody></table>
<h4 id="特殊输入"><a href="#特殊输入" class="headerlink" title="特殊输入"></a><strong>特殊输入</strong></h4><table>
<thead>
<tr>
<th><code>type</code> 值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>color</code></strong></td>
<td>颜色选择器</td>
</tr>
<tr>
<td><strong><code>range</code></strong></td>
<td>滑动条选择数值</td>
</tr>
<tr>
<td><strong><code>hidden</code></strong></td>
<td>隐藏字段，不显示在页面上</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-综合示例"><a href="#3-综合示例" class="headerlink" title="3. 综合示例"></a><strong>3. 综合示例</strong></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>邮箱：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subscribe&quot;</span>&gt;</span> 订阅新闻</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;color&quot;</span>&gt;</span>选择颜色：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span> <span class="attr">id</span>=<span class="string">&quot;color&quot;</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-重点总结"><a href="#4-重点总结" class="headerlink" title="4. 重点总结"></a><strong>4. 重点总结</strong></h3><p>✅ <strong><code>&lt;label&gt;</code> 让表单更易用，使用 <code>for=&quot;id&quot;</code> 关联或包裹 <code>input</code></strong><br>✅ <strong><code>input</code> 的 <code>type</code> 决定输入行为，如 <code>text</code>、<code>password</code>、<code>email</code>、<code>date</code> 等</strong><br>✅ <strong>推荐使用 <code>required</code>、<code>pattern</code> 等属性，提升表单体验</strong>  </p>
<p>🔹 <strong>正确使用 <code>&lt;label&gt;</code> 和 <code>&lt;input&gt;</code> 可以提高用户体验和无障碍支持！ 🚀</strong></p>
<h2 id="提问17-订阅新闻-中的name是什么字段？"><a href="#提问17-订阅新闻-中的name是什么字段？" class="headerlink" title="提问17   订阅新闻 中的name是什么字段？"></a>提问17  <input type="checkbox" name="subscribe"> 订阅新闻 中的name是什么字段？</h2><p>在 <code>&lt;input type=&quot;checkbox&quot; name=&quot;subscribe&quot;&gt;</code> 这段代码中，<code>name=&quot;subscribe&quot;</code> 代表的是 <strong>表单字段的名称（name 属性）</strong>，它的作用如下：  </p>
<hr>
<h3 id="1-name-属性的作用"><a href="#1-name-属性的作用" class="headerlink" title="1. name 属性的作用"></a><strong>1. <code>name</code> 属性的作用</strong></h3><ol>
<li><p><strong>用于表单提交时标识数据</strong>  </p>
<ul>
<li>当用户提交表单时，表单会将 <code>name</code> 作为 <strong>键（Key）</strong>，将用户选择的值作为 <strong>值（Value）</strong>，一起发送到服务器。  </li>
<li>例如：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/subscribe&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subscribe&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yes&quot;</span>&gt;</span> 订阅新闻</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>如果勾选了复选框，提交的数据为：</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subscribe=yes</span><br></pre></td></tr></table></figure></li>
<li><strong>如果没有勾选，提交时不会包含 <code>subscribe</code> 这个字段</strong>。</li>
</ul>
</li>
<li><p><strong>在 JavaScript 中获取复选框值</strong></p>
<ul>
<li><code>name</code> 可以用作 JavaScript 访问和操作表单字段的标识符：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> checkbox = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[name=&quot;subscribe&quot;]&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(checkbox.<span class="property">checked</span>); <span class="comment">// true（选中） or false（未选中）</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>多个复选框共享同一个 <code>name</code></strong></p>
<ul>
<li>如果多个复选框 **有相同的 <code>name</code>**，并且都被选中，提交时会以数组的形式传输：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;reading&quot;</span>&gt;</span> 阅读</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sports&quot;</span>&gt;</span> 运动</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;music&quot;</span>&gt;</span> 音乐</span><br></pre></td></tr></table></figure></li>
<li>**如果用户勾选了”阅读”和”运动”**，提交的数据可能会是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hobby=reading&amp;hobby=sports</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-name-vs-id-的区别"><a href="#2-name-vs-id-的区别" class="headerlink" title="2. name vs id 的区别"></a><strong>2. <code>name</code> vs <code>id</code> 的区别</strong></h3><table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>作用范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td><strong>用于表单数据提交</strong>，服务器识别</td>
<td><strong>表单提交时传递数据</strong></td>
</tr>
<tr>
<td><code>id</code></td>
<td><strong>用于唯一标识 HTML 元素</strong>，供 CSS 和 JS 选择</td>
<td><strong>仅在当前 HTML 文档内有效</strong></td>
</tr>
</tbody></table>
<h4 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;subscribe&quot;</span>&gt;</span>订阅新闻<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;subscribe&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subscribe&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>for=&quot;subscribe&quot;</code> 绑定 <code>id=&quot;subscribe&quot;</code>，使用户可以点击文本来勾选复选框。</li>
<li><code>name=&quot;subscribe&quot;</code> 用于表单提交。</li>
</ul>
<hr>
<h3 id="3-重点总结"><a href="#3-重点总结" class="headerlink" title="3. 重点总结"></a><strong>3. 重点总结</strong></h3><p>✅ <code>name</code> <strong>用于表单提交</strong>，服务器会通过它来接收数据。<br>✅ **复选框未选中时，不会提交 <code>name</code>**，避免数据冗余。<br>✅ <strong>多个复选框可以共享相同 <code>name</code>，以数组形式提交多个值</strong>。<br>✅ <code>name</code> 和 <code>id</code> <strong>不要混用</strong>，<code>id</code> 主要用于 CSS&#x2F;JS，<code>name</code> 用于提交数据。  </p>
<p>💡 <strong>如果复选框没有 <code>name</code>，即使勾选了，也不会在表单提交时传输！</strong> 🚀</p>
]]></content>
      <categories>
        <category>major</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>250303前端复健记录</title>
    <url>/2025/03/03/250303%E5%89%8D%E7%AB%AF%E5%A4%8D%E5%81%A5%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="前端板块（html-css-javascript，以及用javascript写算法题）"><a href="#前端板块（html-css-javascript，以及用javascript写算法题）" class="headerlink" title="前端板块（html+css+javascript，以及用javascript写算法题）"></a>前端板块（html+css+javascript，以及用javascript写算法题）</h1><p>前言：<br>复健！目标还是训练出能够从零开始写代码的能力（当然还是从vscode的<code>!+Enter</code>产生出的基本内容为基础~）。<br>说明：个人一年多前较系统地学习过web前端三件套，因此结合实际条件，笔记输出是个人理解+AI辅助，AI生成内容如果与已有理解相符，不额外进行确认。若要保证正确性，请自行通过附录中的回答原文评估。涉及到AI生成相关内容，会以<code>(附录-提问Id)</code>的形式提及。</p>
<p>先从kimi生成出的代码的照搬入手，从html-&gt;js-&gt;css的方向重温代码结构与作用的理解。<br>（这部分更加生疏也会解释地更加详细。另外，个人理念是，掌握好会的，以项目为基础，因此本身会存在知识体系的盲区，请辩证看待）</p>
<p>知识补充：（附录-提问01）<br>    注释：HTML注释使用 <code>&lt;!--</code> 和 <code>--&gt;</code> 包裹；CSS注释使用 <code>/*</code> 和 <code>*/</code> 包裹；JS单行注释以 <code>//</code> 开头；JS多行注释以 <code>/*</code> 开头，以 <code>*/</code> 结尾。</p>
<p>在“照搬”过程中，发现一件趣事：生成的网页自动居中，但是没有找到<code>text-align</code>的相关样式。尝试通过逐步补充css样式，确认到底是什么原因触发了居中。<br><img style="display:block" src="/2025/03/03/250303%E5%89%8D%E7%AB%AF%E5%A4%8D%E5%81%A5%E8%AE%B0%E5%BD%95/001居中显示情况.png" alt="001居中显示情况"><br>在调试样式的过程中，我发现我对页面呈现出的“居中”效果描述有误。它实际上是<code>.container&#123;max-width: 600px; margin: 0 auto;&#125;</code>样式下，在1382px×762px的窗口大小下，<code>block</code>元素的位置居中。实际上，文本之类的显示还是默认的<code>text-align: left;</code>。</p>
<p>知识补充：（附录-提问02）<br>    - <code>margin: 0 auto;</code> 是以下属性的简写：<br>    <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin-left</span>: auto;</span><br><span class="line"><span class="attribute">margin-right</span>: auto;</span><br></pre></td></tr></table></figure><br>    - <code>auto</code> 值会让浏览器自动计算左右外边距，使元素在其父容器中水平居中。<br>    - 要使 <code>margin: 0 auto;</code> 生效，元素必须满足以下条件：<br>        - 元素必须是<strong>块级元素</strong>（默认宽度为父容器的 100%）<br>        - 元素必须有<strong>明确的宽度</strong>，如果元素的宽度是 <code>auto</code>（默认值），它会占据父容器的整个宽度<br>        - 父容器必须有<strong>足够的空间</strong>，父容器的宽度必须大于元素的宽度，否则元素无法居中。（相关：附录-提问04）</p>
<p>我个人温习的思路是：先实现html部分元素与css之间样式的联动，之后再进行html与js之间的联动，调试JavaScirpt的具体逻辑。<br>对于题目（001），截取其数组<code>[]</code>内的部分输入文本框中。先只考虑<code>nums1</code>与<code>m</code>两个元素。进行一个截取<code>nums1</code>中前<code>m</code>个元素的子功能测试。（这里用到JavaScript 的对数组的 slice() 方法）</p>
<ul>
<li><input disabled type="checkbox"> map函数的详细应用</li>
</ul>
]]></content>
      <categories>
        <category>major</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>250303算法复健记录</title>
    <url>/2025/03/03/250303%E7%AE%97%E6%B3%95%E5%A4%8D%E5%81%A5%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>前言：<br>借助AI工具，代码能力有所下降。<br>面向就业，查考“纯手写代码”能力。<br>因此，复健！</p>
<p>基本目标：对任何题目，必须完整完成输入、输出的代码编写。（点名LeetCode这一“纵容偷懒”的网站）<br>与此同时，记录基本的，可复用的代码结构。</p>
<hr>
<h2 id="001-88-合并两个有序数组-from-LeetCode"><a href="#001-88-合并两个有序数组-from-LeetCode" class="headerlink" title="001.88. 合并两个有序数组 from LeetCode"></a>001.<a href="https://leetcode.cn/problems/merge-sorted-array/description" target="_blank">88. 合并两个有序数组 from LeetCode</a></h2><p>具体题解请查看网页。这是一道很简单的题目。<br>主要是手写处理输入输出的部分。<br>对于向量，存储类型为<code>vector&lt;TYPE&gt;</code>，输入形式是<code>[1,2,3]</code>。这对输入处理提出了要求。<br>由于各元素并不是<code>&quot; &quot; &quot;\n&quot;</code>这种友好的分隔，因此不能只用到<code>cin</code>了，我立即想到了处理单个元素的<code>getchar()</code>方法。<br>个人代码风格，估计自己肯定一遍写不出正确代码，因此在初次写代码过程中就写了些debug用的调试代码。<br>由于打算做一系列LeetCode的题目，输入部分必定要复用，因此vector指定类型时用到了TYPE，这样复用时修改TYPE的define就行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE int</span></span><br><span class="line"><span class="type">bool</span> debug_flag  = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_int_from_char</span><span class="params">(<span class="type">char</span>&amp; c)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">int</span>(c) - (<span class="type">int</span>)<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) != <span class="string">&#x27;,&#x27;</span> &amp;&amp; c != <span class="string">&#x27; &#x27;</span> &amp;&amp; c!=<span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (debug_flag) cout &lt;&lt;<span class="string">&quot;In get_int_from_char:&quot;</span>&lt;&lt;c;</span><br><span class="line">		num *= <span class="number">10</span>;</span><br><span class="line">		num += <span class="built_in">int</span>(c) - (<span class="type">int</span>)<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (debug_flag) cout &lt;&lt; <span class="string">&quot;In get_int_from_char, num is :&quot;</span> &lt;&lt; num &lt;&lt; endl;;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getVector</span><span class="params">(vector&lt;TYPE&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 假定[是左界，]是右界，元素内分隔用&#x27;,&#x27;或&#x27; &#x27;。即[1 , 2 , 3]的形式</span></span><br><span class="line">	<span class="type">char</span> c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">while</span> (c == <span class="string">&#x27;\n&#x27;</span> || c==<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">		c = <span class="built_in">getchar</span>();</span><br><span class="line">		<span class="keyword">if</span> (debug_flag) cout &lt;&lt; <span class="string">&quot;In getVector First filter:&quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (debug_flag &amp;&amp; c != <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Error in function getVector: get unexpected input:&quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (c != <span class="string">&#x27;]&#x27;</span> &amp;&amp; (c = <span class="built_in">getchar</span>()) != <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;,&#x27;</span> || c == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (is_same&lt;TYPE, <span class="type">int</span>&gt;::value) &#123;</span><br><span class="line">			<span class="keyword">if</span> (debug_flag) &#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;TYPE is int!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			vec.<span class="built_in">push_back</span>( <span class="built_in">get_int_from_char</span>(c) );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cout_Vector</span><span class="params">(vector&lt;TYPE&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (debug_flag) cout &lt;&lt; <span class="string">&quot;Enter function cout_vector&quot;</span> &lt;&lt; endl;</span><br><span class="line">	vector&lt;TYPE&gt;::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; iter != vec.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">		cout &lt;&lt; *iter &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>知识补充：（内容选自KIMI.AI生成的内容，应用时最好自行查找文章印证）<br>在C++中，#define 是预处理器指令，用于简单的文本替换。#define 的作用是在预处理阶段将代码中的 TYPE 替换为 int，而不会保留任何关于 TYPE 的类型信息。<br>在C++中，std::vector 的迭代器需要通过成员函数（如 begin() 或 end()）来获取。示例：<code>std::vector&lt;TYPE&gt;::iterator iter = vec.begin();</code><br><code>&lt;type_traits&gt;</code> 是 C++ 标准库中的一个头文件，它提供了一组模板类和函数，用于在编译时检查和操作类型的各种属性。这些功能通常被称为“类型特征”（Type Traits），它们在模板编程、元编程以及需要类型检查或类型转换的场景中非常有用。对几个基本元素进行判断的示例如下：<br>    std::is_integral<T>::value; &#x2F;&#x2F; 检查 T 是否为整数类型<br>    std::is_floating_point<T>::value; &#x2F;&#x2F; 检查 T 是否为浮点类型<br>    std::is_class<T>::value; &#x2F;&#x2F; 检查 T 是否为类类型<br>这里也用到类型关系检查的方法，类型关系检查用法示例如下：<br>    std::is_same&lt;T1, T2&gt;::value; &#x2F;&#x2F; 检查 T1 和 T2 是否为同一类型<br>    std::is_convertible&lt;T1, T2&gt;::value; &#x2F;&#x2F; 检查 T1 是否可以隐式转换为 T2<br>    std::is_base_of&lt;Base, Derived&gt;::value; &#x2F;&#x2F; 检查 Base 是否为 Derived 的基类<br><type_traits>的所有类型特征的检查都在编译时完成，不会引入运行时开销</type_traits></T></T></T></p>
<h2 id="002-55-跳跃游戏-from-LeetCode"><a href="#002-55-跳跃游戏-from-LeetCode" class="headerlink" title="002.55. 跳跃游戏 from LeetCode"></a>002.<a href="https://leetcode.cn/problems/jump-game/description" target="_blank">55. 跳跃游戏 from LeetCode</a></h2><p>也是很基础的题目。题目解释看网页。<br>没有额外说明。</p>
<h2 id="003-42-接雨水-from-LeetCode"><a href="#003-42-接雨水-from-LeetCode" class="headerlink" title="003.42. 接雨水 from LeetCode"></a>003.<a href="https://leetcode.cn/problems/trapping-rain-water" target="_blank">42. 接雨水 from LeetCode</a></h2><p>这道题被LeetCode定为困难，的确需要一些分析思考。分析思考写注释里了。<br>我的输入函数依然可以复用。（另开文件就重新写一遍了）<br>展示一下思路，顺带展示一下调用的方法（要实际运行，需要把上面的那段头文件include+辅助函数定义也加入）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution42</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 看起来是找边界的题目。如果非严格递增或递减，就会有“坑”积水</span></span><br><span class="line">		<span class="comment">// 该水平坐标积水还是看左右侧的各自最大值（记为left right），取二者间的较小值减去该水平坐标柱子高度</span></span><br><span class="line">		<span class="comment">// 要知道left right,两次遍历一定能成；思考能否只遍历一次</span></span><br><span class="line">		<span class="comment">// 可以先记录左右两侧最大边界，往中间移动，只要始终移动边界高度较小的一方，就能实时计算水平坐标处的积水值。</span></span><br><span class="line">		<span class="type">int</span> r_index = height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">		<span class="type">int</span> l_index = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> r_height = height[r_index];</span><br><span class="line">		<span class="type">int</span> l_height = height[l_index];</span><br><span class="line">		<span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (l_index &lt; r_index<span class="number">-1</span>) &#123;<span class="comment">// index表示该下标已经被计算过了，判断后不能继续++or--，即二者相邻时就得停止了</span></span><br><span class="line">			<span class="keyword">if</span> (l_height &lt; r_height) &#123;<span class="comment">// 左边界向右移动；且左边界“较低”，即=min(left,right)</span></span><br><span class="line">				l_index++;</span><br><span class="line">				<span class="keyword">if</span> (height[l_index] &lt; l_height) </span><br><span class="line">				&#123;total += l_height - height[l_index];&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;l_height = height[l_index];&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">// 右边界向左移动；且右边界“较低”，即=min(left,right)</span></span><br><span class="line">				r_index--;</span><br><span class="line">				<span class="keyword">if</span> (height[r_index] &lt; r_height)</span><br><span class="line">				&#123;total += r_height - height[r_index];&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123; r_height = height[r_index]; &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Solution42 output is:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 42. 接雨水 from LeetCode</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; arr1;</span><br><span class="line">	<span class="built_in">getVector</span>(arr1);</span><br><span class="line">	Solution42 solution;</span><br><span class="line">	solution.<span class="built_in">check</span>(solution.<span class="built_in">trap</span>(arr1));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="004-151-反转字符串中的单词-from-LeetCode"><a href="#004-151-反转字符串中的单词-from-LeetCode" class="headerlink" title="004.151. 反转字符串中的单词 from LeetCode"></a>004.<a href="https://leetcode.cn/problems/reverse-words-in-a-string" target="_blank">151. 反转字符串中的单词 from LeetCode</a></h2><p>挑了个字符串的题目。看上去可以只用string库的方法完成。练练字符串的处理。这是一道很经典的题目。<br>输入是string类型，因此include<code>&lt;string&gt;</code>，虽然cin可以输入到string类型中，但cin会以空格与换行符为分隔，无法输入含空格的完整输入。搜索后，发现需要使用getline()方法。</p>
<p>知识补充：（Deepseek AI生成的内容，实际应用请自行核实真伪，验证真实可以告知作者）<br><code>std::getline</code> 是 C++ 标准库中的一个函数，用于从输入流中读取一行文本。它通常用于从文件或标准输入（如键盘）中读取字符串，直到遇到换行符或指定的分隔符。<br>std::string line; &#x2F;&#x2F; line的定义<br>&#x2F;&#x2F; 从标准输入读取一行<br>std::getline(std::cin, line);<br>&#x2F;&#x2F; 从标准输入读取，直到遇到逗号<br>std::getline(std::cin, line, ‘,’);<br>打开 <code>example.txt</code> 文件，并逐行读取文件内容，直到文件结束<br>std::ifstream file(“example.txt”);<br>std::string line;<br>if (file.is_open()) {<br>    while (std::getline(file, line)) {<br>        std::cout &lt;&lt; line &lt;&lt; std::endl;<br>    }<br>    file.close();<br>}<br>如果要输入到char数组中，而非string中：<br>const int bufferSize &#x3D; 100; &#x2F;&#x2F; 定义缓冲区大小<br>char buffer[bufferSize];    &#x2F;&#x2F; 定义一个 char 数组<br>std::cout &lt;&lt; “Enter a line of text: “;<br>std::cin.getline(buffer, bufferSize); &#x2F;&#x2F; 读取一行到 char 数组</p>
<p>事实证明，字符串处理这方法，我确实是“眼高手低，’文杂’倒一”（后半句是高中时他人的调侃）。倒是必须通过实际应用才能重建对字符串处理方法的理解。<br>我思索过后，决定添加“要在string进行原地操作”的额外限制。不引入外部数据结构。<br>在string上进行原地操作，最主要还是得想到“reverse两次就是原单词”的思路。<code>string对象</code>的<code>reverse()</code>方法需要通过<code>&lt;algorithm&gt;</code>导入，在面试场景下得ban掉。因此要自己实现一个<code>reverse()</code>方法。<br>另外，随机访问string，有<code>str.at(pos)</code>和<code>str[pos]</code>两种主要方法；另外有通过<code>str.begin()</code>与<code>str.end()</code>的迭代器访问方法。这里暂时忽略迭代器方法。<br>了解怎么访问后，实现还是比较简单的。</p>
<h3 id="reverse方法的自定义实现"><a href="#reverse方法的自定义实现" class="headerlink" title="reverse方法的自定义实现"></a>reverse方法的自定义实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse_a_word</span><span class="params">(string&amp; s, <span class="type">int</span> l_index, <span class="type">int</span> r_index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 注：处理下标为闭区间[l_index,r_index]</span></span><br><span class="line">	<span class="comment">//bool debug_flag = false;</span></span><br><span class="line">	<span class="type">char</span> temp = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (debug_flag) cout &lt;&lt; <span class="string">&quot;In sulution151 reverse_a_word. string s, l_index,r_index are:&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; l_index &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r_index &lt;&lt; endl;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; l+r &lt; r_index-l_index; l++, r++) &#123;</span><br><span class="line">		temp = s.<span class="built_in">at</span>(l_index+l);</span><br><span class="line">		s.<span class="built_in">at</span>(l_index + l) = s.<span class="built_in">at</span>(r_index - r);</span><br><span class="line">		s.<span class="built_in">at</span>(r_index - r) = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初版代码：原地完成，主要使用find和reverse"><a href="#初版代码：原地完成，主要使用find和reverse" class="headerlink" title="初版代码：原地完成，主要使用find和reverse"></a>初版代码：原地完成，主要使用find和reverse</h3><p>直接考虑到主要使用find和reverse，缓慢地写出并修改出了以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 查找空格的位置；</span></span><br><span class="line">	<span class="comment">// 确定待处理区间的闭区间下标(l_flame r_flame)</span></span><br><span class="line">	<span class="comment">//看题解，突然想到，不如reverse+find？reverse不能用，但也可以自己写</span></span><br><span class="line">	<span class="type">int</span> l_flame = <span class="number">-1</span>;<span class="comment">//记录最左侧空格的合法位置</span></span><br><span class="line">	<span class="type">int</span> r_flame = s.<span class="built_in">size</span>();<span class="comment">//确认待处理最大下标（闭区间）</span></span><br><span class="line">	<span class="keyword">while</span> (r_flame&gt;<span class="number">0</span> &amp;&amp; s[r_flame - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123; s.<span class="built_in">erase</span>(r_flame - <span class="number">1</span>, <span class="number">1</span>); r_flame--; &#125;</span><br><span class="line">	<span class="type">int</span> space_index = <span class="number">0</span>;</span><br><span class="line">	<span class="type">bool</span> debug_flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (l_flame + <span class="number">1</span> &lt;r_flame) &#123;</span><br><span class="line">		<span class="comment">// 执行过程中，如果find返回了string::npos，space_index被赋值为-1，(space_index == string::npos)能正常运行。</span></span><br><span class="line">		<span class="keyword">if</span> (debug_flag) cout &lt;&lt; <span class="string">&quot;Now l_flame is:&quot;</span> &lt;&lt; l_flame &lt;&lt; <span class="string">&quot; r_flame is:&quot;</span> &lt;&lt; r_flame &lt;&lt; endl;</span><br><span class="line">		space_index = s.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>, (l_flame+<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span> (debug_flag) cout &lt;&lt; <span class="string">&quot;Now space_index is:&quot;</span> &lt;&lt; space_index &lt;&lt; <span class="string">&quot;find return:&quot;</span>&lt;&lt; s.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>, l_flame + <span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">		<span class="comment">//如果没有空格，不用处理，返回原字符串; 在 C++ 中，string::npos 是一个常量，表示 size_t 类型的最大值;这里假定length不超过size_t</span></span><br><span class="line">		<span class="keyword">if</span> (space_index == string::npos) &#123; </span><br><span class="line">			<span class="keyword">if</span> (debug_flag) cout&lt;&lt; <span class="string">&quot;Enter checkpoint&quot;</span> &lt;&lt; endl; </span><br><span class="line">			space_index = r_flame;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (space_index == l_flame + <span class="number">1</span>) &#123; <span class="keyword">if</span> (debug_flag) cout &lt;&lt; <span class="string">&quot;Enter checkpoint2 space_index:|&quot;</span> &lt;&lt;space_index &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; endl;  s.<span class="built_in">erase</span>(space_index, <span class="number">1</span>); r_flame--; <span class="keyword">if</span> (debug_flag) cout &lt;&lt;<span class="string">&quot;checkpoint3:|&quot;</span> &lt;&lt; s &lt;&lt;<span class="string">&quot;|&quot;</span> &lt;&lt; endl; <span class="keyword">continue</span>; &#125;</span><br><span class="line">		<span class="built_in">reverse_a_word</span>(s, l_flame+<span class="number">1</span> ,space_index<span class="number">-1</span>);</span><br><span class="line">		l_flame = space_index;</span><br><span class="line">		<span class="keyword">if</span> (debug_flag) cout &lt;&lt; <span class="string">&quot;Checkpoint2 Now l_flame is:&quot;</span> &lt;&lt; l_flame &lt;&lt; <span class="string">&quot; r_flame is:&quot;</span> &lt;&lt; r_flame &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (r_flame == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">	<span class="built_in">reverse_a_word</span>(s, <span class="number">0</span>, r_flame<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码的执行用时3ms，在LeetCode的排名中算是慢的。find与erase的实现逻辑概括如下：（内容源于KIMI AI生成，请自行辨别）</p>
<h3 id="1-std-string-find-的实现原理"><a href="#1-std-string-find-的实现原理" class="headerlink" title="1. std::string::find 的实现原理"></a>1. <code>std::string::find</code> 的实现原理</h3><p><code>std::string::find</code> 用于在字符串中查找指定的字符或子串，并返回其首次出现的位置。它的实现基于简单的线性搜索算法。</p>
<h4 id="实现细节："><a href="#实现细节：" class="headerlink" title="实现细节："></a>实现细节：</h4><ol>
<li><strong>线性搜索</strong>：从指定的起始位置 <code>pos</code> 开始，逐个字符地比较，直到找到匹配的子串或字符。</li>
<li><strong>返回值</strong>：如果找到匹配的子串，返回其起始位置；如果未找到，则返回 <code>std::string::npos</code>。</li>
<li><strong>时间复杂度</strong>：最坏情况下为 **O(n)**，其中 n 是字符串的长度。</li>
</ol>
<h3 id="2-std-string-erase-的实现原理"><a href="#2-std-string-erase-的实现原理" class="headerlink" title="2. std::string::erase 的实现原理"></a>2. <code>std::string::erase</code> 的实现原理</h3><p><code>std::string::erase</code> 用于删除字符串中从指定位置开始的若干字符。它的实现基于内存移动操作。</p>
<h4 id="实现细节：-1"><a href="#实现细节：-1" class="headerlink" title="实现细节："></a>实现细节：</h4><ol>
<li><strong>内存移动</strong>：删除指定范围的字符后，需要将后续的字符向前移动，以填补删除后的空位。</li>
<li><strong>时间复杂度</strong>：为 **O(n)**，其中 n 是字符串的长度。这是因为删除操作可能需要移动大量字符。</li>
<li><strong>边界检查</strong>：如果指定的删除范围超出字符串的实际范围，行为是未定义的。</li>
</ol>
<h3 id="进一步的优化"><a href="#进一步的优化" class="headerlink" title="进一步的优化"></a>进一步的优化</h3><p>在上面这段代码中，多次调用了find与erase，重复地在内存中进行搜索与移动。对于find，在这个问题中，其实单次遍历就可以获得所有需要的信息。对于erase，由于最后输出的字符串可能需要裁剪，因此必定要使用，但要尽可能降低使用次数。<br>基于这些思考，我继续对已有代码进行优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 改进版本01. 先颠倒字符，再颠倒整个字符</span></span><br><span class="line">	<span class="comment">//int s_len = s.size();</span></span><br><span class="line">	<span class="comment">//int left = -1;</span></span><br><span class="line">	<span class="comment">//for (int i = 0; i &lt; s_len;) &#123;</span></span><br><span class="line">	<span class="comment">//	if (s[i] == &#x27; &#x27;) &#123;</span></span><br><span class="line">	<span class="comment">//		if (i - left &lt;= 1) &#123; s.erase(i, 1); s_len--; continue; &#125;</span></span><br><span class="line">	<span class="comment">//		else &#123;</span></span><br><span class="line">	<span class="comment">//			reverse_a_word(s, left+1, i-1);</span></span><br><span class="line">	<span class="comment">//			left = i;</span></span><br><span class="line">	<span class="comment">//		&#125;</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	i++;</span></span><br><span class="line">	<span class="comment">//&#125;// 注：如果最后右边有（一个）空格，单词全会正确颠倒，需删掉该空格</span></span><br><span class="line">	<span class="comment">//// 如果没有，最后一个单词并不会被颠倒，需要补充颠倒</span></span><br><span class="line">	<span class="comment">//if (s_len == 0) return s;</span></span><br><span class="line">	<span class="comment">//if (left == s_len - 1) &#123; s.erase(left, 1); s_len--; &#125;</span></span><br><span class="line">	<span class="comment">//else reverse_a_word(s, left + 1, s_len - 1);</span></span><br><span class="line">	<span class="comment">//reverse_a_word(s, 0, s_len - 1);</span></span><br><span class="line">	<span class="comment">//return s;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 改进版本02. 先反转整个字符串，再针对字符进行颠倒。本质上一样，但改为只用一次erase。</span></span><br><span class="line">	<span class="type">int</span> s_len = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">reverse_a_word</span>(s, <span class="number">0</span>, s_len - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s_len; i++) &#123;<span class="comment">// 空格全部跳过，完成一个单词后在单词后添加空格，最后删掉最后一个空格</span></span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//是空格</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> begin = index;</span><br><span class="line">			<span class="keyword">while</span> (s[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; i &lt; s_len) &#123;</span><br><span class="line">				s[index++] = s[i++];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">reverse_a_word</span>(s, begin, index - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (i != s_len) s[index++] = <span class="string">&#x27; &#x27;</span>;<span class="comment">//添加空格 移动index</span></span><br><span class="line">			<span class="keyword">else</span> index++;<span class="comment">// 不添加空格，但也移动index</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 考虑只有一个单词，没有任何空格的极端情况</span></span><br><span class="line">	<span class="comment">//if (index-1 != s_len &amp;&amp; index!=0) &#123; s.erase(index-1); &#125;</span></span><br><span class="line">	<span class="comment">//else &#123; s.erase(index - 1);&#125;</span></span><br><span class="line">	<span class="keyword">if</span>(index!=<span class="number">0</span>) &#123; s.<span class="built_in">erase</span>(index - <span class="number">1</span>); &#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="c-string（字符串）处理-知识补充"><a href="#c-string（字符串）处理-知识补充" class="headerlink" title="c++ string（字符串）处理 知识补充"></a>c++ string（字符串）处理 知识补充</h3><p><a href="https://blog.csdn.net/wmy0217_/article/details/104069492">https://blog.csdn.net/wmy0217_/article/details/104069492</a><br>erase的基本用法<br>pos为下标<br><code>erase(pos)</code>删除pos及之后的所有内容<br><code>erase(pos,len)</code>从pos开始删除len个内容，若超过字符串实际范围，会自动将其视为到pos到字符串末尾的长度。二者均没返回值。<br>如果是迭代器，<code>iterator erase(iterator pos);</code>会删除该位置字符，并返回指向下一个有效字符的迭代器。<br><code>iterator erase(iterator first, iterator last);</code>左闭右开，返回指向删除范围之后的第一个有效字符的迭代器。例如<code>string::iterator it = s.erase(s.begin() + 1, s.end() - 1);</code>会返回指向最后一个字符的迭代器。</p>
<p>find的基本用法（c为char类型字符）<br>寻找字符：函数定义为：<code>find(char c, std::size_t pos = 0)</code><br><code>find(c,pos)</code>，从pos开始寻找与c匹配的字符，找不到返回<code>std::string::npos</code>（一个特殊的常量，表示 <code>std::size_t</code> 的最大值）</p>
<p>（额外知识补充：）string的迭代器</p>
<hr>
<h1 id="Javascript版本"><a href="#Javascript版本" class="headerlink" title="Javascript版本"></a>Javascript版本</h1><h2 id="001-88-合并两个有序数组-from-LeetCode-1"><a href="#001-88-合并两个有序数组-from-LeetCode-1" class="headerlink" title="001.88. 合并两个有序数组 from LeetCode"></a>001.<a href="https://leetcode.cn/problems/merge-sorted-array/description" target="_blank">88. 合并两个有序数组 from LeetCode</a></h2>]]></content>
      <categories>
        <category>major</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
</search>
